<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大话设计模式 (一)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[标签（空格分隔）： 设计模式 大话 设计 &gt; 仅供参考 /(ㄒ o ㄒ)/~~ 相关的对应的代码会贴上百度云，是用 JAVA 写的。想看的可以下载（在文章末尾）。暂时只是一些个概念和大体结构，大部分（jihu）是没有代码的，理解起来肯定会比较难（或许根本理解不了），whatever , 只是个人读书笔记，比较粗糙，凑活看吧。哈哈。 一 、简单工厂模式 用一个单独的类来实现易修改和扩展创造实例的过程。 有图 ​ ​ UML 类图图示样例 ​ ​ ‘+’表示 public ‘-‘表示 private ‘#’表示 protected ​ 继承关系用空心三角形 + 实线来表示 如图 ​ ​ 接口关系用空心三角形 + 虚线表示 形如上图（略） ​ 关联关系用实线箭头表示 形如上图（略）、 ​ 聚合关系 ​ 聚合表示一种弱的’拥有‘关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 –《设计模式》第二版 用空心的菱形 + 实线箭头表示 ​ 这个有图哦:happy: ​ ​ 组合关系 ​ 一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 –《设计模式》 ​ 组合关系用实心的菱形 + 实线箭头来表示，连线两端的数字 1,2，被称为基数表明这一端的类可以有几个实例（n 表示无数）。 这个也是有图的 看图 ​ ​ 依赖关系 用虚线箭头表示 UML 最后一张图 ​ 二 、策略模式​ 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP] ​ 面向对象的编程, 并不是越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 ​ 策略模式结构图 ​ ​ 策略模式反思 策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合 –《设计模式》[DPE] ​ 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 –《设计模式》【DPE】 ​ 1. 单一职责原则(SRP)​ 就一个类而言，应该仅有一个引起它变化的原因。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏【ASD】。 ​ 2. 开放 - 封闭原则[简称 OCP]​ 是说软件实体（类，模块，函数等等），应该可以扩展，但是不可修改【ASD】 ​ 开放 - 封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要【ASD】 ​ 3. 依赖倒转原则​ 抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程） ​ 依赖倒转原则 ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。【ASD】 ​ 4. 里氏代换原则【LSP】​ 子类型必须能够替换掉他们的父类型。【ASD】 ​ 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 如图 ​ ​ （依赖倒转其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如） ​ 原则总结​ 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了【ASD】 ​ 三 、装饰模式​ 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活【DP】 ​ 如图装饰模式结构图 ​ ​ 装饰模式实例代码（感觉穿衣服的例子比较有意思，是 java 代码:sad:, 逻辑能看懂:sad:） ​ 后面有例子总结，不想看图的直接跳到后面看。 ​ ​ ​ ​ ​ ​ 小结 ​ 我理解的大概的过程是这样一个工程。就是先从最后的具体服饰类开始往上逐个 装饰 的走。从具体服饰类到服饰类再到 Person 类。（可以从结果显示中看到这一过程）。 ​ ​ ​ 总结 ​ 装饰模式是为已有功能动态地添加更多功能的一种方式，装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有条件地，按顺序地使用装饰功能包装对象了【DP】 ​ （优点：把类中的装饰功能从类中搬除去除，这样可以简化原有的类。这样做的更大的好处是有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。） ​ 四 、代理模式（Proxy）​ 为其他对象提供一种代理以控制对这个对象的访问。【DP】 ​ 代理模式结构图 ​ ​ 注释 ​ 大概的意思就是，有一个公共的接口。中间代理和实际实体两者都实现接口的方法。当具体操作的时候，用代理操作，在代理内部实现实际方法的实例化操作来间接的替代实际方法。 ​ 应用场合 ​ 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。这样就可以达到性能的最优化，比如打开一个很大的 HTML 页面，虽然有很多图片但是还是能很快的打开它，此时看到的是文字，图片是一张一张的下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。其实，浏览器当中是用代理模式来优化下载的。 安全代理，用来控制真实对象访问时的权限[DP]。一般用于对象应该有不同的访问权限的时候。 智能指引，是指当调用真实的对象时，代理处理另外一些事情[DP]。如计算真实对象的引用次数，当该对象没有引用时，可以自动释放它: 或当第一次引用一个持久对象时，将它装入内存: 或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 ​ 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ​ 五 、工厂方法模式​ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 ​ 工厂方法模式 ，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。[DP] ​ ​ 工厂方法模式具体实现示例图 ​ ​ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。 ​ ​ ​ 六 、原型模式​ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP]. ​ 原型模式结构图 ​ ​ 注释 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。 ​ 原型模式中一般在初始化的信息不发生变化的情况下，克隆时最好的办法。这即隐藏了对象创建的细节，又对性能是大大的提高。同样也不用重新初始化对象，而是动态地获得对象运行时的状态。 ​ ‘浅复制’: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 ‘深复制’: 深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ​ 声明：这一模式，本人看的不是太懂。感觉有些东西不通。下面会有一个详细的例子，可以参考一下。不解释。 ​ 简历的深复制实现 ​ ​ ​ ​ ​ ​ 七 、模板方法模式​ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板模式方法处理。 ​ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP] ​ ​ 模板方法模式特点 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现其优势。 提供了一个很好的代码复用平台 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。 ​ 八、迪米特法则​ 迪米特法则（LoD）/ 最少知识原则[J&amp;DP]: 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。[J&amp;DP] ​ 九 、外观模式​ 外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] ​ ​ 十 、 建造者模式​ 建造者模式（Builder）: 将一个复杂对象的建造与它的表示分离，使得同样的建造过程可以创建不同的表示[DP] ​ 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ ​ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。 ​ 十一 、观察者模式​ 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己[DP]。 ​ ​ 观察者模式特点​ 当一个对象的改变需要同时改变其他对象时而且它并不知道具体有多少对象有待改变时，应该考虑使用观察中模式。 ​ 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将两者封装在独立的对象中使他们各自独立的改变和复用。 ​ 委托[这段有点突兀，我理解的大概意思是把观察者也抽象了，直接委托具体的类去实现观察类的抽象。] ​ 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 ​ 十二、抽象工厂模式​ 抽象工厂模式（Abstract Factory）, 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。[DP] ​ ​ 百度云链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (三)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[设计模式分组 一、创建型模式 抽象工厂模式 提供一个创建一系列或相关依赖对象的接口，而无需指定他们具体的类[DP] 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示[DP] 工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到子类[DP] 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP] 单例模式 保证一个类只有一个实例，并提供一个访问它的全局访问点[DP] 总结 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么，谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。[DP] 关于松耦合：内聚性和耦合性 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DP] 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定[DP] 通常设计应是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地[DP] ​ 二、 结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作[DP] 桥接模式 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 组合模式 将对象组合成树形结构以表示‘部分 - 整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性[DP] 装饰模式 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活[DP] 外观模式 为子系统中的一组接口提供一个一致 的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] 享元模式 为运用共享技术有效地支持大量细粒度的对象[DP] 代理模式 为其他对象提供一种代理以控制对这个对象的访问[DP] 总结 问题 : 信息的隐藏促进了软件的复用，如何理解这句话？ ​ 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。 代理模式与外观模式的区别 代理对象代表一个单一对象而外观对象代表一个子系统 代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口[R2P] 代理与适配器之间来说，代理模式是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个对象交涉。而适配器则不需要虚构出一个代表着，只需要为应付特定使用目的，将原来的类进行一些组合[DP]。 三、行为型模式 观察者模式 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 ​ 模板方法模式 定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP]。 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销操作[DP]。 状态模式 允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类[DP]。 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch 中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止[DP]。 四、 行为型模式第二组 解释器模式 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP]。 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[DP] 策略模式 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[DP] 备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态[DP]。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界[DP]。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。[DP] 五、 总结 工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂[DPE]。 面向对象设计模式体现的就是抽象的思想。 类是对对象的抽象 抽象类是对类的抽象 接口是对行为的抽象]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (二)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[十三 、状态模式 状态模式（State）, 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。（DP） 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 使用时机 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据它的状态改变它的行为时，就可以考虑使用状态模式了。 [此处应有（meiyou）代码(zi ji kan)] 十四 、 适配器模式 适配器模式（Adapter）, 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP] 类适配器模式 通过多重继承对一个接口与另一个接口进行匹配，但大部分语言不支持多重继承（C++ 支持） 对象适配器模式 对象适配器模式结构图 代码示例 十五 、 备忘录模式 备忘录（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可将该对象恢复到原先保存的状态[DP]。 [DP] 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来[DP]. 当角色的状态改变时，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 十六 、 组合模式 组合模式（Composite）: 将对象组合成树形结构以表示‘部分 - 整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。[DP] 》接口是一种约束 十七 、 迭代器模式 迭代器模式（Iterator）: 提供了一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。[DP] foreach 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据 十八 、 单例模式 单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。[DP] 通常我们可以用一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的办法。[DP] 十九、 桥接模式 继承的麻烦 对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新问题，则父类必须重写或被其他更换的类替换。这种依赖关系限制了灵活性并最终限制了复用性。[DP] 在面向对象设计中，我们有一个很重要的设计原则，那就是合成 / 聚合复用原则。即优先使用对象合成 / 聚合，而不是类继承。[DP] 合成 / 聚合复用原则(CARP): 尽量使用合成 / 聚合，尽量不要使用类继承。[J&amp;DP] 聚合表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分: 合成表示一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]（看图） 好处 优先使用对象的合成 / 聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。[DP] 桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 二十、 命令模式 命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化; 对请求进行排队或记录请求日志，以及支持可撤销的操作。[DP] 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记入日志 允许接受请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他的类，因此增加的新的具体命令类很容易。 命令模式把请求一个操作的对象与知道怎样执行一个操作的对象分隔开[DP] ​ 二十一、 责任链模式 责任链模式（Chain of Responsibility）: 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[DP] 职责连的好处 可简化对象的互相连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。[DP] 可随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性[DP] 二十二、 中介者模式 中介者模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 应用场景 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 二十三 、享元模式 享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象[DP] 优点 享元模式可以避免大量相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。[减少对象的实例化数量] 二十四、 解释器模式 解释器模式（Interpreter）: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP] 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题[DP] (正则表达式是它的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式) 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式[DP] 解释器模式可以很容易地改变或扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。其也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写[DP] 举个例子就是人工智能机器人，机器人把人的具体指令解释成相应的行为。 二十五、 访问者模式 访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它可以使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作[DP] 访问者模式应用 适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 访问者模式使得增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式通常都会使增加新的数据结构变化困难。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (四)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[面向对象基础 类的定义: 类就是具有相同的属性和功能的对象的抽象的集合。构造方法: 只针对于 JAVA 实例化 :对类进行实例化，构造方法与类同名，无返回值，也不需要 void, 在 new 时候调用。 构造方法 :所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了。 方法重载 :方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型。 属性和修饰符 :属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。[属性的名称一般首字母大写，而字段则一般首字母小写或前加‘_’]。（字段和属性时不同的。属性是特殊的方法，可以给对应的字段赋值） 属性有两个方法 get 和 set。get 访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用。set 访问器没有显示设置参数，但它有一个隐式参数，用关键字 value 表示，它的作用是调用属性时可以给内部的字段或引用赋值。 封装 :每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。 继承 子类拥有父类非 private 的属性和功能。 子类具有自己的属性和功能。 子类还可以以自己的方式实现父类的功能（方法重写）。 子类构造方法需要调用父类同样参数类型的构造方法，用 base 关键字代表父类。（对于构造方法，其不能被继承，只能被调用） 继承显然是一种类与类之间的强耦合的关系。 多态 :多态表示不同的对象可以执行相同的动作。但要通过它们自己的实现代码来执行。 添加（virtual）关键字虚拟化父类的成员。子类可以选择使用（override）关键字，将父类实现替换为它自己的实现，这就是方法重写 Override, 或者叫做方法覆写。 原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。[AMNFP] 抽象类 : 抽象类不能实例化。 抽象方法是必须被子类重写的方法。（抽象方法可以被看作是没有实现体的虚方法） 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类[J&amp;DP] 接口 :接口是把隐式公共方法和属性结合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。 不能实例化。不能有构造方法和字段。不能有修饰符。不能声明虚拟的或静态的。 声明接口在语法上与声明抽象类完全不同，但不允许提供接口中任何成员的执行方式。 实现接口的类就必须要实现接口中的所有方法和属性。 接口的命名，前面要加一个大写字母’I’(规范) 抽象类和接口的区别 形态上来说​ 抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口。 设计模式上来说​ 1. 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，他们的共性就是抽象 ​ 2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。 ​ 3. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛华出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。 ​ 4.[抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的] 泛型 :泛型是具有占位符（类型参数）的类、接口、和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符：类型参数作为其字段的类型或其方法的参数类型出现[MSDN]。 不是太懂，来个例子，自己领会吧:sad: 以下文字概念反正我没太懂 通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基结合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱[MSDN]。 委托和事件 :委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程[PC#] 委托对象用关键字 delegate 来声明，而事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。事件用 event 关键字声明。 主要参考文献 [DP] 《设计模式：可复用面向对象软件的基础》 [DPE] 《设计模式解析》 [ASD] 《敏捷软件开发：原则、模式和实践》 [RIDEC] 《重构–改善既有代码的设计》 [J&amp;DP] 《Java 与模式》 [R2P] 《重构与模式》 [Head First Design Patterns] ​ 再次贴上百度云代码链接 相关代码]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[标签（空格分隔）： 设计模式 大话 设计 仅供参考 /(ㄒ o ㄒ)/~~ ​ ​ 相关的对应的代码会贴上百度云，是用 JAVA 写的。想看的可以下载（在文章末尾）。暂时只是一些个概念和大体结构，大部分（jihu）是没有代码的，理解起来肯定会比较难（或许根本理解不了），whatever , 只是个人读书笔记，比较粗糙，凑活看吧。哈哈。 一 、简单工厂模式​ 用一个单独的类来实现易修改和扩展创造实例的过程。 有图 ​ ​ UML 类图图示样例 ​ ​ ‘+’表示 public ‘-‘表示 private ‘#’表示 protected ​ 继承关系用空心三角形 + 实线来表示 如图 ​ ​ 接口关系用空心三角形 + 虚线表示 形如上图（略） ​ 关联关系用实线箭头表示 形如上图（略）、 ​ 聚合关系 ​ 聚合表示一种弱的’拥有‘关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 –《设计模式》第二版 用空心的菱形 + 实线箭头表示 ​ 这个有图哦:happy: ​ ​ 组合关系 ​ 一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 –《设计模式》 ​ 组合关系用实心的菱形 + 实线箭头来表示，连线两端的数字 1,2，被称为基数表明这一端的类可以有几个实例（n 表示无数）。 这个也是有图的 看图 ​ ​ 依赖关系 用虚线箭头表示 UML 最后一张图 ​ 二 、策略模式​ 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP] ​ 面向对象的编程, 并不是越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 ​ 策略模式结构图 ​ ​ 策略模式反思 策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合 –《设计模式》[DPE] ​ 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 –《设计模式》【DPE】 ​ 1. 单一职责原则(SRP)​ 就一个类而言，应该仅有一个引起它变化的原因。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏【ASD】。 ​ 2. 开放 - 封闭原则[简称 OCP]​ 是说软件实体（类，模块，函数等等），应该可以扩展，但是不可修改【ASD】 ​ 开放 - 封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要【ASD】 ​ 3. 依赖倒转原则​ 抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程） ​ 依赖倒转原则 ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。【ASD】 ​ 4. 里氏代换原则【LSP】​ 子类型必须能够替换掉他们的父类型。【ASD】 ​ 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 如图 ​ ​ （依赖倒转其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如） ​ 原则总结​ 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了【ASD】 ​ 三 、装饰模式​ 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活【DP】 ​ 如图装饰模式结构图 ​ ​ 装饰模式实例代码（感觉穿衣服的例子比较有意思，是 java 代码:sad:, 逻辑能看懂:sad:） ​ 后面有例子总结，不想看图的直接跳到后面看。 ​ ​ ​ ​ ​ ​ 小结 ​ 我理解的大概的过程是这样一个工程。就是先从最后的具体服饰类开始往上逐个 装饰 的走。从具体服饰类到服饰类再到 Person 类。（可以从结果显示中看到这一过程）。 ​ ​ ​ 总结 ​ 装饰模式是为已有功能动态地添加更多功能的一种方式，装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有条件地，按顺序地使用装饰功能包装对象了【DP】 ​ （优点：把类中的装饰功能从类中搬除去除，这样可以简化原有的类。这样做的更大的好处是有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。） ​ 四 、代理模式（Proxy）​ 为其他对象提供一种代理以控制对这个对象的访问。【DP】 ​ 代理模式结构图 ​ ​ 注释 ​ 大概的意思就是，有一个公共的接口。中间代理和实际实体两者都实现接口的方法。当具体操作的时候，用代理操作，在代理内部实现实际方法的实例化操作来间接的替代实际方法。 ​ 应用场合 ​ 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。这样就可以达到性能的最优化，比如打开一个很大的 HTML 页面，虽然有很多图片但是还是能很快的打开它，此时看到的是文字，图片是一张一张的下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。其实，浏览器当中是用代理模式来优化下载的。 安全代理，用来控制真实对象访问时的权限[DP]。一般用于对象应该有不同的访问权限的时候。 智能指引，是指当调用真实的对象时，代理处理另外一些事情[DP]。如计算真实对象的引用次数，当该对象没有引用时，可以自动释放它: 或当第一次引用一个持久对象时，将它装入内存: 或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 ​ 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ​ 五 、工厂方法模式​ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 ​ 工厂方法模式 ，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。[DP] ​ ​ 工厂方法模式具体实现示例图 ​ ​ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。 ​ ​ ​ 六 、原型模式​ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP]. ​ 原型模式结构图 ​ ​ 注释 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。 ​ 原型模式中一般在初始化的信息不发生变化的情况下，克隆时最好的办法。这即隐藏了对象创建的细节，又对性能是大大的提高。同样也不用重新初始化对象，而是动态地获得对象运行时的状态。 ​ ‘浅复制’: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 ‘深复制’: 深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ​ 声明：这一模式，本人看的不是太懂。感觉有些东西不通。下面会有一个详细的例子，可以参考一下。不解释。 ​ 简历的深复制实现 ​ ​ ​ ​ ​ ​ 七 、模板方法模式​ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板模式方法处理。 ​ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP] ​ ​ 模板方法模式特点 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现其优势。 提供了一个很好的代码复用平台 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。 ​ 八、迪米特法则​ 迪米特法则（LoD）/ 最少知识原则[J&amp;DP]: 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。[J&amp;DP] ​ 九 、外观模式​ 外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] ​ ​ 十 、 建造者模式​ 建造者模式（Builder）: 将一个复杂对象的建造与它的表示分离，使得同样的建造过程可以创建不同的表示[DP] ​ 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ ​ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。 ​ 十一 、观察者模式​ 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己[DP]。 ​ ​ 观察者模式特点​ 当一个对象的改变需要同时改变其他对象时而且它并不知道具体有多少对象有待改变时，应该考虑使用观察中模式。 ​ 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将两者封装在独立的对象中使他们各自独立的改变和复用。 ​ 委托[这段有点突兀，我理解的大概意思是把观察者也抽象了，直接委托具体的类去实现观察类的抽象。] ​ 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 ​ 十二、抽象工厂模式​ 抽象工厂模式（Abstract Factory）, 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。[DP] ​ ​ 百度云链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 安全]]></title>
    <url>%2F2017%2F08%2F26%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[根本原则：数据与代码分离 同源策略1. 当 JS 被浏览器认为来自不同源是，请求被拒绝。2. 影响同源策略的因素 host(域名，IP 地址，子域名，端口和协议)。3.EXCEPT：script . img .iframe . link 标签可跨区加载资源而不受同源策略的影响。（原因是都带着 src 属性） 攻击手段类型 1. XSS 跨站脚本攻击 总的来说就是引用上面描述的不受同源策略影响的标签引入不合法的代码来进行攻击主要有四种 反射型 XSS 存储型 XSS DOM Based XSS XSS Payload Cookie 劫持攻击等 2. CSRF Cross Site Request Forgery 跨站点请求伪造 风险在于那些通过基于受信任的输入 form 和对特定行为无需授权的已认证的用户来执行某些行为的 web 应用。已经通过被保存在用户浏览器中的 cookie 进行认证的用户将在完全无知的情况下发送 HTTP 请求到那个信任他的站点，进而进行用户不愿做的行为。使用图片的 CSRF 攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用 JavaScript。 –百度百科 3.Click Jacking 点击劫持 点击劫持，clickjacking，也被称为 UI- 覆盖攻击。这个词首次出现在 2008 年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了 HTML 中 iframe 标签的透明属性。 4.SQL 注入 盲注（Blind Injection） 攻击存储过程 编码问题 Session 劫持 如果 SessionID 是保存在 cookie 中的，则这种攻击称为 cookie 劫持 Session Fixation（固定） 攻击：在用户登录网站的过程中，如果登陆前后用户的 sessionID 没有发生变化，则会存在 session fixation 问题 预防 SQL 注入的方式1. 使用预编译语句，绑定变量2. 使用存储过程3. 检查数据类型4. 使用安全函数 5.OAuth（单纯的名词解释）OAuth 是一个在不提供用户名密码的情况下授权第三方应用访问 web 资源的安全协议。 6. 绕过文件上传检查功能 1230x00 被认为是终止符[\0] 为十六进制的 0x00 字符 会利用上述特性截端字符串为脚本语言。 设计安全的文件上传功能1. 文件上传的目录设置为不可执行2. 判断文件类型3. 使用随机数改写文件名和文件路径4. 单独设置文件服务器的域名 在加密算法的选择和使用上 有一些建议1，不要使用 ECB 模式。2，不要使用流密码比如 RC4.3，使用 HMAC-SHAI 代替 MD5(甚至是 SHAI).4, 不要使用相同的 key 做不同的事情。5，salts 与 IV 需要随机产生。6，不要自己实现加密算法，尽量使用安全专家已经实现好的库7，不要依赖系统的保密性。 当不知道如何选择时1，使用 CBC 模式的 AES256 用于加密。2. 使用 HMAC-SHA512 用于完整性检查。3，使用带 salt 的 SHA-256 或 SHA-512 用于 Hashing. 7.DDOS 分布式拒绝服务 Distributed Denial of Service 最主要的便是限制请求频率，比如无限占用 http 请求，缓慢多次发送 http 请求。 Slowloris 攻击 1 以极低的速度往服务器发送 HTTP 请求，在正常的 HPPT 包头中，是以两个 CLRF（\r\n\r\n）表示 HTTP Headers 部分结束的。 HTTP POST DOS1在发送 HTTP POST 包是，指定一个非常大的 Content-Length 值，然后以很低的速度发包，比如 10~100s 发一个字节，保持住这个链接不断开。 Server Limit Dos1（Apache 所能接受的最大 HTTP 包头大小为 8192 字节（request header） request body 默认最大限制为 2GB）超过指定大小服务器会返回一个 4xx 错误。 正则 ReDOS1一种代码实现上的缺陷，正则表达式写的不好，有可能被恶意输入利用，消耗大量资源，从而造成 DOS。 小结 1 应用层拒绝服务攻击是传统的网络拒绝服务攻击的一种选择，本质也是对有限资源的无限滥用所造成的，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。 8. PHP 安全 文件包含漏洞 常见的导致文件包含的函数如下：PHP：include,require,fopen(),readfile();(PHP 内核并不会在意被包含的文件是什么类型)要想成功利用文件包含漏洞，需要满足下面两个条件： include()等函数通过动态变量的方式引入需要包含的文件。 用户能够控制该动态变量。 本地文件包含（LFI）能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞。PHP 配置设置 open_basedir 的作用是限制在某个特定目录下 PHP 能打开的文件，其作用与 safe_mode 是否开启无关。 远程文件包含PHP 的配置选项 allow_url_include 为 ON 的话，则 inlude/require 函数是可以远程加载文件的（RFI）。 PHP 会为上传文件创建临时文件，其目录在 php.ini 的 upload_tmp_dir 中定义，但改值默认为空，此时在 Linux 下回使用 /tmp 目录，在 Windows 下会使用 C:\windows\temp 目录。 变量覆盖漏洞 全局变量覆盖register_globals PHP 配置文件 unset()默认只会销毁局部变量，而要销毁全局变量必须使用 $GLOBALS; extract()变量覆盖 extract() 函数能将变量从数组导入当前的符号表。 遍历初始化变量 常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖（按下不表）。 import_request_variables 变量覆盖 次函数将 GET,POST,Cookie 中的变量导入到全局。 parse_str()变量覆盖 parse_str() 函数往往被用于解析 URL 的 query string.eg. 123$var = &apos;init&apos;;parse_str($_SERVER[&apos;QUERY_STRING&apos;]);print $var; 防止变量覆盖的安全建议 确保 register_globals = OFF, 若不能自定义 php.ini, 则应该在代码中控制。 熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。 养成初始换变量的好习惯。 代码执行漏洞 phpMyAdmin3.4.3.1 远程代码执行漏洞 MyBB 1.4 远程代码执行漏洞 挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用过程中用户是否有可能控制输入。 “文件写入”执行代码 其他执行代码方式 直接执行代码函数 eval(),assert(),exec(),shell_exec() 文件包含 本地文件写入 preg_replace()代码执行 preg_replace() 的第一个参数如果存在 /e 模式修饰符，则许代码执行。 动态函数执行 Curly Syntax {}将执行花括号间的代码，并将结果替换回去。 回调函数执行代码 unserialize()将导致代码执行 能将序列化的数据重新映射为 PHP 变量。 定制安全的 PHP 环境 register_globals = ON. open_basedir = /home/web/html/(指定目录) allow_url_include = offallow_url_fopen = off. display_errors = off log_errors = on magic_quotes_gpc = OFF. cgi.fix_pathinfo = 0(如果 PHP 以 CGI 的方式安装，则需要关闭此项，以避免出现文件解析问题) session.cookie_httponly = 1 session.cookie_secure = 1. sefe_mode disable_functions 能够在 PHP 中禁用函数disable_functions = eg… 10. WEB SERVER 配置安全 主要有五个方面（详略）1.apache 安全 2.nginx 安全3.jBoss 远程命令执行4.Tomcat 远程命令执行5.HTTP Parameter Pollution(通过 GET 或 POST 向服务器发起请求时，提交两个相同的参数) 入侵检测 常见的安全监控产品有 IDS(入侵检测系统)，IPS(入侵防御系统)，DDOS 监控设备。WAF(web 应用防火墙) ModSecurity:Apache 的一个 Module. 他能获取到所有的访问 Apache Httpd Server 的请求，并根据自己的规则对这些请求进行匹配，以检测那些请求存在攻击行为。 1声明：纯手打总结，劳动不易，转载请附上原文链接。谢谢支持]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>web 安全 协议 HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月专业书籍读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[程序员的思维修炼：开发认知潜能的九堂课 亨特 自由的代价是永远提高警惕。 ——约翰•菲尔波特•柯伦的名言, 1790 年 ​ 对于专家来说最致命的弱点是像专家一样行动。一旦你相信自己的专业水平，你就会对其他的可能性视而不见。你停止了好奇心。你可能开始抵制所属领域的改变，担心在你花费了很多努力才得以精通的主题上失去权威。你自己的判断和看法不再支持你，而是囚禁你。 不管你能做什么，或者期望自己能做什么，现在就开始做。勇敢可以给人智慧、力量和神奇。现在就开始做吧。 ——歌德 ​ 如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继续发酵，这当然没问题。​ 好问题是没有答案的。它不是一个需要拧紧的螺栓，而是一颗种下的种子，由它可以收获一片思想的绿洲。 ——约翰•安东尼•查尔迪（John Anthony Ciardi，1916—1986），美国诗人和评论家 ​ 看法是基于预测的。 Perception is based on prediction.​ 很多感知是基于预测的，预测则基于情境和过去的经验，以至于当前的、实时的输入被抛在了后面。​ 认知胜过尝试 ​ 开头把事情做好并不重要，重要的是最后把事情做好。在任何不平凡的工作中，你都会犯错误。​ 错误有益于我们，因为它们让我们思索到底发生了什么，知道什么地方错了，然后通过理解，纠正它。​ 他人即地狱（L’enfer, c’est les autres）。 ——让•保罗•萨特，法国思想家、作家、存在主义哲学大师 ​ 在你出生时，世界上的任何事情都是平凡的，都是世界运转的天然组成部分。当你在十五岁到三十五岁之间时，世界上创造出的任何事物都是新鲜的、令人振奋的、革命性的，你可能以此为职业。三十五岁之后创造出的任何事物都是有悖于事物的自然顺序的。 ——道格拉斯•亚当斯，《怀疑的鲑鱼》​ ，并将它们组装成最合适的表现形式，这就是创作。​ 创造来自于选择和组装，它要选择最合适的部 ​ 设计并不是创造美，美来自于选择、共鸣、同化和爱 ​ 达尔文说过：“无知往往来自于自信而不是知识。 黑客与画家 –保罗·格雷厄姆 以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。 ​ 「“弱即是强”指的是一种软件传播的模式，由 Common Lisp 专家理査德·加布里埃尔（Richard P. Gabriel）于 1991 年在 Lisp: Good News, Bad News, How to Win Big（http://www.dreamsongs.com/WIB.html）一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中的一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能（“弱”）反而是更好的选择（“强”），因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力 任何 C 或 Fortran 程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是 bug 的、运行速度很慢的 Common Lisp 实现 大公司可以互相模仿，但是创业公司就不行。我觉得很多人没有意识到这一点，尤其是一些创业者 essay（论文）这个词来自法语的动词 essayer，意思是“试试看”。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。 设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。 编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。 所谓“编译器”，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。 推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。 科学和工程学的一些最重大的发现在形式上往往很简单，会使得你觉得自己也想到过。 德国包豪斯（Bauhaus）学派的设计师采纳了美国建筑师路易斯·沙利文（Louis Sullivan）的观点“功能决定形式”（form follows function）， 但是他们实际上的理解是“功能应当决定形式”^。真实情况是，如果开发“功能”非常艰难，那么“形式”将不得不全部都由“功能”决定，因为没有多余的精力再来单独开发“形式”了。人们常常觉得野生动物非常优美，原因就是它们的生活非常艰苦，在外形上不可能有多余的部分了。 当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。 ​ 一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程做出的事情。 ​ 技术的发展加大了贫富差距，这是不是一个社会问题？好像没有那么严重。技术在加大收入差距的同时，缩小了大部分的其他差距 ​ 在现实中，财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的 ​ ，他一个人的价值真的等于我们 100 个人的价值吗？你想一想，一个篮球队会同意用一个运动员交换 100 个普通人吗？如果苹果公司不是由乔布斯掌管，而是由一个 100 人组成的委员会掌管，那么这家公司的下一代产品会是什么样 ^？人与人之间的差别并不是那么稳定的线性关系。也许 CEO 和运动员的技能和决心只比普通人高出 10 倍（倍数不重要），但是人与人之间就是存在着重大差别。 ​ 每个人的技能不同，导致收入不同，这才是贫富分化的主要原因，正如逻辑学的“奥卡姆剃刀”原则所说，简单的解释就是最好的解释。 为什么财富的分配问题引起这么多争论？部分原因是反对声最大的人当中，很多人都少有创造财富的经验：大学生、继承人、教授、政客、新闻记者。（如果你在酒吧里听过大家议论体育赛事，你一定很熟悉这种现象。） ​ 一旦自己的财产有了保证，那些想致富的人就会愿意去创造财富，而不是去偷窃。由此导致的新技术不仅被转化成财富，还被转化成军事力量。隐形飞机的理论是由前苏联数学家提出的，但是因为前苏联没有计算机工业，它就只能是一个理论，无法变成产品。前苏联没有足够快的硬件来完成设计飞机所需要的大量计算。 ​ 理解这些有助于回答一个重要的问题：为什么欧洲在历史上变得如此强大？是因为欧洲优越的地理位置，还是因为欧洲人天生就比较优秀，或者是宗教原因？答案（或者至少是近因）可能就是欧洲人接受了一个威力巨大的新观点：允许赚到大钱的人保住自己的财富。 ​ 缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。开发新技术是非常痛苦的经历，正如爱迪生所说，百分之一的灵感加上百分之九十九的汗水。没有财富的激励，就不会有人愿意去做技术革新。工程师愿意接受普通薪水去做一些诱人的项目（比如战斗机和登月火箭），而与日常生活关系更密切的技术革新（比如电灯泡和半导体）只能由创业者来发明。 ​ 「充分条件在这里可能也成立。但是如果成立的话，为什么工业革命没有早一点发生呢？两个可能的（但是互相排斥的）解释是：（a）变化其实早发生了，工业革命只是一系列革命中的一环，（b）中世纪的城镇存在垄断经营和行会制度，延缓了新生产方式的诞生。」 ​ 创造财富不是致富的唯一方法。在人类的历史长河中，它甚至不是最常见的方法。就在几个世纪前，财富的主要来源还是矿石、奴隶、农奴、土地、牲畜，而快速获得财富的方法只有继承、婚姻、征服、没收。所以，很自然地，财富的名声不好。 ​ ^「平均数（mean）是算数平均值，会受到个别极端值的影响，中位数（median）是最中间的那个值，不受个别极端值的影响。所以，这句话的意思就是，由于存在个别极其成功的创业者，所以回报的平均值被拉到了 30 倍，但是大多数创业者其实都以失败告终，所以中位数是 0。——译者注」 「近代历史上，政府有时都搞不清楚金钱和财富的区别。亚当·斯密在《国富论》中提到，许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是，黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。」 ​ 经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。 1989 年，一些聪明的研究人员设计了一个实验，给放射科医生看胸部 X 光片，请他们判断病人有没有肺癌迹象。研究人员记录了医生检査 X 光片时的眼球运动 ^。研究发现，即使那些医生漏掉了一个癌症病灶，他们的目光通常也会在那个地方停留一会。这说明他们的头脑深处已经意识到那里有问题，但是这种深层的反应没有上升为自觉的意识。我认为，类似的思维机制存在于每个人的头脑中，很多看似叛逆的“异端邪说”，早就“潜伏”在我们的思维深处。如果我们暂时关闭自我审查意识，它们就会第一个浮现出来。 ​ 大公司为了避免设计上的灾难，选择了减少设计结果的标准差。但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。大公司只要做到不太烂，就能赢。 「塞缪尔·约翰逊在他编辑的《莎士比亚戏剧集》的前言中写道：“他（莎士比亚）的影响远远超过他的时代，时间就是对他文学成就的检验。不管他的作品从那时的暗语、风俗、政治局势之中，得到过怎样的优势，这些优势都已经消逝多年了。他在毎一幕戏剧中，通过模拟那时的生活所产生的每一个欢乐的主题或悲伤的动机，都已经趋于平淡，而不再是戏剧的亮点。贵族的宠爱和对手的竞争，都不再产生效果，朋友和敌人都走进了坟墓，他的作品再也不是支持一方、打击另一方的舆论工具；它们既不能产生虚名，也不会带来恶意的攻击。人们阅读这些作品，只有一个理由，那就是欣赏作品本身。因此，只有人们真正欣赏它们，才会发出赞美……”」 塞缪尔·约翰逊 ^ 说过，人们对一个作家的评价，需要 100 年才能达成一致 ^^。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。 当工作的专业程度越来越高时，我们就必须接受更长时间的训练。工业化时代来临之前，儿童最晚大约在 14 岁就要参加工作，如果是在农庄（那个时代大多数人生活在农村），参加工作的时间就更早。如今，只要一个青少年读大学，他就要等到 21 岁或 22 岁才开始全职工作。如果再读更髙的学位，比如医学博士或哲学博士，可能要拖到 30 岁才能完成学业。 这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式 ^。 你的灯亮着吗？：发现问题的真正所在 唐纳德·高斯 人们永远没有足够的时间去考虑到底是不是想要它，但永远有足够的时间去为之后悔 ​ 但在更多情况下，交流不畅不是困难的根源。对于不了解的事情，或者不想了解的事情，人们无法有效交流。​ 大多数情况下，问题的根源在你自己身上。​ 在社会上，很多问题源自系统的设计者和决策者，他们并未亲身体会过应该由他们“负责任”的问题。​ 只要可行，人们会首先把问题置于让自己觉得最舒适的语义层面上 ​ 每转换一次视角，都会发现新的不协调之处。 在把一项“解决方案”付诸实践之前从各个视角对其审视一遍，不是比等到出现灾难性后果才意识到问题存在好得多吗？​ 在这次大型“实验”之前，没有人确切知道为什么每年有 50000 人死在高速公路上。汽车制造商归罪于司机，与制酒业无关的所有人指责醉酒驾驶者是罪魁祸首，但从没有人因为立法者设定了如此之高的车速上限而责怪他们。​ 每一个解决方案都是下一个问题的来源。 我们永远都没法避开问题。问题、解决方案、新问题循环出现，构成了无尽的链条。能指望的最理想状态就是新问题比我们“已经解决”的问题要好对付一些。​ 问题就是理想状态和现实状态之间的差别。 人月神话 –弗雷德里克·布鲁克斯 人件：高生产率的项目和团队 ​ 编程人员被屏蔽而不是暴露在他人模块内部结构面前。这种情况下，工作效率最高 ​ 老板的不良反应肯定会对信息的完全公开造成压制；相反，仔细区分状态报告、毫无惊慌地接收报告、决不越俎代庖，将能鼓励诚实的汇报。​ 状态的获取是困难的，因为下属经理有充分的理由不提供信息共享 ​ 系统文档中的巨大容量带来了新的不理解问题 [例如，看看 Unix]，但是它比大多数未能详细描述编程系统特性的短小文章更加可取。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。​ 很容易为不同的晋升线建立相互一致的薪水级别，但要同等威信的建立需要一些强烈的心理措施：相同的办公室、一样的支持和技术调动的优先补偿 ​ 目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。​ 户的实际需要和用户感觉会随着程序的构建、测试和使用而变化 ​ 将开发的第一个系统–丢弃原型–发布给用户，可以获得时间，但是它的代价高昂–对于用户，使用极度痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使最好的再设计也难以挽回名声 ​ 对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。​ 一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法–既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。​ 向软件项目中增派人手从三个方面增加了项目必要的总体工作量：任务重新分配本身和所造成的工作中断；培训新人员；额外的相互沟通。​ 2.10 因为我们对自己的估计技术不确定，所以在管理和客户的压力下，我们常常缺乏坚持的勇气。 2.11 Brook 法则：向进度落后的项目中增加人手，只会使进度更加落后。​ 在若干人员中分解任务会引发额外的沟通工作量–培训和相互沟通。 2.8 关于进度安排，我的经验是为 1/3 计划、1/6 编码、1/4 构件测试以及 1/4 系统测试。​ 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。​ .. 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外 ​ 。实际上，类的容易重用和通过继承方便地定制是面向对象技术最吸引人的地方 ​ 在所有被误导的科学探索中，最悲惨的莫过于对一种能够将一般金属变成金子的物质，即点金石的研究。这个由统治者不断地投入金钱，被一代代的研究者不懈追求的、炼金术中至高无上的法宝，是一种从理想化想象和普遍假设中–以为事情会像我们所认为的那样–提取出的精华。它是人类纯粹信仰的体现，人们花费了大量的时间和精力来认可和接受这个无法解决的问题。即使被证明是不存在，那种寻找出路和希望能一劳永逸的愿望，依然十分的强烈。而我们中的绝大多数总是很同情这些明知不可为而为之的人，因此它们总是得以延续。所以，将圆形变方的论文被发表，恢复脱发的洗液被研制和出售，提高软件生产率的方法被提出并成功地推销。​ 在软件开发中，我称为”必要（essence）”的部分是构思这些概念上的结构；我称为”次要（accident）”的部分指它的实现过程。​ 那些想看到完美方案的人，其实在心底里就认为它们以前不存在，以后也不可能出现。 - 亚历山大·波普，批判散文 ​ 没有任何软件机构可以忽视这项挑战。尽管公司可能缺少良好的管理人员，但决不会比良好设计人员的需求更加迫切，而卓越的管理人员和设计人员都是非常缺乏的。大多数机构花费了大量的时间和精力来寻找和培养管理人员，但据我所知，它们中间没有任何的一家在寻求和培育杰出的设计人员上投入相同的资源，而产品的技术特色最终依赖于这些设计人员。​ 其中的差异并不小–就象萨列里和莫扎特。一个接一个的研究显示，非常卓越的设计者产生的成果更快、更小、更简单、更优雅，实现的代价更少。卓越和一般之间的差异接近于一个数量级。​ 。低劣设计和良好设计之间的区别可能在于设计方法中的完善性，而良好设计和卓越设计之间的区别肯定不是如此。卓越设计来自卓越的设计人员。软件开发是一个创造性的过程。完备的方法学可以培养和释放创造性的思维，但它无法孕育或激发创造性的过程。​ 无限扩展。日常生活中，建筑有可能发生变化，但众所周知，建筑修改的成本很高，从而打消了那些想提出修改的人的念头。​ 所有成功的软件都会发生变更。现实工作中，经常发生两种情况。当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。​ 自文档化方法 ​ 不了解，就无法真正拥有。 - 歌德 ​ 减少角色的冲突。首先老板必须区别行动信息和状态信息。他必须规范自己，不对项目经理可以解决的问题做出反应，并且决不在检查状态报告的时候做安排。我曾经认识一个老板，他总是在状态报告的第一个段落结束之前，拿起电话发号施令。这样的反应肯定压制信息的完全公开。​ 关键的地方和构建无 bug 程序的核心，是把系统的结构作为控制结构来考虑，而不是独立的跳转语句。这种思考方法是我们在程序设计发展史上向前迈出的一大步 ​ 我能召唤遥远的精灵。 那又怎么样，我也可以，谁都可以，问题是你真的召唤的时候，它们会来吗？ - 莎士比亚，《亨利四世》，第一部分 ​ 这正是历史的关键。使用卓越的能源–构建文明–成立杰出的机构，但是每次总会出现问题。一些致命的缺陷会将自私和残酷的人带到塔尖，接着一切开始滑落，回到到痛苦和堕落。实际上，机器失灵了。看上去，就好像是机器正常启动，跑了几步，然后垮掉了 7。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。令人吃惊的是，该成本受用户数目的严重影响。用户越多，所发现的错误也越多。​ 不过，他提出了一种卓越的见解。他观察到不愿意为设计书写文档的原因，不仅仅是由于惰性或者时间压力。相反，设计人员通常不愿意提交尝试性的设计决策，再为它们进行辩解。”通过设计文档化，设计人员将自己暴露在每个人的批评之下，他必须能够为他的每个结果进行辩护。如果团队架构因此受到任何形式的威胁，则没有任何东西会被文档化，除非架构是完全受到保护的 ​ 数据的表现形式是编程的根本 ​ 规格说明的风格必须清晰、完整和准确。用户常常会单独提到某个定义，所以每条说明都必须重复所有的基本要素，所以所有文字都要相互一致。这往往使手册读起来枯燥乏味，但是精确比生动更加重要。​ 概念的完整性的确要求系统只反映唯一的设计理念，用户所见的技术说明来自少数人的思想。实际工作被划分成体系结构、设计实现和物理实现，但这并不意味着该开发模式下的系统需要更长的时间来创建。经验显示恰恰相反，整个系统将会开发得更快，所需要的测试时间将更少。同工作的水平分割相比，垂直划分从根本上大大减少了劳动量，结果是使交流彻底地简化，概念完整性得到大幅提高。​ 体系结构同实现必须仔细地区分开来。如同 Blaauw 所说的，”体系结构陈述的是发生了什么，而实现描述的是如何实现 3。”他举了一个简单的例子–时钟。它的结构包括表面、指针和上发条的旋钮。当一个小孩知道了时钟的外表结构，他很容易从手表或者教堂上的时钟辨认时间。而时钟的实现，描述了表壳中的事物–很多种动力提供装置中的一种，以及众多控制精度方案的一种。​ 而进度压力却要求很多人员来开发系统。有两种方法可以解决这种矛盾。第一种是仔细地区分设计方法和具体实现。第二种是前一章节中所讨论的、一种崭新的组建编程开发团队的方法。​ 。项目的时间依赖于顺序上的限制，人员的数量依赖于单个子任务的数量。从这两个数值可以推算出进度时间表，该表安排的人员较少，花费的时间较长（唯一的风险是产品可能会过时）。相反，分派较多的人手，计划较短的时间，将无法得到可行的进度表。总之，在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大 ​ 向进度落后的项目中增加人手，只会使进度更加落后。（Adding manpower to a late software project makes it later​ 因为软件开发本质上是一项系统工作–错综复杂关系下的一种实践–沟通、交流的工作量非常大，它很快会消耗任务分解所节省下来的个人时间。从而，添加更多的人手，实际上是延长了，而不是缩短了时间进度。]]></content>
      <categories>
        <category>专业书书摘</category>
      </categories>
      <tags>
        <tag>人月神话 黑客与画家 程序员思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[皮囊 –蔡崇达 我没能说出口的是：厚朴，或许能真实地抵达这个世界的，能确切地抵达梦想的，不是不顾一切投入想象的狂热，而是务实、谦卑的，甚至你自己都看不起的可怜的隐忍。 梦想原来是卑微的执着。 他以为再走进去，就是无限宽广的可能；他以为正在和他对话的，已经是整个世界。 台风在于我从来没有悲伤的色彩，直到那一年。 小王子 –圣. 埃克苏佩里 。如果一个人听任自己被人驯服，那他就要冒流泪的风险…… 重要的东西眼睛是看不见的。 你一直不懂我的爱，这是我的错。不过这并不重要。但是你——你却和我一样傻。祝你幸福……将玻璃罩拿走吧，我不需要。” 我本应该根据事实而不是花言巧语来判断她。她用她的芬芳环绕着我，用她的光辉照耀着我。我真不该离开她……我应该猜出隐藏在她拙劣伎俩背后的所有温情。但我当时太小了，根本不知道怎样去爱她……” 月亮与六便士 –毛姆 恐惧使人们变得残酷无情…… 女人们禀性善良、喜爱虚荣，因此便认为这种感情极富于精神价值。但是在冲动的热情前面，这 种感情是毫无防卫能力的。 这是一种对任何一个人都可能产生的被动的感情，正象藤蔓可以攀附在随便哪株树上一样。因为 这种感情可以叫一个女孩子嫁给任何一个需要她的男人，相信日久天长便会对这个人产生爱情， 所以世俗的见解便断定了它的力量。但是说到底，这种感情是什么呢？它只不过是对有保障的生 活的满足，对拥有家资的骄傲，对有人需要自己沾沾自喜，和对建立起自己的家庭洋洋得意而已。 我觉得，在爱情的事上如 果考虑起自尊心来，那只能有 一个原因：实际上你还是最爱自己 有一些人很不幸，即使他们流露的是最真挚的感情也令人感到滑稽可笑，戴尔克·施特略夫正是这样一个人。 有人说灾难不幸可以使人性高贵，这句话并不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人们变得心胸狭小、报复心更强。 到了这一 地步，对那些不肯受良心约束的人，他就会觉得怎样责骂也不过分，因为他已经是社会的一名成 员，他知道得很清楚，绝对没有力量造自己的反了。 一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”​ 这种生活模式给人以安详亲切之感。它使人想到一条平静 的小河，蜿蜒流过绿茸茸的牧场，与郁郁的树荫交相掩映，直到最后泻入烟波浩渺的大海中。但是大海却总是那么平静，总是沉默无言、声色不动，你会突然感到一种莫名的不安。也许这只是我自己的一种怪想法（就是在那些日子这种想法也常在我心头作祟），我总觉得大多数人这样度过一生好象欠缺一点什么。我承认这种生活的社会价值，我也看到了它的井然有序的幸福，但是 我的血液里却有一种强烈的愿望，渴望一种更狂放不羁的旅途。这种安详宁静的快乐好象有一种 叫我惊惧不安的东西。我的心渴望一种更加惊险的生活。只要在我的生活中能有变迁——变迁和 无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。 人们常常发现一位离了职的首相当年只不过是个大言不惭的演说家；一个解甲归田的将军无非是个平淡乏味的市井英雄。 目送 –龙应台 原来所有自己的当下啊，都是别人的过去。 幸福就是，寻常的日子依旧 幸福就是，生活中不必时时恐惧 你告诉我，什么是家，我就可以告诉你，什么是永恒。 有一段初始的生命，全世界只有这几个人知道，譬如你的小名，或者，你在哪一棵树上折断了手 是的，没有一种笑是铁打的 甚至眼泪也不是…… 你们之中，今天最聪明、最优秀的四个孩子，两个人会成为医生或工程师或商人，另外两个人会终其一生落魄而艰辛。所有其它的人，会经历结婚、生育、工作、退休，人生由淡淡的悲伤和淡淡的幸福组成，在小小的期待、偶尔的兴奋和沉默的失望中过每一天，然后带着一种想说却又说不来的『懂』，作最后的转身离开。」 如果在我们十二岁那年，有人跟我们这样上课，会怎么样？ 当然，没有一个老师，会对十二岁的孩子们这样说话。因为，这，哪能作人生的「座右铭」呢？ 天心月圆 也还相信。 譬如国也许不可爱，但是土地和人可以爱。譬如史也许不能信，但是对于真相的追求可以无止尽。譬如文明也许脆弱不堪，但是除文明外我们其实别无依靠。譬如正义也许极为可疑，但是在乎正义比不在乎要安全。譬如理想主义者也许成就不了大事大业，但是没有他们社会一定不一样。譬如爱情总是幻灭的多，但是萤火虫在夜里发光从来就不是为了保持光。譬如海枯石烂的永恒也许不存在，但是如果一粒沙里有一个无穷的宇宙，一刹那里想必也有一个不变不移的时间。 曾经相信过爱情，后来知道，原来爱情必须转化为亲情才可能持久，但是转化为亲情的爱情，犹如化入杯水中的冰块——它还是冰块吗？ 情人 –杜拉斯 我已经老了，有一天，在一处公共场所的大厅里，有一个男人向我走来。他主动介绍自己，他对我说：“我认识你，永远记得你。那时候，你还很年轻，人人都说你美，现在，我是特为来告诉你，对我来说，我觉得现在你比年轻的时候更美，那时你是年轻女人，与你那时的面貌相比，我更爱你现在备受摧残的面容。” 恨之所在，就是沉默据以开始的门槛。只有沉默可以从中通过，对我这一生来说，这是绵绵久远的苦役。我至今依然如故，面对这么多受苦受难的孩子，我始终保持着同样的神秘的距离。我自以为我在写作，但事实上我从来就不曾写过，我以为在爱，但我从来也不曾爱过，我什么也没有做，不过是站在那紧闭的门前等待罢了。 不要求取得什么，只求从当前的处境中脱身而去。 菊于刀 –本尼德克特 萨苏 刘锋 我们通常为因为财富产生的不平等而感到愤恨，但是在历史上，以财富的不平等代替出身的不平等却是人类的一个进步。因为，人无法选择出身，却可能通过自己的努力致富；虽然依然是不平等，却为每个人在人格上的平等打下了基础。为了争取到这样的不平等，法国付出了几十年不断的革命，英国经历了王位的反复兴废，从欧洲到亚洲染满了血腥……历史的发展中，五十步和一百步差别就是这样大。 荣枯鉴 –冯道 谤而不辩，其事自明，人恶稍减也；谤而强辩，其事反浊，人怨益增也 人微不诤，才庸不荐 位高节低，人贱义薄 人冀人愚而自明，示人以愚，其谋乃大；人忌人明而自愚，智无潜藏，其害无止 l 有的人总希望别人愚蠢而自己聪明，展示在众人面前是很愚笨的，这样的人具有非同小可的谋略；有的人忌妒别人聪明而自己愚蠢，才智也没有能力深深隐藏，这样的人将祸患无穷。 祸于上，无辩自罪者全；祸于下，争而罪人者免 孤独六讲 –蒋勋 这个社会要有一个从群众里走出去的孤独者，他才会比较有思考性，因为他走出去，可以回看群众的状态；如果他在群众当中，便没办法自觉。 我们看高空弹跳、赛车、极限表演，都是藉助观赏他者的冒险，发泄自己生命潜意识里的暴力倾向。 群体的道德意识往往会变成对他人的指责，在西方，道德观已经回归到个体的自我检视，对他人的批判不叫道德，对自己行为的反省才是 少有人走的路 –斯科特. 派克 你不可能宽恕一个没有罪过的人。宽恕只有在有罪裁决后才生效。 停止一个游戏，唯一的方式就是停止， 一个没有灵魂的人就像一张破碎的纸片，盲目地追逐着每一阵风，完全失去了掌控自己的能力，最终会成为魔鬼撒旦的工具，干出许多邪恶的事情。 恶，可以定义为：为了维护病态的自我， 不择手段去毁灭别人的自我。 恩典与个人之间的关系：“就像身体包裹在衣服里，血肉包裹在皮肤里，骨骼包裹在血肉里，心脏包裹在胸腔一样，我们的心灵和身体包裹在上帝的慈善之中。衣服、血肉、骨骼和心脏都会衰朽，而上帝的慈善却永远保持完整。 自由与约束相辅相成，没有约束作基础，自由带来的就不是真正的爱，而是情感的毁灭。 精神贯注表面上的代价之一，就是你迟早要为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中的许多事物，包括子女、婚姻、性爱、晋升和友谊，但唯有这些事物才能够使人生丰富多彩。在拓展自我的过程中，除了痛苦和悲伤，你同样可以收获快乐和幸福。完整的人生势必伴随着痛苦，其中最大的痛苦之一，就是心爱之人或心爱之物的逝去。如果你想避免其中的痛苦，那你恐怕只有完全脱离现实，去过没有任何意义的生活。 有些时候，我们宁可拒绝改变，也不愿忍受改变带来的痛苦，此时我们最需要的就是勇气。勇气，并不意味着永不恐惧，而是面对恐惧时能够坦然行动，克服畏缩心理，大步走向未知的未来。在某种意义上，心智的成熟（也即爱的实质）需要勇气，也需要冒险。 把“爱”挂在口头上，或只在脑海里去想象真正的爱，并以此作为爱的证据，这显然是轻而易举的事情，而表现出爱的行动却相当困难。真正的爱，其价值在于始终如一的行动，这远远大于转瞬即逝的感觉或者精神贯注。真正的爱出自自我意愿，只能依靠实际行动来证明。 ​ 想让别人真正爱你，只有让自己成为值得爱的人 坠入情网本身并不是爱，但它却是爱的神秘架构中最重要的一环。 对于某种事物长期的爱，使我们生活在了精神贯注的境界里，于是，我们的自我界限便开始延伸，延伸到一定程度后，自我界限就会淡化，而这时，我们的心智便获得了成熟 为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由。 哈佛商业评论 对美好事情的期待。比起美好事情，我们可能更钟情的是对其“渴求”的过程 对商场上的成功而言，技巧和好运缺一不可。就像文章开头所说，并没有简单的规则。但总体而言，战略勇气、适应能力和价值观决定的领导力在商场和战场上均可提高成功的可能性。 我们所畅想的新型雇主－雇员契约的重要性在于：虽然它并不以忠诚为基础，但它也不仅仅是纯粹的交易。它是组织与个人之间的联盟，联盟双方都致力于帮助彼此走向成功。 因为这种契约仍旧鼓励人员流动，这有碍于发挥员工生产力。更重要的是，虽然缺乏职业安全感直接促使员工更具适应能力与创业精神，但由于缺乏共同利益，其导致了逆向选择，也就是最具适应力与创业精神的员工反而另谋高就。企业节约了成本，但损失的是创新性与适应能力。 杀死一只知更鸟 –哈珀·李 从马耶拉张嘴喊叫的那一刻起，汤姆就死定了。 她们慢晃摇椅，轻挥罗扇，细斟慢饮地喝着冰水。 这个世界从表面上看来，只是一群香喷喷的女士 因为他刚安慰了我，所以我就说它看起来很可爱，但实际上我什么也没看见。“真不错，杰姆 他告诉过我，说带枪就等于邀请别人来射你。 勇敢是，当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。 道理很简单，不能因为我们开始前已经失败了一百年，就认为我们没有理由去争取胜利。 阿蒂克斯说过去掉那些形容词，剩下的就是事实了 当然不应该那样做，不过他永远不会改变他的生活方式。你不会再抱怨他的孩子们了吧？​ 霍乱时期的爱情 –加西亚. 马尔克斯 他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 ​ 无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了 “你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定 当她在成为寡妇后的第一个早晨醒来，闭着眼睛在床上翻了个身，想找一个更舒服的姿势继续睡下去，就在这一刻，她才真正意识到他死了。也只有在这时，她才察觉到，这是他多年来第一次没有在家过夜。另一个触动她的情境是在餐桌前，但不是因为感到孤单，尽管事实的确如此，而是因为她奇怪地相信，自己正在同某个已不存在的人一起用餐 ​ 她无法摆脱隐藏在心底的怨恨，怨丈夫将她孤零零地遗弃在这汪洋大海之中 ​ 在这么多年一次次精心算计的爱情之后，天真无邪的生涩味道别有一番新鲜的堕落的快乐 “我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。” 曾经，每天的每分每秒都胜似他的盟友，如今却开始算计他 但最终，他还是让步了，弗洛伦蒂诺·阿里萨把镜子挂到了自己家中，却并不是因为那镜框的精雕细琢，而是因为镜子里的那片天地，他爱恋的形象曾在那里占据了两个小时之久 ​ 他们终于彻底了解了对方，在结婚将近三十年时，他们变得好似一个人被分成了两半，常常因为对方猜出自己没有说出口的心事，或者一个抢先把另一个想说的话公之于众的荒唐事件而感到不悦。 ​ 她丈夫爱她胜过一切，胜过世间所有的人，但这也仅仅是为了他自己：这是他的神圣义务。 ，唯一可能的解释——就像她常说的那样——便是她怨恨丈夫明知故犯地为一群黑人牺牲了性命，而唯一正确的牺牲应该是为了她活下去 ​ 但当她们独自去望弥撒时，才逐渐意识到，自己又一次成为自己意愿的主人，当初，为了换取一种安全感，她们不仅放弃了自己家庭的姓氏，甚至放弃了自我，可那种安全感不过是她们做姑娘时许多幻想中的一个罢了。只有她们自己知道，她们曾经疯狂爱着的那个男人——尽管他或许也爱着她们——给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 ​ 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 ​ 说不清究竟是欧洲之行改变了他们，还是爱情改变了他们，因为这两者是同时发生的。它们都起了作用，更深一层说，改变的不仅是他们两人，也是所有人，就像弗洛伦蒂诺·阿里萨在那个不幸的星期日，他们回来两周后，看见他们望完弥撒从教堂中走出来时所察觉到的那样。 ​ 尽管并非有意，但这样处理匿名信的方式是正确的，其实那些不敢留名的人所属的阶层，在历史的嘲弄下，早已习惯了对既成的事实低头 ​ 可洛伦索·达萨以桶匠的大度吞下所受的侮辱，继续执著地依靠智慧创造偶遇胡维纳尔·乌尔比诺的机会，却没有发现其实是胡维纳尔·乌尔比诺付出了更为超常的努力，尽一切可能让两人相遇 “这座城市还真是伟大，”他常常说，“我们用了四百年的时间来摧毁它，至今仍没有达成目的。 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们靠私下里抽签来决定谁做他的女伴，而他也乐得与她们相处，但总是若即若离，始终保持着清雅，直到最后，他不可救药地被费尔明娜·达萨那种质朴的魅力迷住了 ​ 但与那时不同，此刻她没有感到爱情的震撼，而是坠入了失望的深渊。 ​ 四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生 不可避免，苦杏仁的气味总是让他想起爱情受阻后的命运]]></content>
      <categories>
        <category>书摘</category>
      </categories>
      <tags>
        <tag>读书书摘</tag>
      </tags>
  </entry>
</search>
