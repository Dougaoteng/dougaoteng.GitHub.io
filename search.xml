<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[思考 快与慢]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%80%9D%E8%80%83%20%E5%BF%AB%E4%B8%8E%E6%85%A2%2F</url>
    <content type="text"><![CDATA[情感因素在我们对直觉判断和决策的理解上发挥了比以往更大的作用。 鲍迈斯特的小组屡次发现，刻意掌控意志和进行自我控制很辛苦。如果你必须强迫自己去做某件事，而此时这件事又面临一个新的挑战，你就会很不情愿或是根本无法进行自我控制。这种现象被命名为自我损耗（ego depletion）。 想让人们相信谬误有个可靠的方法，那就是不断重复，因为人们很难对熟悉感和真相加以区别。 即我们生来就具有区分自然性和意向性的因果关系的能力，而这一能力也解释了宗教信仰的普遍性。他发现，“我们对物质世界和精神世界的感知完全不同，所以我们才可能对没有灵魂的身体和没有身体的灵魂进行想象”。我们注定能够感知得到的这两种因果关系模式使我们能够很自然地接受众多宗教中都存在的两个主要信念：无形的神是物质世界所有现象的最终原因，而不死的灵魂只是在我们活着时暂时控制我们的躯体，我们死后，灵魂也将离开躯体。 已有证据显示，当人们劳累或是精力耗尽时，更容易受那些空洞却有说服力的信息影响，例如广告，这正说明人们根据已有信息勾勒出的故事的连贯性增强了他们的自信心一个好故事最重要的是信息的前后一致性，而不是其完整性。的确，你常会发现：知道得很少反而可以把已知的所有事物都囊括进连贯的思维模式中。 人们一定不知道通过什么方式将不可能完成的任务简单化了，由此，我们开始研究他们是如何做到这一点的。我们的答案是，当人们按照要求对可能性作出判断时，他们实际上是对其他的事情作了判断，并且认为自己已经完成了判断可能性的任务。遇到很难的“目标问题”时，如果脑海中马上出现了一些与之相关联且容易回答的“启发性问题”的答案，系统 1 通常便会采取这种“替代”的做法，采用替代问题的答案。 思维发散性的自主过程和强度匹配可以使能映射到目标问题的简单问题有一个或多个答案有些情况下会有替代答案，系统 2 会认可这一启发式答案。当然，系统 2 也可以拒绝这个直觉性答案，或者通过整合其他信息来改变它。但是，一个懒惰的系统 2 往往会遵循最省力法则，不经检验就认可某个启发式答案。你不会被难倒，也不必非常努力，甚至都没有注意到自己其实答非所问。此外，你也许都注意不到目标问题很难，因为你的头脑中会很迅速地闪出一个直觉性答案。 系统 1 的特点 ·自主且快速运行，只需付出较少努力，甚至不用付出努力，没有自主控制的感觉。 当发现（搜寻）特殊形式时，能接受系统 2 编控来调动注意力。 在接受了一定的训练后，能够做出熟练的回应，产生直觉。 为联想记忆激发出来的各种想法创造连贯形式。 将认知放松感和真理错觉、愉快的感觉以及放松的警惕感联系起来。 区分常态中令人惊奇之事。 推断原因和意图。。忽略歧义，按捺住心中的疑问。 大情感的一致性（光环效应）。 将注意力集中在当前的证据上，忽略不存在的证据（眼见即为事实）。 作一些基本估测。。通过常态和原型来表现集合，但不要将两者看成一个整体。 通过测量确定不同程度对应的匹配物（比如音量的大小）。 真正去计算，而不是空想（思维的发散性）。 有时用简单点的问题替代难题（启发法）。 对变化的感知比对形态的感知更敏锐（前景理论）。 可能性作出过高估计。 ·对数量越来越不敏感（心理物理学）。 ·对损失的反应比获得更强烈（损失厌恶）。* ·严密设计决策问题，分别进行讨论 锚定效应。人们在对某一未知量的特殊价值进行评估之前，总会事先对这个量进行一番考量，此时锚定效应就会发生。这一效应是实验心理学中最可靠也最稳健的结果，即估测结果和人们思考的结果很相近，就好比沉入海底的锚一样。 媒体不仅影响了公众的兴趣，也受到公众兴趣的影响。 效用层叠是一连串自持事件，它可能开始于对相对次要的事件的媒体报道，然后会引起公众恐慌和大规模的政府行动。有些情况下，关于某一风险的媒体报道能抓住部分公众的注意力，这部分注意力进而会变成激愤和焦虑。这种情感反应本身就是一种宣扬，会推动媒体跟进报道，继而会令人产生更大的焦虑，波及面也更大 我们的大脑解决小风险的能力有一个基本限度：我们要么完全忽视风险，要么过于重视风险，没有中间地带 不出所料，人们对更详细、更丰富的描述作出的概率判断更高，这一点有违逻辑。预言家总会给其客户设下陷阱：对情节加以详述会使其更可信，却更不可能成为现实。 为了体会“貌似合理”的作用，请看下面的问题： 下面两个论述哪个可能性更大？ 马克长有头发。马克长有金色的头发。 以及 下面两个论述哪个可能性更大？ 简是位老师。简是位老师，她走路去上班。 这两个问题与琳达问题一样，有相同的逻辑结构，但它们却没有引起谬误，因为更详细的结果只是更详细而已，不会更让人信服，或更有连贯性，或更讲得通。对貌似合理和连贯性的评估不会产生概率问题的答案。在与之相矛盾的直觉缺位时，逻辑就会起作用。 系统 2 的惰性是生活中存在的一个重要事实，而对典型性会阻碍明显的逻辑原则运用的相关观察也至关重要。 很多情况下，直接的比较使得人们更谨慎也更有逻辑性。不过，也不常是这样。有时即使正确的答案就在眼前，直觉也会打败逻辑。 统计学基础比率”（statistical base rates）是指某一事件所属类别的事实总量，与单独事件无关；而“因果关系基础比率”（causal base rates）则会改变你对单独事件的看法。对两种基础比率，人们往往会区别对待：一是我们容易赋予个人以典型特征，二是情境的一个重要特点就是能影响个人的思考结果。 不愿从普遍现象中推导出特殊性，这一点与他们愿意从特殊现象中归纳出普遍性如出一辙。 我们对于数据的想法以及我们对于个体案例的想法存在很大的差距。相较于非因果关系的信息来说，用因果关系进行解释的统计学结果对我们的想法影响更大。但即使是具有说服力的因果关系统计数据也不会改变我们在个人经历中形成的长期坚守或是根深蒂固的信念。此外，令人惊讶的个体案例影响甚大，是教授心理学更为有效的手段，因为个案与统计数据的分歧需要调解，并被嵌入一种因果关系里，正因如此，本书才包含种种直接向各位读者提问的问题。与从别人那儿听到令人惊奇的事实相比，你更有可能因为从自己的行为中发现惊人的事实而学到知识。 对于一个理性的人来说，无偏见且适度的预测不应该引发问题。毕竟一个理性的风险投资家知道，即便是最有前景的新建公司，其成功概率也只是中等水平而已。她将自己的工作视为从所有赌注中找到的前景最好的赌注，而且关于要投资的那家新建公司的发展前景问题，她觉得没有必要欺骗自己。同样，预测某家公司收益的理性个体不会受到某个数字的束缚—他们应该考虑到最有可能出现的那个结果的不确定性。如果成功的回报足够大，一个理性的人就会考虑向一家极有可能倒闭的企业投资一大笔钱，而不会自欺欺人地抬高其成功概率。然而，我们并不都是理性的，我们中的一些人也许还需要歪曲判断作为保护来掩盖自己的无能为力。如果选择接受极端的预测来蒙蔽自己，你就会清楚地意识到自己对自己的纵容。 叙事谬误”的概念，用来描述存有缺憾的往事是如何影响我们的世界观和我们对未来的预期的。我们不断试图去了解这个世界，在这个过程中难免就会产生“叙事谬误”。能够吸引人们眼球的那些说法往往很通俗易懂，那些说法具体而不抽象，它们认为天资、愚蠢和意图的作用都要超过运气的作用，它们关注的是少数几件已经发生的重大事件，而不是无数件并没有发生的事 很多实实在在发生过的重要事件中包含着众多抉择，这些抉择会诱导你夸大技能的作用并低估运气对最终结局的影响 结果越糟糕，后见之明的偏见就越严重 证据的数量和质量并不那么重要，因为即使证据十分苍白也能构建一个非常连贯的故事。对于一些最重要的信念，我们其实根本就没有什么证据来证明其合理性，我们怀有这些信念仅仅是因为我们所爱的人和所信任的人也持有同样的信念。由于所知甚少，我们对自己信念的信心是毫无缘由的—但这种信念也很重要。 对某个判断的主观自信并不是对这个判断正确概率的合理评估。自信是一种感觉，它能反映出某条信息和处理该信息时所体现的认知放松的一致性。由衷地承认不确定性乃明智之举，但如果有人声称自信满满，只能说明他在脑海里已经构建了一个连贯的情节，当然这个情节未必是真实的。 我们理解过去所产生的错觉会使我们对自己预测未来的能力过于自信。 联想机制会抑制怀疑并引发与当前情况相符合的想法与信息。遵从眼见即为事实原则的大脑可通过忽略自己所不知道的事而变得过于自信。因此，许多人容易对没有事实根据的直觉怀有高度的自信也就不足为奇了。我和克莱因最终就一个重要的原则达成了共识：人们对直觉的自信心不能作为他们判断的有效性的可靠指标。换句话说，当有人告诉你你应该相信他们的判断时，不要相信他们，也不要相信自己。 请记住这条规则：在环境缺乏牢靠的规律时，不要相信直觉 当“苍白无力的”统计学信息与某个人对案例的印象相冲突时，这些信息总会被舍弃。在与内部意见的竞争中，外部意见丝毫没有取胜的机会。 偏向内部意见常带有道德的意味。 最初预算的误差并不总是无知的。制订计划的人都希望自己的计划能得到上级和顾客的认可。通常也正是这种愿望的驱使，他们才制订出了不切实际的计划。他们这样做还因为仅仅由于超支或超时不太可能会导致项目被中途叫停 在预测时使用相似团队的分布信息被称为采纳“外部意见，它是避免规划谬误的有效方法。 乐观偏差是人们愿意承担风险的重要原因。在经济学标准的理性模式下，人们愿意冒险是因为胜算大—他们之所以现在能承受有代价的失败，是因为他们相信最终成功的概率很大。这是替代的一个观点。 人们之所以经常（但不是总是）承担风险项目是因为他们对成功率过于乐观。我将在本书中反复提到这一点，因为它可能有助于解释为什么人们会对簿公堂、发起战争或者急于创业。 即使大多数风险承担者最终总是收获失望，但那些因乐观而承担的风险企业家毫无疑问都会为激发资本主义社会的经济活力作出贡献 对环境的不确定性了解不足必然会导致经济行为人承担本可以避免的风险。然而，无论在社会生活中还是在股票市场中，乐观主义极其重要。个人及企业会奖励那些提供了冒险且有误导性信息的人，而不是说真话的人。我们从造成大萧条的金融危机中学到的是：总有一段时间，专家间和企业间的竞争会造成大家对风险和不确定性视而不见。 通常，临床医生显现出的不确定是一种懦弱的表现。自信的人比对事情持不确定态度的人更受人推崇。医生将自己的不确定透露给病人会遭到大家的指责。”完全认识到自己无知的专家可能会被更自信、更能获得病人信任的竞争者取代。对不确定性的无偏见评价是理性的基石，但这并不是个人或机构想要的。在危机中，极度的不确定会造成严重后果，而且在风险高的时候承认自己只是在猜测的做法特别不易被接受。所以，假装知道通常是首选的解决方式。 主观自信是由人们构建的连贯的故事决定的，而不是由支持它的信息的质量和数量决定的。 事实上，一个规避风险的决策制定者会选择一件低于预期值的确定事情，实际上就是拿出一笔额外费用以避免不确定的事情发生。 人们的各种选择并非基于金钱价值，而是基于各种结果的心理价值，即它们的效用。如此说来，一个风险的心理价值就不是对可能会得到的金钱收益量的平均加权，而是这些收益效用的平均值。 ·在得失都可能出现的赌局中，损失厌恶会产生极力规避风险的选择 在肯定会有损失和有可能会损失更多的选择中，降低敏感度会引发冒险之举。 问题 6：选择有 90% 的机会赢得 100 万美元，还是选择肯定会得到 50 美元？ 问题 7：选择有 90% 的机会赢得 100 万美元，或者选择肯定会得到 15 万美元？ 请比较一下两种情况下选择赌一把却赢不了的痛苦孰大孰小。在两种情况下，不能赢都会带来失望，但在问题 7 中，潜在的痛苦是多重的，因为知道如果选择赌一把又输了的话，你会后悔自己“贪婪的”决定，后悔放弃了拿到 15 万美元的机会，后悔这种体验依赖于你本应该采取却没有采取的意见。 禀赋效应是指当个人一旦拥有某个物品，那么他对该物品价值的评价要比未拥有之前大大提高 第一，人们的偏好并不是一成不变的，它们会随着参照点发生变化。第二，改变的不利之处比有利之处更突出，其有利之处包括对倾向于现状的偏见。当然，损失厌恶并不是说你从未想改变自己的处境；一次机会带来的益处也许会超过甚至大大超过损失。损失厌恶只能表明我们的选择总是强烈偏向趋近参照情形的选项（而且通常情况下会偏向较小而不是较大的改变）。 传统的无差异曲线和伯努利用财富状态来表示结果的做法有一个共同的错误假设，即拟定各项事务状态的效用只依赖于该状态本身，并不受你过往的影响。对这一错误的修正已经成为行为经济学的成就之一。 市场的魔力对于那些想使用某件商品的所有者（卖家）而言根本就不起作用。 一只蟑螂可使一碗樱桃不再诱人，而一个樱桃对一碗蟑螂却不会起任何作用 我们发现公平性的一条基本原则是：不可利用市场的力量将损失强加给他人 。违背了公平原则的雇主会受到生产力下降的惩罚，标价不合理的商人也会失去一部分销售市场。以较低价格卖出近期以较高价格购进的商品会使这位商人此后从每家商品供应商进货的量减少 15%，即每位顾客都会分摊到 90 美元的损失。顾客显然将低价位看成了参照点，而且由于多付了钱，他们会认为自己也遭受了损失。尽管反应最强烈的顾客是那些以较高价钱买了更多商品的人，而且新价目表中较低的价格增加了产品销量，但按底价购物的那些顾客的损失其实远远超过他们所得的。 可能性效应，即我们往往看重轻风险，更愿意花比预期价值更多的钱将其排除掉。在可能性效应中，有 95% 的可能性会遭受灾难和必然会遭受灾难两者间的心理差别甚至更大；虽然“一切都会没事的”这样的希望很渺茫，但人们却总是将这种希望无限放大。过于看重很小的概率，使得风险和保险政策更具诱惑力。 可能性效应会重视不大可能的结果，而几乎肯定的结果相对于确定的结果来说，受到的重视程度要小。预期原理通过可能性来判定价值，这是一种不可取的心理。 当不大可能出现的事情成为关注的焦点时，我们对它的重视程度就要超过其本身出现的概率应该引起的关注度 在审视自己的选择是否错误的时候，我们在处于损失的情况下会选择冒险；处于赢利的情况下会选择规避。 也就是说人们在面临的抉择比较糟糕时会孤注一掷，尽管希望渺茫，他们也宁愿选择使事情更糟的较大可能性以换取避免损失的希望，这种做法常会使可控制的失误变成灾难。 失败总是难以让人接受，所以失败的一方常会保持战斗力，即使在知道对方的胜利只是时间问题的情况下，输的这一方还是会作无谓的挣扎。 你对概率的判断最终总是由认知放松或顺畅性决定的，因此你的脑海中总会出现貌似正确的情形。 你并不总是关注要求你作出评估的事件。如果目标事件发生的可能性很大，你就会关注这个事件的其他可能性。请思考下面这个例子： 在你们当地医院里出生的新生儿在 3 天内就出院的概率有多大？ 你现在要估测婴儿出院回家的概率，但你肯定会关注造成婴儿不能在正常期间出院的事件。我们的大脑有个有用的机能，它会不由自主地去关注奇怪、不同或是不寻常的事。你很快就会意识到，在美国（不是所有国家都设有同样的标准），婴儿于分娩后的两三天出院是很正常的。所以，你将注意力转移到反常的情况上去了。罕见事件成了焦点，这些事件很可能唤起可得性启发模式：你的判断可能由你所制造的许多医疗问题的发生场景以及想起这些问题时的感受决定。因为你处于确定性模式下，你对医疗问题出现频率的估计会非常高。 当某个人努力预测某个方案的结果时，就可以切实且轻松地成功执行某项方案。相反，失败的可能性则会被忽略，因为事情出问题的情况错综复杂。对自己职业前景进行评估的那些企业家与投资者很容易高估自己的机会，也喜欢过高权衡自己的估值。 当你脑海中闪现关于某个事件生动的画面时，这个事件不发生的可能性所带来的影响同样也很生动，因此就会被过度权衡。增强的可能性效应与增强的确定性效应相结合以后，决策权重很难在 21% 的概率和 84% 的概率之间发生改变。 根据前景理论可知，通过描述性文字作选择会产生可能性效应—低概率结果的可能性被过高权衡。与之形成鲜明对比的是，凭经验作选择不会出现过高权衡的情况，而较低权衡的情况却较为普遍 许多实验的结果表明，当我们做类似于选择餐厅或是固定好水壶以应对地震这样的决策时，罕见事件不会被过高权衡。 当前景得到明确描述时（例如“有 99% 的概率赢得 1 000 美元，1% 的概率什么也得不到”），注意力就一定会分散。过多关注（耶路撒冷的大巴）、生动的画面（玫瑰花）、具体的表述（1 000 中的 1 个），以及明确的提醒（以描述为基础作出选择）都是引起过高权衡的原因。没有过高权衡，就会存在忽视。就罕见事件而言，我们的大脑并不能总是作出正确判断。 决策（1）： 从 A、B 中作出选择： A. 肯定能赚到 240 美元 B. 有 25% 的概率得到 1 000 美元，75% 的概率什么也得不到 决策 （2）：从 C、D 中作出选择： C. 肯定会损失 750 美元 D. 有 75% 的概率损失 1 000 美元，25% 的概率没有损失 处于收益状态时规避损失、处于亏损状态时承担风险是需要付出代价的。这些态度会使你不愿冒险，而愿付出额外的费用去得到肯定可获得的赢利，还会使你愿意付出额外费用（包含在预期价值中）以避免肯定的损失 钱是衡量一个人自身利益与自我成就感的标尺。 沉没成本悖论导致人们在不被看好的事情上浪费了太多时间，例如不幸福的婚姻、没有希望的研究项目等 人们对由于不采取行动而导致的结果，会比因行动而产生的结果有更为强烈的情绪反应（包括后悔）。比如我们在那家餐馆里发现了一道极其美味的菜，因为害怕会后悔，所以我们就不愿意再尝试别的菜了。 若某赌注有 10% 的概率赢得 95 美元，有 90% 的概率损失 5 美元，你会接受这个赌注吗？ 若某彩票有 10% 的概率赢得 100 美元，有 90% 的概率什么也得不到，你愿意花 5 美元买这张彩票吗？ 你的道德感觉与框架相联系，与对实际情况的描述相联系，而不是实际情况本身 评级可通过将最糟糕时期和最后时刻的疼痛程度的平均加权而评估出来。 ·过程忽视（duration neglect）：过程的持续对所有疼痛的评估没有任何影响 经验自我是回答“现在疼吗”这种问题的，而记忆自我则是回答“总体如何”这种问题的。我们只有通过记忆才能保存生活体验，因此，在我们思考生命时，唯一能采取的观点来自于记忆自我。 我们希望痛苦的时间缩短，而愉快的时间能够延长。然而，我们的记忆（系统 1 的作用）已变成痛苦和快乐的最强烈感受（高峰时）以及感受结束时的自身感觉。忽视过程的记忆不会为我们的偏向带来长期的愉快和短暂的痛苦。 峰终定律，指我们对一件事物的记忆仅限于高峰和结尾，事件过程对记忆几乎没有影响。高峰之后，终点出现得越迅速，这件事留给我们的印象越深刻。作者因这个认知获得诺贝尔奖。——编者注 有时候，人们对待自己就如对待其他失忆的人一样，他们通过回到曾令自己愉快的地方以增强自己的愉悦感。然而，许多人说他们完全不想去那些地方，这表明他们只关注自己的记忆自我，而且相对于失去记忆的陌生人来说，他们更少关注失去记忆的经验自我。许多人指出他们不会让自己或是失忆的人去爬山或是穿越丛林，因为这些体验在当时大都是痛苦的，只能靠提醒自己达成目标的痛苦与快乐都是值得的才能坚持下去。 人们为自己设定的目标对于他们要做什么，以及对只关注经验自我的幸福感是难以维持的这一事实的感受都极为重要。幸福不是忽略人们想要得到的。此外，说幸福是忽略自己活着的真实感受而只关注自己对生活的想法也是不成立的。我们必须接受幸福是各个方面的综合体的观点，必须把记忆自我和经验自我的感受都考虑在内。 聚焦错觉能使人们对自己当前的幸福状态、他人的幸福感以及自己未来的幸福感判断错误。 想要适应一个新的环境，无论这个环境是好还是坏，在很大程度上取决于慢慢地不去想这个环境。从这个意义上来看，生活的长期状况（包括半身瘫痪和婚姻）只在部分时间会对人们的状态产生影响，即当人们关注于这些状况的时候。 聚焦错觉会产生一种偏见，这种偏见会导致人们更加看好本身就能令人兴奋的事物或经历，即使这些事物或经历最终也会失去吸引力。人们忽视了时间，致使维持人们长久的注意力价值的经验很少受到关注，至少比这种经验应得到的关注要少。 比起细水长流的幸福来说，人们更偏好享受短暂却强烈的快乐。这种偏见是由结合了峰终定律的过程忽视造成的。与这种偏见相反，另一种偏见使我们更为害怕短期、强烈的疼痛，而对于长时间但较轻微的疼痛却更容易接受。过程忽视还使我们容易接受长期但轻微的不愉快，因为其结局会更好；若某件事的结局不好，即使其过程是长期且快乐的，我们也会忽略掉。以同样的观点来看待不适，请考虑这个普遍的警告，“不要这样做，否则你会后悔的”，这个建议听起来很明智，因为其所能预见的后悔出自于记忆自我的判断，我们也倾向于将这个判断看做是最终结论。然而，我们不应该忘记，记忆自我的观点不总是正确的。一个测量快乐的客观观察者会更注重经验自我，会提供不同的建议。记忆自我对过程的忽略、对峰终和结局的重要性的夸大，以及对后见之明的怀疑共同作用，歪曲地反映着我们真实的体验。 我们在推理时，头脑不会总是很清醒，我们犯错也不全是因为突然想到的不恰当的直觉。通常，我们犯错是因为我们（系统 2）无法再了解到更多的信息。 技能的习得要求有固定的环境、练习的机会，以及对自己想法和做法快速且明确的反馈。当这些条件都满足时，就能掌握技能了，且此后快速闪现在大脑中的直觉性判断和选择都会是正确的。这些都是系统 1 来完成的，也就是说这些是快速且自主发生的。有技能的行为是能快速有效地处理大量信息的能力。 系统 1 的运行特征，包括眼见即为事实、强度匹配和联想一致性等，会产生可预测的偏见和认知错觉，比如锚定效应、回归平均值的预测、过度自信，以及许多其他错觉。 人们期望过程的基本特征不仅表现在整个序列中，还表现在局部的序列中。然而，局部代表的序列系统地脱离了概率的期望：因为局部代表的序列中选择很多，但可供选择的项却很少。抱有局部代表性这个想法的另一个后果就是有名的赌徒谬误。例如，在看到轮盘赌的指针长时间连续指向红色以后，大多数人就会错误地认为现在该是指向黑色的时候了。这是因为，相比再次出现红色，出现黑色会使序列更具代表性。人们普遍将概率视为可进行自我纠正的过程。在这个过程中，某个方向的偏离能引起其相反方向的偏离，以达到恢复平衡的目的。事实上，在概率的结果揭晓时偏离并不是被“纠正”了，而只是融为一体了。 某个具有统计意义的样本结果可以代表样本所属的整个群体的性质，这与样本大小并无关联 由于预测特点与输入信息非常吻合而产生的没有保证的自信就被称为效度错觉。即使当判断者意识到限制其预测准确性的因素时，这种错觉仍然存在。 因搜索集合的有效性导致的偏见。假设从某个英文文本中随机抽取一个词（含有 3 个或更多字母的词）。这个词更有可能是以 r 开头还是以 r 作为第三个字母？人们在回答这个问题时，会回忆首字母为 r 的单词（例如 road）以及第三个字母为 r 的单词（例如 car），然后通过想到这两个词的容易程度来评估相对频率。因为从记忆中搜寻单词的首字母要比搜寻其第三个字母更为容易，所以大多数人都判断以某个辅音开头的单词要比第三个字母为该辅音的单词多。但实际上，例如 r 或 k 的辅音字母，出现在第三个字母的频率都要比出现在开头的频率高。 在许多情况下，人们都会通过初始值来确定最后的答案。初始值或起始点，可能是从问题形成之时得到的提示，也可能是在稍微计算之后得到的结果。但无论是前者还是后者，其调整都不会太过充分。不同的起始点会产生不同的估测，都会偏向于初始值。我们将这个现象称为锚定。 人们易于高估连续事件的概率，低估非连续事件的概率。这样的偏见是由锚定效应引起的。 我们有时可以从事件的结构中推测出锚定偏见的方向。连续事件的链式结构会导致高估，非连续事件的漏斗式结构会导致低估。 在现实中，主观概率会决定我们对赌注的偏好，但我们并不是从这些偏好中推断出主观概率的，就如同理性决策中不证自明的理论一样 我们有时可能从对赌注之间的偏好中推断出主观概率，但通常主观概率并不是由此而形成的。 判断必须与人们持有的所有信念相容。 理性判断者会努力争取这种相容，即使利用内在一致性能更容易完成判断和评估。特别是，理性判断者会尝试使自己对概率的判断与自己相关的知识、概率的规则以及个人的判断启发式和偏见相容。 是否采取某个选择取决于这个选择可能的负面结果是被评估为一种成本还是无法补偿的损失。 边界效应：即从不可能到可能，或从可能到确定的变化比变化范围内的变化有更大的影响力 这种疫苗被描述成可治愈一半的病人时，与其被描述成对相同症状的病毒的一半完全有效得到的吸引力相比，其对公众的吸引力更小。 相对于完全消除危险而言，人们过低估计了降低发生危险的可能性。因此，当将保险被描述成可以消除危险而不只是降低危险时，保险会更具吸引力 对语言理解力的研究指出，人们会将听到的东西迅速地转化为抽象的表述，这种表述不能再区分该想法是用主动还是被动的形式来表达的，且不能再辨别实际所说的和暗指的、假定的或包含的意思。不幸的是，自主地进行这些运作的大脑机制不能完成将公共健康问题或死亡率、存活率的统计问题转化成普通的抽象任务。 许多决策问题都以在维持现状和选择一个替代选项的形式出现。这些替代选项在某些方面是有利的，而在其他方面又是不利的。早期用于线性风险前景的价值分析可运用到这种决策中来，其方法是通过假设现状可定义问题所有因素的参考水平。替代选项的有利点会被评估成收益，而其不利点会被评估为损失。因为损失比收益的影响更大，决策制定者会偏向于维持当前现状。 通过将损失的结果构架成消费而不是损失时，人们的主观状态会被提升 问题 10：你会接受一个有 10% 的概率获得 95 美元、90% 的概率损失 5 美元的赌吗？ 问题 11：有种抽奖有 10% 的概率赢得 100 美元、90% 的机会什么也得不到，你愿意花 5 美元参加这种抽奖吗？ 体验价值：高兴或悲伤的程度、对结果真实体验的满足感或痛苦；决策价值：预期结果对某个选项中总的吸 ​ ​]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书书摘 行为 决策 前景理论 损失厌恶 风险规避</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加西亚·马尔克斯（待续）]]></title>
    <url>%2F2017%2F12%2F31%2F%E5%8A%A0%E8%A5%BF%E4%BA%9A%C2%B7%E9%A9%AC%E5%B0%94%E5%85%8B%E6%96%AF%2F</url>
    <content type="text"><![CDATA[霍乱时期的爱情 他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 ​ 无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了 “你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定 当她在成为寡妇后的第一个早晨醒来，闭着眼睛在床上翻了个身，想找一个更舒服的姿势继续睡下去，就在这一刻，她才真正意识到他死了。也只有在这时，她才察觉到，这是他多年来第一次没有在家过夜。另一个触动她的情境是在餐桌前，但不是因为感到孤单，尽管事实的确如此，而是因为她奇怪地相信，自己正在同某个已不存在的人一起用餐 ​ 她无法摆脱隐藏在心底的怨恨，怨丈夫将她孤零零地遗弃在这汪洋大海之中 ​ 在这么多年一次次精心算计的爱情之后，天真无邪的生涩味道别有一番新鲜的堕落的快乐 “我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。” 曾经，每天的每分每秒都胜似他的盟友，如今却开始算计他 但最终，他还是让步了，弗洛伦蒂诺·阿里萨把镜子挂到了自己家中，却并不是因为那镜框的精雕细琢，而是因为镜子里的那片天地，他爱恋的形象曾在那里占据了两个小时之久 ​ 他们终于彻底了解了对方，在结婚将近三十年时，他们变得好似一个人被分成了两半，常常因为对方猜出自己没有说出口的心事，或者一个抢先把另一个想说的话公之于众的荒唐事件而感到不悦。 ​ 她丈夫爱她胜过一切，胜过世间所有的人，但这也仅仅是为了他自己：这是他的神圣义务。 ，唯一可能的解释——就像她常说的那样——便是她怨恨丈夫明知故犯地为一群黑人牺牲了性命，而唯一正确的牺牲应该是为了她活下去 ​ 但当她们独自去望弥撒时，才逐渐意识到，自己又一次成为自己意愿的主人，当初，为了换取一种安全感，她们不仅放弃了自己家庭的姓氏，甚至放弃了自我，可那种安全感不过是她们做姑娘时许多幻想中的一个罢了。只有她们自己知道，她们曾经疯狂爱着的那个男人——尽管他或许也爱着她们——给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 ​ 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 ​ 说不清究竟是欧洲之行改变了他们，还是爱情改变了他们，因为这两者是同时发生的。它们都起了作用，更深一层说，改变的不仅是他们两人，也是所有人，就像弗洛伦蒂诺·阿里萨在那个不幸的星期日，他们回来两周后，看见他们望完弥撒从教堂中走出来时所察觉到的那样。 ​ 尽管并非有意，但这样处理匿名信的方式是正确的，其实那些不敢留名的人所属的阶层，在历史的嘲弄下，早已习惯了对既成的事实低头 ​ 可洛伦索·达萨以桶匠的大度吞下所受的侮辱，继续执著地依靠智慧创造偶遇胡维纳尔·乌尔比诺的机会，却没有发现其实是胡维纳尔·乌尔比诺付出了更为超常的努力，尽一切可能让两人相遇 “这座城市还真是伟大，”他常常说，“我们用了四百年的时间来摧毁它，至今仍没有达成目的。 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们靠私下里抽签来决定谁做他的女伴，而他也乐得与她们相处，但总是若即若离，始终保持着清雅，直到最后，他不可救药地被费尔明娜·达萨那种质朴的魅力迷住了 ​ 但与那时不同，此刻她没有感到爱情的震撼，而是坠入了失望的深渊。 ​ 四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生 不可避免，苦杏仁的气味总是让他想起爱情受阻后的命运 一桩事先张扬的谋杀案 夜里，他梦见自己冒着蒙蒙细雨，穿过一片榕树林，这短暂的梦境使他沉浸在幸福之中，但醒来时，仿佛觉得全身盖满了鸟粪。 她没有拖延时间，几乎马上说出了那个名字。她在黑暗中寻找着，第一眼就从这个世界和另一个世界那么多混杂的名字中找那个名字，并且用她那百发百中的标枪将它像一只没有意志的蝴蝶那样钉牢在墙壁上，对它的判决就这样一直留在那墙上。”圣地亚哥·纳塞尔，”她说。 虽说如此，实际情况好像是维卡兄弟根本不想在无人在场的情况下立刻杀死圣地亚哥·纳赛尔，而是千方百计想叫人出面阻止他们，只不过没有如愿以偿罢悲剧的其他主要人物都尊严地、乃至颇为杰出地完成了生活赋予他们的使命。 埃伦蒂拉与她残忍的祖母 1. 埃伦蒂拉并没有听见他的哭声，她还在逆风跑着，跑得比鹿还快，这个世界上任何声音也不能使她停下来。她头也不回地向前奔去，跑过热气腾腾的硝石水潭，跑过那几座云母火山口，跑过别具一格的原始水上住宅区，直到这海洋自然景色结束，又进入了荒凉地区。她带着那件金条背心，迎着干辣辣的风沙，在那永不消失的黄昏中继续奔跑着。……从此再也没有听到过一点她的消息，也没有发现她最后遇难的一丝痕迹。 将军和他的情妇——迷宫中的将军 我一生中的遭遇似乎是鬼使神差 只有曼努埃拉知道他的大大咧咧不是因为他的无知和轻率，也不是因为他是个宿命论者，而是因为他忧伤地坚信，他将来必定会穷愁潦倒赤身裸体地在自己的床上死去，而且得不到民众的谅解。 我得到平静的第一天，即我掌权的最后一天。 逃兵，则是不问青红皂白一概枪毙。生活已使他充分认识到，任何失败都不是最后一次 于这一花天酒地的过去，唯一给他留下来的只是一些刻着他的缩写名字的个人餐具。 有一位退伍军人用一句话概括了所有人的感情：“将军，我们现在拥有了独立，可请您告诉我们该拿它怎么办。 只要下级为了讨好我而继续撒谎，事情将永远如此。 随着往下游行去，河，越变越宽，气势越来越磅礴，就象一片没有边际的沼泽，天气如此炎热，甚至能用手触摸到它的淫威 夜里，他躺在吊床上无法入睡，缓慢的桨声玩着与热带雨林里卷尾猴、小鹦鹉、大蟒蛇的声音比美的游戏。突然，谁也没有想到，有个人说道，坎皮略一家由于害怕被传染上结核病，把那套英国餐具、捷克波希米亚的玻璃器皿和荷兰台布全都埋在院子里了。 虽然在大河一带这已是人所皆知的消息，而且很快将传遍整个海滨地区。但是，这是将军第一次听到对他病症的马路诊断。何塞·帕拉西奥斯感到将军受到了震惊，因为他的吊床不再摆动。经过长长的沉默思虑后，他说：“我用的是自己的餐具。” 24 年之后，当他深为大河的魅力所吸引，自己的生命已近垂危，且为对手所败时，也许他问过自己是否有勇气把牛至和鼠尾草的叶子，还有何塞·帕拉西奥斯为他准备洗浴消遣用的苦橙子扔进粪坑里去，是否有勇气遵从卡雷尼奥的忠告，与他的叫化子军队，他那废物一堆的荣誉，他那些值得铭记的错误，还有整个祖国和他自己，一起沉入用紫硬毛香菊泡成的救苦救难的大海海底。 在人类悠久的历史上，许多次都表明：才干是需要的合法女儿。 爱上一个女人就等于一个人同时有两个灵魂 当她回到秘鲁刻意追求她生活中的爱情时，不需要向任何人请教便在那种乱糟糟的环境中扎下根来。 除了伊图尔维德和欧洲副官们之外，他们都是委内瑞拉人，而且几乎都与将军有血缘关系或者有姻亲关系。费尔南多、伊瓦拉兄弟们、布里塞尼奥·门德斯都是如此。阶级关系和血缘关系使他们利言一致，将他们紧紧联在一起。 他们每个人的个人功绩都是无可争议的。糟糕的是，将军自己从来意识不到他在他们面前所建造的权力堡垒。这个堡垒越是坚不可摧，他越认为自己是一个易于接近和宽厚仁慈的人。但是，在何塞·帕拉西奥斯把军官们真实的精神状态告诉他的那天晚上，将军便完全以平等的态度跟他们玩牌，输了也高高兴兴，军官们都感到心情舒畅。 显然，军官们感受到的沮丧并不是往昔的失望。他们不在乎失败的情绪对他们的影响，哪怕这种情绪出现在刚刚打过胜仗之后；他们不在乎强加于他们的缓慢晋升的规定，这样做是为了避免有人觉得晋级是种特权；他们已不在乎背乡离井的流浪生活；他们也不在乎有没有逢场作戏的一时艳遇；由于国家财政的拮据，军人的薪水已经降低到原来的三分之一。即使这样，还要拖迟三个月支付，而且付的是不能保证兑换的国家公债，他们经常都是以低价卖给投机商人。然而他们对这一切毫不在乎，就象他们不把将军出门时那响彻整个世界的摔门声放在心上一样；他们甚至不在乎将军把他们丢下任敌人宰割。总之，他们什么都不在乎，反正光荣是属于别人的。他们所不能忍受的是，自从将军决定放弃政权之后，他给他们播下的那种茫然失措的情绪，而且，随着这种情况的继续和没有任何目标、任何方向的旅行被搁置，他们更加无法忍受了。 在他一生中遇见过的那么多女人里，其中很多与他只有过短暂的欢愉，但从没有向任何一个女人暗示过让她留下来的想法。一旦他的欲望如愿以偿，他就满足于在记忆中继续回味她们；或从遥远的地方通过火热的书信表示对她们的迷恋；或给她们赠以厚礼以给自己的健忘辩解，但决不使自己的生活哪怕有一丁点儿陷入这种与其说是爱情不如说是虚荣的感情里去。 天亮时，“波帕足”的那所房子已是座被遗弃的兵营，但是将军留下了，愿一场新的战争来重振他昔日光荣的希望在支撑着他。 我这样做的唯一目的就是要使这片大陆成为一个独立的、统一的国家，在这一点上我从没有过自相矛盾的地方，也从没有过一丝的怀疑。 我聚老、病、累于一身，我万念俱灰，四处受敌，我遭人毁谤，还被恩将仇报。 将军说，“最可悲的是，当他们认为在改变世界时，实际上是在使西班牙的落后思想永世长存。 请相信我说的，大夫，”他对医生说道，“我们的威严，我们的生命只有用我们敌手的鲜血才能保存。” 将军对发生的一切似乎已经麻木不仁，直到看见牧师长袍上的血迹时才意识到世界的存在 不是敌人的背信弃义，而是朋友们的折腾葬送了我的荣誉。是他们使我上了奥卡尼亚议会的贼船，是他们使我陷入了君主政体的麻烦，是他们最初迫使我去争取重新当选总统，而后又以同样的理由让我放弃这一职位，而现在他们把我囚禁在这个国家里，我现在已没有任何东西可以丢失了。 雨没完没了地下着，潮湿甚至使人们的记忆都产生了裂缝 驻军司令兼市长胡安·格伦少校冒着大雨风风火火地来了，因为他听说比斯瓦尔先生的一个女仆由于把将军在索莱达剪下的头发作为圣物出售而被捕。将军再次感到无限伤悲，因为他万万没有想到自己的一切都变成了廉价的处理商品。 直到许多年之后，堂·华金·德米耶尔肯定会记得在那闷热的第一个夜晚人们用担架从船上抬下来的那个可怕的小人儿。他颓然地倒在座位上，脑袋无力地倚靠着马车的后背，但他那贪婪的目光却在追寻着窗外勃勃生机的万物，那样的景色是最后一次闪过他的眼前，此后将一去永不复返。 也许他的军官们从来没有想到那种权力和利益的分配是何等紧密地将他们的命运联系在一起，因为，不管是走运还是倒霉，他们的余生都要在一起同甘共苦，包括历史对他们的嘲弄，五年后他们又重聚委内瑞拉，在佩德罗·卡鲁霍司令的指挥下，为了实现玻利瓦尔统一美洲大陆的理想而并肩战斗，并发动了一场军事冒险行动 距加拉加斯 132 公里的圣马特奥糖厂是他多年乡愁的中心。在那儿，他三岁丧父，九岁丧母，二十岁失去爱妻。他曾在西班牙跟一个秀丽的美洲姑娘结为伉俪。这姑娘是他的亲戚，他跟她结合的唯一幻想便是在圣马特奥糖厂当好厂长，管好资产，增加他的巨额财富，夫妻安居乐业，美满地白头偕老。他一直没有弄清楚妻子仅仅在结婚后八个月即与世长辞是由于恶性热病还是由于家里的一件偶然事故。对于他来说，那是一次历史的新生，因为在这之前，他是出生于委内瑞拉的一个西班牙血统的土著贵族之家的花花公子，整天沉湎于世俗的灯红酒绿之中，对政治丝毫无兴趣。自从失去爱妻之后，他就变成了一位伟人，直至他去世为止。他没有谈起过他死去的妻子，从没有想起过她，也从没有打算续娶。在他的一生中，他几乎每天晚上都梦到圣马特奥故居，梦到他的父亲和母亲，梦到兄弟姐妹们，但一次也没有梦到过妻子，他一直把她忘记了，仿佛是跟她一刀两断似的，似乎没有她也能够继续活下去。唯一能稍微拨动一下他记忆的是圣佩德罗·亚历杭德里诺糖厂制糖后飘出的糖浆味儿，糖厂里表情冷漠、甚至连一道怜悯的目光都不曾向他投来过的奴隶，以及为了迎接他而刚刚粉刷得雪白的房子及它周围的参天大树。这是另一座糖厂，在这里，一种难以逃脱的命运将把他拖向死亡的深渊。 借着回光返照的来临，他审视了一下房间，第一次看清了里面的一切：借来的最后一张大床；破旧得令人可怜的梳妆台；那面模糊不清的镜子，从今以后，他再也不会出现在里面了；掉了瓷的水罐依然盛着水，搁着毛巾和肥皂，那已是为别人准备的了；无情的八角钟象脱僵的野马不可抗拒地向 12 月 17 日飞奔，很快将指到将军生命的最后一个下午的一点零七分。那时将军将交叉的双臂放在胸部，开始听到榨糖厂的奴隶们以宏亮的声音唱着清晨六时的圣母颂。他透过窗户看到了天空中闪闪发光、将一去不复返的金星，雪山顶上的长年积雪，新生的攀援植物。但下一个星期六，在因服丧而紧闭大门的邸宅里他将看不到那些黄色的钟状小花的开花了。这是生命的最后闪光，在今后多少个世纪也不会在人世间重现。 族长的秋天 他在自己的荣光中如此孤独，孤 独得连一个敌人都没有剩下 她并没有迎合儿子的兴 奋，而是开始啃咬她画黄鹂的毛笔以遮掩酸楚破 碎的心，因为她忆起了唯有她才清楚的过往岁月，记起了他为保住那把交椅而付出的巨大代价，我 说的不是现在，主啊，不是现今这样轻松的光景， 现在的权力正像他说的一样，是摸得着又独一无 二的实在东西，就像手掌上的一颗玻璃珠，她说 的是他被联邦战争中最后一群贪婪的考迪罗追逐 迫害的时期，当时他好似一条逃命的鲱鱼，没有 神明庇护，在附近一座宫殿里游窜，天哪，再 一阵之后就结束了，当混乱过去，世界的阒寂中 只剩下一缕火药气息，只剩下他，在权力的焦虑中永远安然无恙， 因为 他自始至终都清楚，想要战胜一个无法战胜的人， 唯有将友谊作为武器 那时的权力还不是他晚秋 时期的无边泥塘，而是在我们眼前的从源头喷放 的激越洪流 为祖国而死是至上的荣耀，阁下，而他带着怜悯 的微笑回应他，别傻了，孩子，祖国就是活着 这种信任他必须给予那些最骁 勇的将士，哪怕有违他的意志，因为离开他们， 他无以为继，而拥有他们，情况也是一样，他注 定要永远呼吸那一团令他窒息的空气 他自己的听力每况愈下，直到一个 晚上，他鼓膜的嗡鸣破碎了，结束了，变成了泥 浆般的空气，其中只有来自权力暗影的虚幻航船的告别挽歌还会飘过，只有想象中的风还会吹拂，只有内心的鸟雀还会喧闹呜叫，并最终于现实中 鸟雀寂静的深渊里安慰着他 什么东西都只会让教士、 外国佬和有钱人分了，穷人什么都得不到，当然 了，他们一向这么浑蛋，要是哪天大便也值钱了， 穷人会生下来就没有屁股的 他在那个遥远的世界里看到了这样那样的很多东 西，尽管他自己都无法把握十足地判断，那一切 到底是他真实的记忆还是在战时发着烧的不幸夜 晚听来的，抑或源自他趁政局风平浪静时一连数 小时迷醉其中的游记插画，不过这些都不重要， 他妈的，等着瞧吧，将来它们全部会是真的 如果那时候他知道自己不用太多年也不用 太艰难就会将那个无法避免的礼拜三的最后一丝 记忆彻底抹去，那么他们留下的东西再多一点或 再少一点对他来说也便无关紧要了 他在心中搜寻着本 想存留至死的仇恨，却只找到了不值得再留存的 受了伤的自尊的残灰， 直到粗鲁的麦 昆大使回答他说现在咱们已经不是在商量了，阁 下，支撑这制度的不是希望、顺从，甚至不是恐 惧，而是无从挽回的古老幻灭中的纯粹惯性 在他最不想要 它降临时，它降临了，在如此多年的贫瘠幻想之 后，他开始隐隐明白，人不是在生活，真他妈见 鬼，而是在苟活，人开始学习时已经太晚，即便 是最博大最了不起的生命也仅能达到学习怎么去 活的程度，他从自己喑哑手掌的谜团里、从纸牌 隐形的密码中，意识到了自己没有能力去爱，于 是企图用权力的孤独罪恶的炽烈祭礼去补偿那无 耻的命运，却在无尽燔祭的火焰中沦为自己献祭 主张的牺牲品，他以诓骗与罪行养肥了自己，以 无情与羞辱培育了自己，他克服狂热的贪婪与天 生的怯懦只是为了将那颗玻璃球握在掌中直至时 间的尽头，却不曾知晓这种罪恶没有尽头，正是它的饱足滋生着它的胃口，循环往复直至所有时 间的尽头，将军阁下，他从一开始就知道，他们 骗他是为了博他欢心，奉承他是为了赚他钱财， 他们以武力逼迫民众聚集，要大家在他经过时欢 呼雀跃，并高举讨好他的、上书伟大领袖万寿无 疆的牌板，那位领袖比他更老迈，但他学会了与 这些相处，学会了与所有荣耀衍生的悲惨相处， 并在无法数算的岁岁年年中发现，谎言比质疑更 舒心、比爱更有用、比真理更持久，他已经并不 意外地到达了可耻的臆想境地，无权力却在统治、 无荣耀却受赞颂、无威信却被遵从，而此刻，在他秋天的那串飘落的黄叶中，他相信了，他从来 就不会是他全部权力的主宰，他注定只能颠倒着 认识生命，注定无法参透世事，无法在现实中的 幻想的哥白林毯上捋直阴谋的线、解开诡计的结， 同时丝毫不怀疑，哪怕死到临头也仍不怀疑，唯 一可见的生活，就是被展示出来的那一个，我们 从这边看到的并不是您的那个将军阁下，在穷苦 人的这边，有我们无尽的不幸岁月的黄叶飘零， 还有那些抓不住的幸福时刻，还有被死亡的幼芽 污染的爱，但它是真真切切的爱啊将军阁下，在 这边，您本人不过是个模糊的影子，是火车小窗 灰蒙蒙的薄帘之后的哀怨眼睛，是那沉默嘴唇的 颤抖，是那只戴缎面手套的无主之手一晃而过的挥别，那只手属于那个没有结局的老人，我们从 来不知道他是谁，不知道他什么样，甚至不知道 他是否只是一个想象中的谎言，一个可笑的独裁 者，我们从来不知道另一边在哪里、生命的权利 在哪里，而我们仍以贪婪的热忱爱着这您不敢去 爱的生命，您甚至不敢想象去爱它，因为您害怕知道我们已经清楚得不能再清楚的事实：生命是 艰辛又转瞬即逝的，然而再没有另一个生命了， 将军，因为我们知道自己是谁，而他却永远不能 知晓，他带着自己年迈死者那疝气的温柔哨声， 被死亡一棍击中、连根折断，他在他秋天的最后几片冰冷树叶的阴暗声响中，飞向了被遗忘的真 相的黑暗祖国，他惊恐地抓着死亡长袍上的破布 烂线，远离了疯狂人群的呼喊，他们冲上街头唱 着欢快的颂歌，庆祝他的死亡，他也将永久地远 离那自由的音乐、幸福的焰火和那荣耀的钟声， 它们正向世界宣告一则好消息，宣告那永恒的无 尽时光终于结束了。 恶时辰 当时，她有一种预感，仿佛有件什么事，很早以前已经进入尾声，如今终于结束了 他朝着敞开的阳台坐下来，随手拍打着蚊子。空寂的大街上已经亮起了路灯。他很熟悉黄昏时的这种宁静。几年前，也是在这样一个黄昏，他充分体验到什么叫权势。 安赫尔神父停住脚步，扭回头来，用那双庄重的天蓝色眼睛看着她。米娜也停下脚步，腋下夹着空盒子，话没说完，却神经质地笑了笑。 枯枝败叶 我觉得，在某种程度上，我们的决心不会使他们为一时失去快乐而感到悲哀，只会为这一时刻的姗姗来迟感到遗憾。 是砸过第二下，窗居然应声开了。阳光一下子冲进来，如同一只猛兽破窗而入，一声不响地东跑西窜，淌着口水，四处闻嗅，狂暴地挠着墙壁，最后，在这牢笼里找了个最阴凉的角落，悄悄地卧了下去。 没容他说完，我就抢着问：“要多少？”一听这句话，他又完全变成另外一个人了。 很明显，那天晚上梅梅特别怀念当年的生活，似乎这些年来她的年龄一直静止不动，时间也根本没有流逝，直到那天晚上回首往事，时间才又流动起来，她也才开始经历姗姗来迟的衰老。 梅梅笑了笑。这是凄凉的惨笑，看起来倒不是因为现在情绪不佳，而像是她把这种惨笑收藏在抽屉里，什么时候需要，什么时候就拿出来。她笑得很笨，似乎平时难得一笑，连怎么正常笑也忘得一干二净了 只有当某种东西活动的时候，人们才知道时间在前进 家里的事并不听从我的指挥，而是听从另一种神秘力量的安排。这种力量左右着我们生活的进程，而我们自己不过是无足轻重的被驯服的工具而已。似乎事情，都无非是在自然而然、一环扣一环地实现某种预言罢了。 不过，我认为即使这样一种微不足道的叛逆表现，也胜过那些受人压榨、自甘堕落的人们的行为。 他们自以为可以决定自己的行动。其实，一切早已安排妥当，命中注定那些事情一件接着一件发生，最后把我们引到了今天这个礼拜三。 我原本甚至认为根本无需上吊的绳索，只要一股微风就足以扑灭残存在他那双冷酷的黄眼睛里的一星生命的火花。 我们还没来得及弄清楚发生了什么事，一道强烈、明亮的阳光就从背后一下子冲了进来。由于两百年来抵挡阳光的支柱被抽走了，光线以两百头公牛的力气一下子冲进室内，把屋里各种物件的阴影一扫而光。仿佛半空中打了一个大闪，人的形象骤然变得十分清晰，他们各自晃了晃，仿佛想尽力站住脚跟，不让亮光推倒。 没有人给他写信的上校 这时，妻子瞧见他跟婚礼那天穿得一样，才发现丈夫已经苍老了许多。 “二十年过去了，每次大选完了，你都指望他们能兑现承诺给你寄钱来。到头来我们等到的一切，就是一个死掉的儿子。”]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>加西亚·马尔克斯 族长 将军 上校 霍乱 爱情 谋杀案 枯枝败叶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱你就像爱生命]]></title>
    <url>%2F2017%2F12%2F31%2F%E7%88%B1%E4%BD%A0%E5%B0%B1%E5%83%8F%E7%88%B1%E7%94%9F%E5%91%BD-%E7%8E%8B%E5%B0%8F%E6%B3%A2%2F</url>
    <content type="text"><![CDATA[你劝我的话我记住了。我将来一定把我的本心拿给你看。为什么是将来呢？啊，将来的我比现在好，这一点我已经有了把握。你不要逼我把我的坏处告诉你，请你原谅了这一点男子汉的虚荣心吧。我会在暗地里把坏处去掉，我要自我完善起来。为了你我要成为完人 当我跨过沉沦的一切 向着永恒开战的时候 你是我的军旗 越悲怆的时候我越想嬉皮。 我会不爱你吗？不爱你？不会。爱你就像爱生命。算了。不胡扯。 我真的不知怎么才能和你亲近起来，你好像是一个可望而不可及的目标，我捉摸不透，追也追不上，就坐下哭了起来。 请你不要吃我，我给你唱一支好听的歌 我把我整个的灵魂都给你，连同它的怪癖，耍小脾气，忽明忽暗，一千八百种坏毛病。它真讨厌，只有一点好，爱你。 你已经知道我对你的爱有点自私。真的，哪一个人得到一颗明珠不希望它永远归己所有呢。我也是。我很知道你的爱情有多美好（这是人们很少能找到的啊！），我又怎能情愿失去它呢。 我希望我的“自我”永远“吱吱”地响，翻腾不休，就像火炭上的一滴糖。 我现在正在看《大卫? 科波菲尔》，真是好书。我现在看得进这样的书了。他们对人们怀有多深的情感啊！现代作家们对别人永远不及对自己的八分之一关心。我因为这个恨他们。他们写自己的满腹委屈，写自己的无所事事，这怎么可以呢？人不能不爱别人啊。 有时我有点担心你和我是很不同的人。我正是为这一点爱你，可是我怕你会为这一点不爱我。你呀， 于结婚不结婚之类的事情我都不爱去想。世俗所谓必不可少的东西我是一件也不要的。还有那个“爱”、“欠情”之类，似乎无关紧要。只希望你和我好，互不猜忌，也互不称誉，安如平日，你和我说话像对自己说话一样，我和你说话也像对自己说话一样。说吧，和我好吗？]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书书摘 王小波</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 优化篇（二）]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[优化数据库对象 优化表的数据类型 ​ 使用 PROCEDURE ANALYSE() 对当前已有应用的表类型的判断，该函数可 以对数据表中的列的数据类型提出优化建议，可以根据应用的实际情况酌情考虑是否实施优 化。12SELECT * FROM tbl_name PROCEDURE ANALYSE();SELECT * FROM tbl_name PROCEDURE ANALYSE(16,256); ​ 输出的每一列信息都会对数据表中的列的数据类型提出优化建议。第二个例子告诉 PROCEDURE ANALYSE()不要为那些包含的值多于 16 个或者 256 字节的 ENUM 类型提出建议。如果没有这样的限制，输出信息可能很长;ENUM 定义通常很难阅读。 通过拆分，提高表的访问效率 主要是针对 Myisam 类型的表，拆分的方法可以分成两种情况: 纵向拆分: 纵向拆分是只按照应用访问的频度，将表中经常访问的字段和不经常访问的字段拆分成两个表，经常访问的字段尽量是定长的，这样可以有效的提高表的查询和更新的效率。 横向拆分: 横向拆分是指按照应用的情况，有目的的将数据横向拆分成几个表或者通过分区分到多个分区中，这样可以有效的避免 Myisam 表的读取和更新导致的锁问题。 逆规范化​ 数据库的规范化设计强调数据的独立性，数据应该尽可能少地冗余，因为存在过多的冗余数据，这就意味着要占用了更多的物理空间，同时也对数据的维护和一致性检查带来了问题。 但是对于查询操作很多的应用，一次查询可能需要访问多表进行，如果通过冗余纪录在相同表中，更新的代价增加不多，但是查询操作效率可以有明显提高，这种情况就可以考虑通过冗余数据来提高效率。 使用冗余统计表​ 使用 create temporary table 语法，它是基于 session 的表，表的数据保存在内存里面，当 session 断掉后，表自然消除。 ​ 对于大表的统计分析，如果统计的数据量不大，利用 insert。。。 select 将数据移到临时表中比直接在大表上做统计要效率更高。 选择更合适的表类型 如果应用出现比较严重的锁冲突，请考虑是否更改存储引擎到 innodb，行锁机制可以有效的减少锁冲突的出现。 如果应用查询操作很多，且对事务完整性要求不严格，则可以考虑使用 Myisam 存储引擎。 锁问题 获得锁等待情况 可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定争夺: 12mysql&gt; show status like &apos;Table%&apos;; +----------------------------+----------+ | Variable_name | Value | +----------------------------+----------+ | Table_locks_immediate | 105 || Table_locks_waited | 3 | +----------------------------+----------+ 2 rows in set (0.00 sec) 可以通过检查 Innodb_row_lock 状态变量来分析系统上的行锁的争夺情况: 123456789mysql&gt; show status like &apos;innodb_row_lock%&apos;; +----------------------------------------+----------+| Variable_name | Value | +----------------------------------------+----------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 2001 || Innodb_row_lock_time_avg | 667 || Innodb_row_lock_time_max | 845 || Innodb_row_lock_waits | 3 |+----------------------------------------+----------+5 rows in set (0.00 sec) 另外，针对 Innodb 类型的表，如果需要察看当前的锁等待情况，可以设置 InnoDBMonitors，然后通过 Show innodb status 察看，设置的方式是: 1CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB; 监视器可以通过发出下列语句来被停止: 1DROP TABLE innodb_monitor; 什么情况使用表锁 很多操作都是读表。 在严格条件的索引上读取和更新，当更新或者删除可以用单独的索引来读取得到时: UPDATE tbl_name SET column=value WHERE unique_key_col=key_value; DELETE FROM tbl_name WHERE unique_key_col=key_value; SELECT 和 INSERT 语句并发的执行，但是只有很少的 UPDATE 和 DELETE 语句。 很多的扫描表和对全表的 GROUP BY 操作，但是没有任何写表。 什么情况使用行锁 行级锁定的优点: 当在许多线程中访问不同的行时只存在少量锁定冲突。 回滚时只有少量的更改。 可以长时间锁定单一的行。 行级锁定的缺点: 比页级或表级锁定占用更多的内存。 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。 如果你在大部分数据上经常进行 GROUP BY 操作或者必须经常扫描整个表，比其它锁定 明显慢很多。 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁 成本小于行级锁定。 如何减少锁冲突 对 Myisam 类型的表： Myisam 类型的表可以考虑通过改成 Innodb 类型的表来减少锁冲突。 根据应用的情况，尝试横向拆分成多个表或者改成 Myisam 分区对减少锁冲突也会有一定的帮助。 对 Innodb 类型的表 首先要确认，在对表获取行锁的时候，要尽量的使用索引检索纪录，如果没有使用索引访问，那么即便你只是要更新其中的一行纪录，也是全表锁定的。要确保 sql 是使用索引来访问纪录的，必要的时候，请使用 explain 检查 sql 的执行计划，判断是否按照预期使用了索引。 由于 mysql 的行锁是针对索引加的锁，不是针对纪录加的锁，所以虽然是访问不同行的纪录，但是如果是相同的索引键，是会被加锁的。应用设计的时候也要注意，这里和 Oracle 有比较大的不同。 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，当表有主键或者唯一索引的时候，不是必须使用主键或者唯一索引锁定纪录，其他普通索引同样可以用来检索纪录，并只锁定符合条件的行。 用 SHOW INNODB STATUS 来确定最后一个死锁的原因。查询的结果中，包括死锁的事务的详细信息，包括执行的 SQL 语句的内容，每个线程已经获得了什么锁，在等待什么锁，以及最后是哪个线程被回滚。详细的分析死锁产生的原因，可以通过改进程序有效的避免死锁的产生。 如果应用并不介意死锁的出现，那么可以在应用中对发现的死锁进行处理。 确定更合理的事务大小，小事务更少地倾向于冲突。 如果你正使用锁定读，(SELECT … FOR UPDATE 或 … LOCK IN SHARE MODE)，试着用更低的隔离级别，比如 READ COMMITTED。 以固定的顺序访问你的表和行。则事务形成良好定义的查询并且没有死锁。 优化 Mysql Server影响 Mysql 性能的重要参数 key_buffer_size 键缓存 (变量 key_buffer_size) 被所有线程共享; 服务器使用的其它缓存则根据需要分配。此参数只适用于 myisam 存储引擎。 下面的语句将表 t1、t2 和 t3 的索引分配给名为 hot_cache 的 键高速缓冲: 1mysql&gt; CACHE INDEX t1, t2, t3 IN hot_cache; 可以用 SET GLOBAL 参数设置语句或使用服务器启动选项设置在 CACHE INDEX 语句中引用的键高速缓冲的大小来创建键高速缓冲。 1mysql&gt; SET GLOBAL keycache1.key_buffer_size=128*1024; 要想删除键高速缓冲，将其大小设置为零: 1mysql&gt; SET GLOBAL keycache1.key_buffer_size=0; 请注意不能删除默认键高速缓冲。删除默认键高速缓冲的尝试将被忽略 如果你很少使用 MyISAM 表，那么也保留低于 16-32MB 的 key_buffer_size 以适应给予磁盘的临时表索引所需。 Table_cache ​ 数据库中打开表的缓存数量。table_cache 与 max_connections 有关。例如，对于 200 个并行运行的连接，应该让表的缓存至少有 200 * N，这里 N 是可以执行的查询的一个联接中表的最大数量。还需要为临时表和文件保留一些额外的文件描述符。 设置技巧： ​ 可以通过检查 mysqld 的状态变量 Opened_tables 确定表缓存是否太小: 123456mysql&gt; SHOW STATUS LIKE &apos;Opened_tables&apos;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Opened_tables | 2741 |+---------------+-------+ 如果值很大，即使你没有发出许多 FLUSH TABLES 语句，也应增加表缓存的大小。 innodb_buffer_pool_size 的设置 缓存 InnoDB 数据和索引的内存缓冲区的大小。你把这个值设得越高，访问表中数据需要得磁盘 I/O 越少。在一个专用的数据库服务器上，你可以设置这个参数达机器物理内存大小的 80%。尽管如此，还是不要把它设置得太大，因为对物理内存的竞争可能在操作系统上导致内存调度。 innodb_table_locks InnoDB 重视 LOCK TABLES，直到所有其它线程已经释放他们所有对表的锁定，MySQL 才从 LOCK TABLE .. WRITE 返回。默认值是 1，这意为 LOCK TABLES 让 InnoDB 内部锁定一个表。在使用 AUTOCOMMIT=1 的应用里，InnoDB 的内部表锁定会导致死锁 。可以通过设置 innodb_table_locks=0 来消除这个问题。 innodb_lock_wait_timeout Mysql 可以自动的监测行锁导致的死锁并进行相应的处理，但是对于表锁导致的死锁不能自动的监测，所以该参数主要被用来在出现类似情况的时候对锁定进行的后续处理。默认值是 50 秒，根据应用的需要进行调整。 innodb_doublewrite 默认地，InnoDB 存储所有数据两次，第一次存储到 doublewrite 缓冲，然后存储到确实的数据文件。如果对性能的要求高于对数据完整性的要求，那么可以通过–skip-innodb-doublewrite 关闭这个设置。 innodb_log_buffer_size 默认的设置在中等强度写入负载以及较短事务的情况下，服务器性能还可以。如果存在更新操作峰值或者负载较大，就应该考虑加大它的值了。如果它的值设置太高了，可能会浪费内存 – 它每秒都会刷新一次，因此无需设置超过 1 秒所需的内存空间。通常 8-16MB 就足够了。越小的系统它的值越小。 innodb_log_file_size 在高写入负载尤其是大数据集的情况下很重要。这个值越大则性能相对越高，但是要注意到可能会增加恢复时间。 I/O 问题 使用磁盘阵列或虚拟文件卷分布 I/O使用 Symbolic Links 分布 I/O​ 可以将表和数据库从数据库目录移动到其它的位置并且用指向新位置的符号链接进行替换。推荐的方法只需要将数据库通过符号链接指到不同的磁盘。符号链接表仅作为是最后的办法。 ​ 符号链接一个数据库的方法是，首先在一些有空闲空间的硬盘上创建一个目录，然后从 MySQL 数据目录中创建它的一个符号链接。 12shell&gt; mkdir /dr1/databases/testshell&gt; ln -s /dr1/databases/test /path/to/datadir 注意: 只有 MyISAM 表完全支持符号链接。对于其它表类型，如果试图在操作系统中 的文件上用前面的任何语句使用符号链接，可能会出现奇怪的问题。 应用优化 使用连接池 对于访问数据库来说，建立连接的代价比较昂贵，因此，我们有必要建立”连接池”以提高访问的性能。我们可以把连接当作对象或者设备，池中又有许多已经建立的连接，访问本来需要与数据库的连接的地方，都改为和池相连，池临时分配连接供访问使用，结果返回后，访问将连接交还。 减少对 Mysql 的访问 避免对同一数据做重复检索​ 应用中需要理清楚对数据库的访问逻辑，需要对相同表的访问，尽量集中在相同 sql 访问，一次提取结果，减少对数据库的重复访问。 使用 mysql query cache​ 作用：查询缓存存储 SELECT 查询的文本以及发送给客户端的相应结果。如果随后收到一个相同的查询，服务器从查询缓存中重新得到查询结果，而不再需要解析和执行查询。 ​ 使用范围：不发生数据更新的表。当表更改 (包括表结构和表数据) 后，查询缓存值 的相关条目被清空。 ​ 参数描述： ​ show variables like ‘%query_cache%’; ​ have_query_cache 表明服务器在安装使已经配置了高速缓存​ query_cache_size 表明缓存区大小，单位为 M ​ query_cache_type 的变量值从 0 到 2，含义分别为 ​ 0 或者 off(缓存关闭) ​ 1 或者 on(缓存打开，使用 sql_no_cache 的 select 除外) ​ 2 或者 demand(只有带 sql_cache 的 select 语句提供高速缓存) 在 SHOW STATUS 中，你可以监视查询缓存的性能: 变量 含义 Qcache_queries_in_cache 在缓存中已注册的查询数目 Qcache_inserts 被加入到缓存中的查询数目 Qcache_hits 缓存采样数数目 Qcache_lowmem_prunes 因为缺少内存而被从缓存中删除的查询数目 Qcache_not_cached 没有被缓存的查询数目 (不能被缓存的，或由于 QUERY_CACHE_TYPE) Qcache_free_memory 查询缓存的空闲内存总数 Qcache_free_blocks 查询缓存中的空闲内存块的数目 Qcache_total_blocks 查询缓存中的块的总数目 加 cache 层 ​ Cache(高速缓存)、Memory(内存)、Hard disk(硬盘) 都是数据存取单元，但存取速度却有很大差异，呈依次递减的顺序。对于 CPU 来说，它可以从距离自己最近的 Cache 高速地存取数据，而不是从内存和硬盘以低几个数量级的速度来存取数据。而 Cache 中所存储的数据，往往是 CPU 要反复存取的数据，有特定的机制 (或程序) 来保证 Cache 内数据的命中率(Hit Rate)。因此，CPU 存取数据的速度在应用高速缓存后得到了巨大的提高。 ​ 因为将数据写入高速缓存的任务由 Cache Manager 负责，所以对用户来说高速缓存的内容肯定是只读的。需要你做的工作很少，程序中的 SQL 语句和直接访问 DBMS 时没有分别，返回的结果也看不出有什么差别。而数据库厂商往往会在 DB Server 的配置文件中提供与 Cache 相关的参数，通过修改它们，可针对我们的应用优化 Cache 的管理。 负载均衡​ 1. 利用 mysql 复制分流查询操作 ​ 利用 mysql 的主从复制可以有效的分流更新操作和查询操作，具体的实现是一个主服务器，承担更新操作，多台从服务器，承担查询操作，主从之间通过复制实现数据的同步。多台从服务器一方面用来确保可用性，一方面可以创建不同的索引满足不同查询的需要。 ​ 对于主从之间不需要复制全部表的情况，可以通过在主的服务器上搭建一个虚拟的从服务器，将需要复制到从服务器的表设置成 blackhole 引擎，然后定义 replicate-do-table 参数只复制这些表，这样就过滤出需要复制的 binlog，减少了传输 binlog 的带宽。因为搭建的虚拟的从服务器只起到过滤 binlog 的作用，并没有实际纪录任何数据，所以对主数据库服务器的性能影响也非常的有限。 ​ 通过复制分流查询的存在的问题是主数据库上更新频繁或者网络出现问题的时候，主从之 间的数据可能存在差异，造成查询结果的异议，应用在设计的时候需要有所考虑。 ​ 2. 采用分布式数据库架构 ​ mysql 从 5.0.3 开始支持分布式事务，当前分布式事务只对 Innodb 存储引擎支持。分布式的数据库架构适合大数据量，负载高的情况，有良好的扩展性和高可用性。通过在多台服务器之间分布数据实现在多台服务器之间的负载平均，提高了访问的执行效率。具体实现的时候，可以使用 mysql 的 Cluster 功能 (NDB 引擎) 或者自己编写程序来实现全局事务 。 ​ ​​​]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Mysql Server 优化 锁 优化表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构（三）]]></title>
    <url>%2F2017%2F11%2F10%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[排序 排序：假设含有 n 个记录的序列为 {r~1~,r~2~,….,r~n~}, 其相应的关键字分别为{k~1~,k~2~,…,k~n~}, 需确定 1，2，…，n 的一种排列 p~1~,p~2~,…,p~n~, 使其对应的关键字满足 k~p1~≤k~p2~≤…≤k~pn~(非递减或非递增) 关系，即使得序列成为一个按关键字有序的序列{r~p1~,r~p2~,…,r~pn~}, 这样的操作就称为排序。 稳定排序和不稳定排序：假设 k~i~ = k~j~ (1≤i≤n,1≤j≤n,i≠j), 且在排序前的序列中 r~i~ 领先于 r~j~(即 i＜j). 如果排序后 r~i~ 仍领先于 r~j~，则称所用的排序方法是稳定的，反之，则是不稳定的。（只要有一组关键字实力发生上面描述的情况，就可认为此排序方法是不稳定的） 内排序和外排序 内排序：在排序整个过程中，待排序的所有记录全部被放置在内存中。 外排序：由于排序的记录个数太多，不能同时放置在内存，整个排序过程需要在内外村之间多次交换数据才能进行。 对于内排序来说，排序算法的性能主要是受 3 个方面影响 时间性能 尽可能少的关键字比较次数和记录移动次数 辅助空间 辅助存储空间是除了存放待排序所占用的存储空间之外，执行算法所需要的其他存储空间。 算法的复杂性 指算法本身的复杂度，而不是指算法的时间复杂度。 根据排序过程中借助的主要操作，我们把内排序分为：插入排序，交换排序，选择排序和归并排序。 123456789/* 首先定义一个经常用到的排序函数 */void swap(SqList *L, int i ,ini j)&#123; Int temp = L-&gt;r[i]; L-&gt;r[i] = L-&gt;r[j]; L-&gt;r[j] = temp;&#125; 冒泡排序 一种交换排序，基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。 12345678910111213141516171819/* 对顺序表 L 作冒泡排序 */void BubbleSort(SqList *L)&#123; int i,j; Status flag = TRUE; /* 改进代码，用 flag 作标记 */ for(i=1; i&lt;L-&gt;length &amp;&amp; flag; i++) /* 改进代码 若 flag 为 false 则退出循环 */ &#123; flag = FALSE; /* 改进代码，初始为 false*/ for(j=L-&gt;length-1; j＞=i; j--)/*j 是从后往前循环的 */ &#123; if(L-&gt;r[j]&gt;L-&gt;r[j+1]) &#123; swap(L,j,j+1); flag = TRUE; /* 改 如果有数据交换，则 flag 为 true*/ &#125; &#125; &#125;&#125;上面的改进代码增加了一个标记变量 flag 来实现这一算法。防止出现 &#123;2,1,3,4,5,6,7,8,9&#125; 这样的排序数组而造成多于的循环。flag 用来标记是否在循环中存在数据交换，如果有交换则说明是无序的，flag 也就等于 ture 不满足 for 的退出条件，只要循环发现没有进行数据交换则 flag 为 false 退出循环。 简单选择排序 就是通过 n-i 次关键字间的比较，从 n-i+1 个记录中选出关键字最小的记录，并和第 i(1≤i≤n)个记录交换之。 1234567891011121314151617/* 对顺序表 L 作简单选择排序 */void SelectSort(SqList *L)&#123; int i,j,min; for(i=1; i&lt;L-&gt;length; i++) &#123; min = i; for(j = i+1; j&lt;=L-&gt;length; j++) &#123; if(L-&gt;r[min]&gt;L-&gt;r[j]) min = j; &#125; if(i != min) /* 若 min 不等于 i，则说明找到最小值，交换 */ swap(L,i,min); &#125;&#125;比较数据和冒泡排序无差别，但是只在最外层循环中交换了一次数据。而冒泡排序在最内层排序中交换了多次数据。所以其交换移动数据次数相当少。其余冒泡排序的总的事件复杂度都为 O(n^2^), 但在性能上是略优于冒泡排序的。 直接插入排序 基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的，记录数增 1 的有序表。 1234567891011121314151617/* 对顺序表 L 作直接插入排序 *//*&#123;5,3,4,6,2&#125; 在此数组中插入一个哨兵 r[0]=0 变为 &#123;0,5,3,4,6,2&#125;*/void InsertSort(SqList *L)&#123; int i,j; for(i=2; i&lt;=L-&gt;length; i++) &#123; if(L-&gt;r[i]&lt;L-&gt;r[i-1]) &#123; L-&gt;r[0]=L-&gt;r[i]; /* 设置哨兵 */ for(j=i-1;L-&gt;r[j]&gt;L-&gt;r[0];j--) L-&gt;r[j+1]=L-&gt;r[j]; /* 记录后移 */ L-&gt;r[j+1]=L-&gt;r[0]; /* 插入到正确位置 */ &#125; &#125;&#125;和其他排序相比，还是比较只不过少了数据交换的步骤变为数据移动。其时间复杂度也为 O(n^2^)但性能相对于冒泡和简单排序的性能要好一些。 希尔排序 跳跃分割策略：将相距某个“增量”的记录组成一个子序列，这样才能保证在子序列内分别进行直接插入排序后得到的结果是基本有序而不是局部有序。 12345678910111213141516171819202122/* 对顺序表 L 做希尔排序 */void ShellSort(SqList *L)&#123; int i,j; int increment=L-&gt;length; /* 增量序列 */ do &#123; increment = increment/3+1; /* 增量值 */ for(i=increment+1; i&lt;=L-&gt;length; i++) &#123; if(L-&gt;r[i]&lt;L-&gt;r[i-increment]) &#123;/* 将 L-&gt;r[i]插入有序增量子表 */ L-&gt;r[0]=L-&gt;r[i]; /* 暂存在 L-&gt;r[0]*/ for(j=i-increment; j&gt;0&amp;&amp;L-&gt;r[0]&lt;L-&gt;r[j];j-=increment) L-&gt;r[j+increment]=L-&gt;r[j]; /* 记录后移，查找插入位置 */ L-&gt;r[j+increment]=L-&gt;r[0]; /* 插入 */ &#125; &#125; &#125; while(increment&gt;1);&#125;希尔排序将关键字较小的记录，不是一步一步地往前挪动，而是跳跃式地往前移，从而使得每次完成一轮循环后，整个序列就朝着有序坚实地迈进一步。 大量的研究表明，当增量序列为 dlta[k]=2^t-k+1^-1(0≤k≤t≤[log~2~(n+1)])时，可以获得不错的效果。 增量序列的最后一个增量值必须等于 1 才行。 （Delta 是第四个希腊字母的读音，其大写为Δ，小写为δ。在数学或者物理学中大写的Δ用来表示增量符号。 而小写 δ 通常在高等数学中用于表示变量或者符号。） 堆排序 堆：堆是具有下列性质的完全二叉树：每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆，反之，每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆。 堆排序：利用堆进行排序。基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它移走(其实就是将其与堆数组的末尾元素交换，此时末尾元素就是最大值)，然后将剩下的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次小值。如此反复执行，便能得到一个有序序列了。 1234567891011121314151617181920212223242526272829303132/* 堆顺序表 L 进行堆排序 */void HeapSort(SqList *L)&#123; int i; for(i=L-&gt;length/2;i&gt;0;i--) /* 把 L 中的 r 构建成一个大顶堆 */ HeapAdjust(L,i,L-&gt;length);/* 重要：其中的对应 HeapAdjust 函数中的 s 参数 */ for(i=L-&gt;length;i&gt;1;i--) &#123; swap(L,1,i); /* 将堆顶记录和当前未经排序子序列的最后一个记录交换 */ HeapAdjust(L,1,i-1); /* 将 L-&gt;r[1..i-1]重新调整为大顶堆 */ &#125;&#125;/* 已知 L-&gt;r[s..m]中记录的关键字除 L-&gt;r[s]之外均满足堆的定义 *//* 本函数调整 L-&gt;r[s]的关键字，使 L-&gt;r[s..m]成为一个大顶堆 */void HeapAdjust(SqList *L,int s,int m)&#123; int temp,j; temp=L-&gt;r[s]; for(j=2*s; j&lt;=m; j*=2) /* 沿关键字较大的孩子结点向下筛选 */ &#123; if(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-r[j+1]) ++j; /*j 为关键字中较大的记录的下标 */ if(temp&gt;=L-&gt;r[j]) break; /*rc 应插入在位置 s 上 */ L-&gt;r[s]=L-&gt;r[j]; s=j; &#125; L-&gt;r[s]=temp; /* 插入 */&#125;其中的 j=2*s 这行代码是根据二叉树的性质得出的。因为是完全二叉树，当前结点序号是 s，其左孩子的序号一定是 2s，右孩子的序号一定是 2s+1, 它们的孩子当然也是以 2 的位数序号增加。 其无论是最好，最坏和平均时间复杂度均为 O(nlogn)。在性能上远远好于冒泡，简单选择，直接插入的 O(n^2^)的时间复杂度。空间复杂度上，它只有一个用来交换的暂存单元。 不过由于记录的比较和交换是跳跃式进行，因此堆排序也是一种不稳定的排序方法。另外，由于初始构建堆所需的比较次数较多，因此，它并不适合待排序序列个数较少的情况。 归并排序 原理是假设初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1，然后两两归并，得到 [n/2] ([x] 表示不小于 x 的最小整数)个长度为 2 或 1 的有序子序列；再两两归并，…，如此重复，直至得到一个长度为 n 的有序序列为止，这种排序方法称为 2 路归并排序。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/* 对顺序表 L 作归并排序 */void MergeSort(SqList *L)&#123; MSort(L-&gt;r,L-&gt;r,1,L-&gt;length);&#125;/* 将 SR[s..t]归并排序为 TR1[s..t]*/void MSort(int SR[],int TR1[],int s,int t)&#123; int m; int TR2[MAXSIZE+1]; if(s==t) TR1[s]=SR[S]; else &#123; m = (s+t)/2; /* 将 SR[s..t]平分为 SR[s..m]和 SR[m+1..t]*/ MSort(SR,TR2,s,m); /* 递归将 SR[s..m]归并为有序的 TR2[s..m]*/ MSort(SR,TR2,m+1,t); /* 递归将 SR[m+1..t]归并为有序 TR[m+1..t]*/ Merge(TR2,TR1,s,m,t); /* 将 TR2[s..m]和 TR2[m+1..t]归并到 TR1[s..t]*/ &#125;&#125;/* 将有序的 SR[i..m]和 SR[m+1..n]归并为有序的 TR[i..n]*/void Merge(int SR[],int TR[], int i, int m, int n)&#123; int j,k,l; for(j=m+1,k=i;i&lt;=m &amp;&amp; j&lt;=n;k++) /* 将 SR 中记录由小到大归并入 TR*/ &#123; if(SR[i]&lt;SR[j]) TR[k]=SR[i++]; /* 执行完之后执行加 1*/ else TR[k]=SR[j++]; &#125; if(i&lt;=m) &#123; for(l=0;l&lt;=m-i;l++) TR[k+l]=SR[i+l]; /* 将剩余的 SR[i..m]复制到 TR */ &#125; if(j&lt;=n) &#123; for(l=0;l&lt;=n-j;l++) TR[k+1]=SR[j+l]; /* 将剩余的 SR[j..n]复制到 TR */ &#125;&#125;归并的时间复杂度为 O(n+logn)归并的 merge 函数存在 if 两两比较，不存在跳跃，因此归并排序是一种比较占用内存，但却效率高且稳定的排序算法。/* 对顺序表 L 作归并非递归排序 */void MergeSort2(SqList *L)&#123; int* TR = (int*)malloc(L-&gt;length*sizeof(int)); /* 申请额外空间 */ int k=1; while(k&lt;L-&gt;length) &#123; MergePass(L-&gt;r,TR,k,L-&gt;length); k=2*k; /* 子序列长度加倍 */ MergePass(TR,L-&gt;r,k,L-&gt;length); k=2*k; /* 子序列长度加倍 */ &#125;&#125;/* 将 SR[]中相邻长度为 s 的子序列两两归并到 TR[]*/void MergePass(int SR[],int TR[],int s, int n)&#123; int i=1; int j; while(i &lt;= n-2*s+1) &#123; Merge(SR,TR,i,i+s-1,i+2*s-1);/* 两两归并 */ i=i+2*s; &#125; if(i&lt;n-s+1) /* 归并最后两个序列 */ Merge(SR,TR,i,i+s-1,n); else /* 若最后只剩下单个子序列 */ for(j=i;j&lt;=n;j++) TR[j]=SR[j];&#125;非递归的迭代方法，避免了递归时深度为 log~2~n 的栈空间，空间只是用到申请归并临时用的 TR 数组，因此空间复杂度为 O(n), 并且避免递归也在时间性能上有一定的提升，因此使用归并排序时，尽量考虑用非递归方法。 快速排序 基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。关键的是确定分割点。也就是枢轴。 1234567891011121314151617181920212223242526272829303132333435363738/* 对顺序表 L 作快速排序 */void QuickSort(SqList *L)&#123; Qsort(L,1,L-&gt;length);&#125;/* 对顺序表 L 中的子序列 L-&gt;r[low..high]作快速排序 */void QSort(SqList *L,int low,int high)&#123; int pivot; if(low&lt;high) &#123; pivot=Partition(L,low,high); /* 将 L-&gt;r[low..high]一分为二 */ /* 算出枢轴值 privot*/ QSort(L,low,pivot-1); /* 对低子表递归排序 */ QSort(L,pivot+1,high); /* 对高子表递归排序 */ &#125;&#125;/* 交换顺序表 L 中子表的记录，使枢轴记录到位，并返回其所在位置 *//* 此时在它之前 (后) 的记录均不大 (小) 于它 */int Partition(SqList *L,int low,int high)&#123; int pivotkey; pivotkey=L-&gt;r[low]; /* 用子表的第一个记录枢轴记录 */ while(low&lt;high) /* 从表的两端交替向中间扫描 */ &#123; while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey) high--; swap(L,log,high); /* 将此枢轴记录小的记录交换到低端 */ while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey) low++; swap(L,low,high); /* 将此枢轴记录大的记录交换到高端 */ &#125; return low; /* 返回枢轴所在位置 */&#125;就空间复杂度来说，主要是递归造成的栈空间的使用，最好情况，递归树的深度为 log~2~n, 空间复杂度为 O(logn), 最坏情况，需要进行 n-1 递归调用，其空间复杂度为 O(n)，平均情况，空间复杂度为 O(logn)。可惜的是，由于关键字的比较和交换是跳跃进行的，因此，快速排序也是一种不稳定改的排序方法。 快速排序优化1. 优化选取枢轴 三数取中法获取枢轴：取三个关键字先进行排序，将中间数作为枢轴，一般是取左端，右端和中间三个数。（对于数据较大的序列来说可以使用九数取中法，同上。） 需在 Partition 函数代码的第 3 行与第 4 行之间增加这样一段代码。 1234567int m = low + (high-low)/2;if(L-&gt;r[low]&gt;L-&gt;r[high]) swap(L,low,high);if(L-&gt;r[m]&gt;L-&gt;r[high]) swap(L,high,m);if(L-&gt;r[m]&gt;L-&gt;r[low]) swap(L,m,low); 2. 优化不必要的交换 12345678910111213141516171819/* 快速排序优化算法 */int Partition(SqList *L,int low,int high)&#123; int pivotkey; // 这里省略三数取中代码 pivotkey=L-&gt;r[low]; L-&gt;r[0]=pivotkey; /* 将枢轴关键字备份到 L-&gt;r[0]*/ while(low&lt;high) &#123; while(low&lt;high &amp;&amp; L-&gt;r[high]&gt;=pivotkey) high--; L-r[low]=L-&gt;r[high]; /* 采用替换而不是交换的方式进行操作 */ while(low&lt;high &amp;&amp; L-&gt;r[low]&lt;=pivotkey) low++; L-r[high]=L-&gt;r[low]; /* 采用替换而不是交换的方式进行操作 */ &#125; L-&gt;r[low]=L-&gt;r[0]; /* 将枢轴数值替换回 L-&gt;r[low]*/ return low; &#125; 3. 优化小数组时的排序方案 改进 QSort 函数 123456789101112131415#define MAX_LENGTH_INSERT_SORT 7 /* 数组长度阈值 *//* 对顺序表 L 中的子序列 L-&gt;r[low..high]作快速排序 */void QSort(SqList *L,int low,int high)&#123; int pivot; if((high-low)&gt;define MAX_LENGTH_INSERT_SORT) /* 当 high-low 大于常数时用快速排序 */ &#123; pivot=Partition(L,low,high); QSort(L,low,pivot-1); QSort(L,pivot+1,high); &#125; else /* 当 high-low 小于等于常数时用直接插入排序 */ InsertSort(L);&#125; 4. 优化递归操作 对 QSort 实施尾递归优化。 12345678910111213141516171819#define MAX_LENGTH_INSERT_SORT 7 /* 数组长度阈值 *//* 对顺序表 L 中的子序列 L-&gt;r[low..high]作快速排序 */void QSort(SqList *L,int low,int high)&#123; int pivot; if((high-low)&gt;define MAX_LENGTH_INSERT_SORT) /* 当 high-low 大于常数时用快速排序 */ &#123; while(low&lt;high) &#123; pivot=Partition(L,low,high); /* 此处的 Partition 函数已是上面优化过的函数 */ QSort(L,low,pivot-1); low = pivot+1; /* 尾递归 */ &#125; &#125; else InsertSort(L);&#125;尾递归因采用了迭代而不是递归的方法可以缩减堆栈深度，从而提高了整体性能。 总结回顾 直接插入排序 —&gt; 希尔排序 插入排序类 简单选择排序—&gt; 堆排序 选择排序类 冒泡排序—&gt; 快速排序 交换排序类 归并排序 归并排序类 算法指标对比 排序方法 平均情况 最好情况 最坏情况 辅助空间 稳定性 冒泡排序 O(n^2^) O(n) O(n^2^) O(1) 稳定 简单选择排序 O(n^2^) O(n^2^) O(n^2^) O(1) 稳定 直接插入排序 O(n^2^) O(n) O(n^2^) O(1) 稳定 希尔排序 O(nlogn)~O(n^2^) O(n^1.3^) O(n^2^) O(1) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2^) O(nlogn)~O(n) 不稳定]]></content>
      <categories>
        <category>数据结构 算法</category>
      </categories>
      <tags>
        <tag>图表 路径算法 树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 优化篇（一）]]></title>
    <url>%2F2017%2F11%2F10%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL 优化 优化 SQL 的一般步骤 通过 show status 和应用特点了解各种 SQL 的执行频率 通过 SHOW STATUS 可以提供服务器状态信息， 也可以使用 mysqladmin extended-status 命令获得。 SHOW STATUS 可以根据需要显示 session 级别的统计结果和 global 级别的统计结果。 Connections 试图连接 Mysql 服务器的次数 Uptime 服务器工作时间 Slow_queries 慢查询的次数 Com_select/Innodb_rows_read select 针对 Myisam 和 Innodb 存储引擎执行操作的次数，累加（包括批量操作）为 1. 对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚 的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。 定位执行效率较低的 SQL 语句 可以通过慢查询日志定位那些执行效率较低的 sql 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。可以链接到管理维护中的相关章节。 慢查询日志在查询结束以后才纪录， 所以在应用反映执行效率出现问题的时候询查慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前 MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看 SQL 执行情况，同时对一些锁表操作进行优化。 通过 EXPLAIN 分析低效 SQL 的执行计划 ​ 可以通过 explain 或者 desc 获取 MySQL 如何执行 SELECT 语句的信息， 包括 select 语句执行过程表如何连接和连接的次序。 ​ explain 可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的 SELECT。 1234567891011121314mysql&gt; explain select sum(moneys) from sales a,companys b where a.company_id =b.id and a.year = 2006;+----------------+----------+-----------+----------------+----------------+--------- -+-----------+----------------+| select_type | table | type | possible_keys| key | key_len | rows | Extra |+----------------+----------+-----------+----------------+----------------+----------+-----------+----------------+网易技术部47www.163.com | SIMPLE | b | index | PRIMARY | PRIMARY | 4 | 1 | Using index || SIMPLE | a | ALL | NULL | NULL | NULL | 12 | Using where |+----------------+----------+-----------+----------------+----------------+--------- -+-----------+----------------+2 rows in set (0.02 sec) select_type: select 类型 table: 输出结果集的表 ​type: 表示表的连接类型 当表中仅有一行是 type 的值为 system 是最佳的连接类型; 当 select 操作中使用索引进行表连接时 type 的值为 ref; 当 select 的表连接没有使用索引时，经常会看到 type 的值为 ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。 possible_keys: 表示查询时, 可以使用的索引列. key: 表示使用的索引 key_len: 索引长度 rows: 扫描范围 Extra: 执行情况的说明和描述 确定问题，并采取相应的优化措施 ​ 经过以上步骤，基本可以确认问题出现的原因，可以根据情况采取相应的措施，进行优化提高执行的效率。 例如上面的例子，我们确认是对 a 表的全表扫描导致效率的不理想，我们对 a 表的 year 字段创建了索引，查询需要扫描的行数明显较少。 索引问题 如何使用索引​ 查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。 下列情况下，Mysql 不会使用已有的索引: 如果 mysql 估计使用索引比全表扫描更慢，则不使用索引。例如: 如果 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好:SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90 如果使用 heap 表并且 where 条件中不用 = 索引列，其他 &gt; 、&lt;、 &gt;=、 &lt;= 均不使用索引; 如果不是索引列的第一部分; 如果 like 是以 % 开始; 对 where 后边条件为字符串的一定要加引号，字符串如果为数字 mysql 会自动转为字符串，但是不使用索引。 查看索引的使用情况1mysql&gt; show status like &apos;Handler_read%&apos;; ​ Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。 索引优化 定期分析表 ANALYZE TABLE 1ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于 MyISAM, BDB 和 InnoDB 表有作用。对于 MyISAM 表，本语句与使用 myisamchk-a 相当。 CHECK TABLE 12CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125; 检查一个或多个表是否有错误。CHECK TABLE 对 MyISAM 和 InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。 CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。 CHECKSUM TABLE 1CHECKSUM TABLE tbl_name [, tbl_name] ... [QUICK | EXTENDED] 报告一个表校验和。 使用 optimize table 1OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表 (含有 VARCHAR, BLOB 或 TEXT 列的表) 进行了很多更改，则应使用 OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的 INSERT 操作会重新使用旧的记录位置。您可以使用 OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。OPTIMIZE TABLE 只对 MyISAM, BDB 和 InnoDB 表起作用。 SQL 具体优化 大批量插入数据 对于 Myisam 类型的表，可以通过以下方式快速的导入大量的数据。 123ALTER TABLE tblname DISABLE KEYS;loading the dataALTER TABLE tblname ENABLE KEYS; 这两个命令用来打开或者关闭 Myisam 表非唯一索引的更新。在导入大量的数据到一 个非空的 Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量 数据到一个空的 Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行 设置。 对于 Innodb 类型的表，这种方式并不能提高导入数据的效率。对于 Innodb 类型 的表，我们有以下几种方式可以提高导入的效率 因为 Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果 Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行 SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动 提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 优化 inser 语句 将索引文件和数据文件分在不同的磁盘上存放(利用建表中的选项); 如果进行批量插入，可以增加 bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对 myisam 表使用; 当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍; 根据应用情况使用 replace 语句代替 insert; 根据应用情况使用 ignore 关键字忽略重复记录。 如果你从不同客户插入很多行，能通过使用 INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让 insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘; 这比每条语句分别插入要快的多;LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入; 如果你同时从同一客户插入很多行，使用多个值表的 INSERT 语句。这比使用分开 INSERT 语句快(在一些情况中几倍)。 1Insert into test values(1,2),(1,3),(1,4)... 优化 group by 语句 默认情况下，MySQL 排序所有 GROUP BY col1，col2，….。查询的方法如同在查询 中指定 ORDER BY col1，col2，…。如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括 GROUP BY 但你想要避免排序结果的消耗，你可以指定 ORDER BY NULL禁止排序。 例如: 1SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL; 优化 or 条件 对于 or 子句，如果要利用索引，则 or 之间的每个条件列都必须用到索引; 如果没有索引，则应该考虑增加索引。 Mysql 默认调度策略 写入操作优先于读取操作。 对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。 对某张数据表的多个读取操作可以同时地进行。 MySQL 提供了几个语句调节符，允许你修改它的调度策略: LOW_PRIORITY 关键字应用于 DELETE、INSERT、LOAD DATA、REPLACE 和 UPDATE。 HIGH_PRIORITY 关键字应用于 SELECT 和 INSERT 语句。 DELAYED 关键字应用于 INSERT 和 REPLACE 语句。 使用 SQL 提示 当处理一个会让客户端耗费点时间才能处理的大结果集时，可以考虑使用 SQL_BUFFER_RESULT 提示字。这样可以告诉 MySQL 将结果集保存在一个临时表中，这 样可以尽早的释放各种锁。 USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供你希望 MySQ 去参考的索引列 表，就可以让 MySQL 不再考虑其他可用的索引。 1Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ... IGNORE INDEX 如果你只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。 1Eg:SELECT * FROM mytale IGNORE INDEX (priority) ... FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 Hint。 1Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ... 其他优化措施 使用持久的连接数据库以避免连接开销。 经常检查所有查询确实使用了必要的索引。 避免在频繁更新的表上执行复杂的 SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。 对于没有删除的行操作的 MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作. 对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。 充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减 少 MySQL 需要做的语法分析从而提高插入速度。 对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。 通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。 表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的 影响，推荐通过应用来实现字段的自增长。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL优化 索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 开发篇（一）]]></title>
    <url>%2F2017%2F11%2F07%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E5%BC%80%E5%8F%91%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mysql 字符集介绍 ​ mysql 的字符集包括字符集(CHARACTER) 和校对规则 (COLLATION) 两个概念。字符集是用来定义 mysql 存储字符串的方式，校对规则则是定义了比较字符串的方式。字符集和校对规则是一对多的关系, MySQL 支持 30 多种字符集的 70 多种校对规则。每个字符集至少对应一个校对规则。 可以 S 用 HOW COLLATION LIKE ‘utf8%’; 命令查看相关字符集的校对规则。 Unicode 一种字符编码方法。 全名 ‘Universal Multiple-Octet Coded Character Set’ 简称 UCS。 字符集 选择字符集​ 通常建议在能够完全满足应用的前提下，尽量使用小的字符集。因为更小的字符集意味着能够节省空间，减少网络传输字节数，同时由于存储空间的较小间接的提高了系统的性能。 ​ 有很多字符集可以保存汉字，比如 utf8、gb2312、gbk、latin1 等等，但是常用的是 gb2312 和 gbk。因为 gb2312 字库比 gbk 字库小，有些偏僻字 (例如: 洺) 不能保存，因此在选择字符集的时候一定要权衡这些偏僻字在应用出现的几率以及造成的影响， 不能做肯出定答复的话最好选用 gbk。 Mysql 字符集的设置​ mysql 的字符集和校对规则有 4 个级别的默认设置: 服务器级、 数据库级、 表级和段字级。分别在不同的地方设置，作用也不相同。 服务器字符集和校对，在 mysql 服务启动的时候确定。可以在 my.cnf 中设置:[mysqld]default-character-set=utf8 或者在启动选项中指定:mysqld –default-character-set=utf8或者在编译的时候指定:./configure –with-charset=utf8 如果没有特别的指定服务器字符集，默认使用 latin1 作为服务器字符集。上面三种设置的方式都只指定了字符集， 没有指定校对规则， 这样是使用该字符集默认的校对规则如，果要使用该字符集的非默认校对规则，则需要在指定字符集的同时指定校对规则。 可以用 show variables like ‘character_set_server’; 命令查询当前服务器的字符集和校对规则。 索引的设计和使用​ 所有 MySQL 列类型可以被索引。对相关列使用索引是提高 SELECT 操作性能的最佳途径。 根据存储引擎定义每个表的最大索引数和最大索引长度。 所有存储引擎支持每个表少至 16 个索引，总索引长度至少为 256 字节。大多数存储引擎有更高的限制。 ​ 还可以创建 FULLTEXT 索引。该索引可以用于全文搜索。只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只为 CHAR、VARCHAR 和 TEXT 列。索引总是对整个列进行，不支持局部 (前缀) 索引。也可以为空间列类型创建索引。只有 MyISAM 存储引擎支持空间类型。空间索引使用 R- 树。默认情况 MEMORY(HEAP)存储引擎使用 hash 索引，但也支持 B- 树索引。 设计索引的原则 搜索的索引列， 不一定是所要选择的列。 换句话说， 最适合索引的列是出现在 WHERE 子句中的列， 或连接子句中指定的列， 而不是出现 S 在 ELECT 关键字后的选择列表中的列。 使用惟一索引。 考虑某列中值的分布。 对于惟一值的列， 索引的效果最好， 而具有多个重复值的列，其索引效果最差。例如，存放年龄的列具有不同值，很容易区分 各行。而用来记录性别的列，只含有“ M”和“F”，则对此列进行索引没有多大用处(不管搜索哪个值，都会得出大约一半的行) 使用短索引。 如果对串列进行索引， 应该指定一个前缀长度， 只要有可能就应该这做。样例如，如果有一个 CHAR(200) 列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前 10 个或 20 个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 I/O 较少，较短的值比较起来更快。更为重要的是， 对于较短的键值， 索引高速缓存中的块能容纳更多的键值， 因 M 此 yS，QL 也可以在内存中容纳更多的值。这增加 了找到行而不用读取索引中较多块的可能性。 (当然， 应该利用一些常识。 如仅用列值的一第个字符进行索引是不可能有多大好处的，因为这个索引中不会有许多不 同的值。) 利用最左前缀。在创建 一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可起几个索引的作用， 因为可利用索引中最左边的列集来匹配行。 这样的集列称为最左前缀。 (这与索引一个列的前缀不同，索引一个列的前缀是利用该的 n 前个字符作为索引值。) 不要过度索引。 不要以为索引“越多越好”， 什么东西都用索引是错的。 每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能，这一点我们前面已经介绍 过。在修改表的内容时， 索引必须进行更新， 有时可能需要重构， 因此， 索引越多， 所花时的间越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表 的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最好索引。 只保持所需的索引有利于查询优化。 如果想给已索引的表增加索引， 应考该虑所要增加的索引是否是现有多列索引的最左 索引。如果是，则就不要费力去增加这个索引了，因为已经有了。 考虑在列上进行的比较类型。索引可用于“ &lt;”、“ &lt; = ”、“ = ”、“ &gt; =”、“ &gt;”和 BETWEEN 运算。在模式具有一个直接量前缀时，索引也用于 LIKE 运算。如果只 将某个列用于其他类型的运算时(如 STRCMP()) ，对其进行索引没有价值 Myssql 如何使用索引 索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL 必须从第 1 条记录开始然后读完整个表直到找出相关的行。 表越大， 花费的时间越多。 如果表中查询的有列一个索引，MySQL 能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。如果一个表有 1000 行，这比顺序读取至少快 100 倍。注意如果你需要访问大部分行，顺序读取要快得多，因为此时我们避免磁盘搜索。 大多数 MySQL 索引 (PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT) 在 B 树中存储。只是空间列类型的索引使用 R- 树，并且 MEMORY 表还支持 hash 索引。 锁机制和事务控制 如何加锁和解锁 锁定表的语法:LOCK TABLES123tbl_name [AS alias] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125;[, tbl_name [AS alias] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125;] ... 解锁语法:1UNLOCK TABLES innodb 的存储引擎提供行级锁，支持共享锁和排他锁两种锁定模式，以及四种不同的隔离级别。 死锁​ InnoDB 自动检测事务的死锁， 并回滚一个或几个事务来防止死锁 In。noDB 不能在 MySQL LOCK TABLES 设定表锁定的地方或者涉及 InnoDB 之外的存储引擎设置锁定的地方检测死锁。你必须通过设定 innodb_lock_wait_timeout 系统变量的值来解决这些情况。 如果要依靠等锁待超时来解决死锁问题， 对于更新事务密集的应用， 将有可能导致大量事务的锁等待，致导系统异常， 所以不推荐在一个事务中混合更新不同存储类型的表， 也不推荐相同类型的采表用不同的锁定方式加锁。 事务控制​ 当开始一个事务时，会造成一个隐含的 unlock tables 被执行。因此， 在同一个事务中， 最好不使用不同存储引擎的表， 否 r 则 ollback 时需要对非事务类型的表进行特别的处理，因为 commit、rollback 只能对事务类型的表进行提交和回滚。 ​ 在事务中可以通过定义 savepoint，指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 savepoint，满足不同的条件时，回滚不同的 savepoint。需要注意的是，如果定义了相同名字的 savepoint，则后面定义的 savepoint 会覆盖之前的定义。 对于不再需要使用 s 的 avepoint， 可以通过 release savepoint 命令删除 savepoint，删除后 savepoint，不能再执行 rollback to savepoint 命令。 SQL Mode 及相关问题 SQL Mode 简介​ 通常在 linux 下安装完 mysql 后，默认的 sql-mode 值是空，在这种情形下 mysql 执行的是一 种不严格的检查，例如日期字段可以插入 ’0000-00-00 00:00:00’这样的值，还有如果要插入 的字段长度超过列定义的长度， 那么 mysql 不会终止操作， 而是会自动截断后面的字符继续 插入操作，如下例： 1234567mysql&gt; create table t5 (c1 char(3)); mysql&gt; insert into t5 values(&apos;abcd&apos;); mysql&gt; select * from t5;+------+|c1 |+------+|abc |+------+1 row in set (0.00 sec) 我们可以设置 sql_mode 为 STRICT_TRANS_T ABLES，如下: 1mysql&gt; set session sql_mode=&apos;STRICT_TRANS_T ABLES&apos; 这样我们再执行同样的操作，mysql 就会告诉我们插入的值太长，操作被终止，如下: 123mysql&gt; insert into t5 values(&apos;abcd&apos;);ERROR 1406 (22001): Data too long for column &apos;c1&apos; at row 1 Sql_mode 值 描述 ANSI 更改语法和行为，使其更符合标准 SQL。 STRICT_TRANS_TABLES 如果不能将给定的值插入到事务表中， 则放弃该语句。 对于非事表，务如果值出现在单行语句或多行语句的第 1 行，则放弃该语句。 TRADITIONAL Make MySQL 的行为象“传统”SQL 数据库系统。该模式的简单描述是当在列中插入不正确的值时“给出错误而不是警告”。注释: 一旦发现错误立即放弃 INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。 SQL Mode 与数据效验 SQL Mode 还可以实现对数据效验和转移等功能如:·效验日期数据合法性.·在 INSERT 或 UPDATE 过程中，如果被零除(或 MOD(X，0))，则产生错误·将‘“’视为识别符引号(‘`’引号字符)·禁用反斜线字符(‘\’) 做为字符串内的退出字符。启用 NO_BACKSLASH_ESCAPES 模式，反斜线则成为普通字符。·将 || 视为字符串连接操作符(+)(同 CONCAT())，而不视为 OR。 ​​​ ​​​ ​​​​​​ ​​​]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL SQL Mode 索引 事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构（一）]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[数据结构绪论 基本概念和术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，病输入给计算机处理的符号集合。数据不仅仅包括整形，实型等数据类型，还包括字符及声音，图像，视频等非数值类型。数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 ### 逻辑结构 和 物理结构 逻辑结构 ：是指数据对象中数据元素之间的相互关系。 逻辑结构包括四种：集合结构（集合）、线性结构（一对一）、树形结构（一对多）、图形结构（多对多）。 物理结构：是指数据的逻辑结构在计算机中的存储形式。 数据元素的存储结构形式有两种： 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。 抽象数据类型 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。（如：’整数‘ 类型）。其定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。至于一个抽象数据类型到底需要哪些操作，就只能由设计者根据实际需要来定。 抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。 算法 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法五个特性：输入、输出、有穷性、确定性、可行性。 算法设计要求：正确性、可读性、健壮性、高效率和低存储量。 #### 函数的渐进增长 函数的渐进增长特性：使得判断一个函数的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。 算法时间复杂度 定义：在井陉算法分析时，语句总的执行次数 T（n）是关于问题规模 n 的函数，进而分析 T（n）随 n 的变化情况并确定 T（n）的数量级。算法的事件复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。 这样用大写 O()来体现算法时间复杂度的记法，我们称之为大 O 记法。一般情况下，随着 n 的增大，T（n）增长最慢的算法为最优算法。 O（1）常数阶 O（n）线性阶 O（n^2^）平方阶。 推导大 O 阶： 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。 算法空间复杂度 算法的空间复杂度通过计算算法所需的存储空间实现，其计算公式记作 S(n) = O(f(n)), 其中 n 为问题的规模， f(n)为语句关于 n 所占存储空间的函数。 线性表 线性表（List）: 零个或多个数据元素的有限序列。 #### 线性表的顺序存储结构 指的是用一段地址连续的存储单元依次存储线性表的数据元素。 线性表的顺序存储结构的优缺点： 优点：无需为表示表中元素之间的逻辑关系而增加额外的存储空间 ​ 可以快速地存取表中任一位置的元素 缺点：插入和删除操作需要移动大量元素 ​ 当线性表长度变化较大时，难以确定存储空间的容量 ​ 造成存储空间的“碎片” #### 线性表的链式存储结构 单链表 对于其存储的数据元素（a~i~）来说, 除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域成为数据域，把存储直接后继位置的域成为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素（a~i~）的存储映像，称为结点（Node）。 n 个结点（a~i~）链结成一个链表，即为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表。 头结点和头指针的区别：头指针只有指针域（必要元素） 头结点数据域和指针域都有（非必要）【头结点包含头指针】。 单链表的优势：对于插入或删除数据越频繁的操作，单链表的效率优势越是明显。 优缺点分析 顺序存储结构 单链表 存储分配方式 用一段连续的存储单元依次存储线性表的数据元素 采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找：O(1) 插入删除：O(n) 查找：O(n) 插入删除：O(1) 空间性能 需要预分配存储空间，分大了，浪费，分小了易发生上溢 不需要分配存储空间，元素个数也不受限制 ##### 静态链表 用数组描述的链表叫做静态链表。 重要的截图： 优点 缺点 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 没有解决连续存储分配带来的表长难以确定的问题。失去了顺序存储结构随机存取的特性。 ​ 静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 循环链表 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表。 双向链表 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。 栈与队列（特殊的线性表）栈 栈是限定仅在表尾进行插入和删除操作的线性表。简称 LIFO 结构。 栈的顺序与链式存储结构使用区别 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的应用 - 递归 斐波那契数列：前面相邻两项之和，构成了后一项。 递归函数：把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数。 （简单的说，就是在前行阶段，对于每一层递归，函数的局部变量，参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量，参数值和返回地址被弹出，用于返回调用层次中中执行代码的其余部分，也就是恢复了调用的状态。） 栈的应用 - 四则运算表达式求值 后缀（逆波兰）表示法定义— 一种不需要括号的后缀表示法，也称为逆波兰表示。叫后缀的原因是所有的符号都是在要运算数字的后面出现。 eg. “9 3 1 - 3* +10 2 /+”（后缀表达式） = “9+(3-1)x3+10÷2”(也称作中缀表达式) 将中缀表达式转换成后缀表达式（栈用来进出运算的符号） 将后缀表达式进行运算得出结果（栈用来进出运算的数字） 队列 队列是只允许一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的线性表，简称 FIFL。 循环队列 把队列的头尾相接的 顺序存储结构 称为循环队列。 队列的链式存储结构 其就是线性表的 单链表，只不过只能尾进头出，简称链队列。 循环队列和链队列的区别 时间上：循环队列事先申请好空间，使用期间不释放，链队列每次申请和释放结点也会存在一些时间开销。 空间上：循环队列必须有一个固定长度，所以就有了存储元素个数和空间浪费的问题。链队列不存在这个问题。 总之，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。 串（字符串）由零个或多个字符组成的有限序列。 朴素的模式匹配算法 子串的定位操作通常称为串的模式匹配。 朴素的模式匹配是根据两个需匹配的字符串各自的每个字符进行循环匹配的操作。容易出现极端情况，比如 00000…..0000001 与 00000001 的匹配，随着前者的长度越大，其匹配的效率越低。 KMP 模式匹配算法 克努特 Knuth - 莫里斯 Morris- 普拉特 Pratt 算法。 具体算法略 KMP 算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显。 KMP 算法待补充。 树 树的定义 树：树（Tree）是 n(n≥0)个结点的有限集。n=0 时称为空树。在任意一棵非空树中： （1）有且仅有一个特定的称为根（Root）的结点。 （2）当 n&gt;1 时，其余结点可分为 m(m&gt;0)个互不相交的有限集 T~1~、T~2~ 、…、T~m~，其中每个集合本身又是一棵树，并且称为根的子树（Subtree）。子树之间是不可相交的。 结点：树的结点包含一个数据元素及若干指向其子树的分支。 结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点。度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支节点也称为内部结点。树的度是树内其中结点的度的最大值。 结点间的关系 树的抽象数据类型 双亲表示法 就是在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。 当我们又关注结点的双亲，又关注结点的孩子，还关注结点的兄弟，而且对事件遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。 存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适，方便，时间复杂度好不好等。 孩子表示法 多重链表表示法：每个结点有多个指针域，其中每个指针指向一棵子树的根节点。 孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 当也需要找到某个结点的双亲时，可以和双亲表示法结合 孩子兄弟表示法 设置了两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。 二叉树的定义 二叉树：是 n(n≥0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 特殊的二叉树：斜树 满二叉树 完全二叉树（编号连续）（满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的） 二叉树的性质 在二叉树的第层上 至多 有 2^i-1^ 个结点 深度为 k 的二叉树至多有 2^k^-1 个结点 对任何二叉树 T，如果其终端结点数为 n~0~，度为 2 的结点数为 n~2~，则 n~0~=n~2~+1。（需要推导） 具有 n 个结点的完全二叉树的深度为 [log~2~n]+1(需要推导) 如果对一棵有 n 个结点的完全二叉树（深度为[log~2~n]+1）的结点按层序编号，对任一结点 i（1≤i≤n）有: 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1, 则其双亲结点为[i/2]。 如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。 如果 2i+1&gt;2 ，则结点 i 无右孩子；否则其右孩子是结点 2i+1。 二叉树的存储结构 二叉树顺序存储结构 用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。但是考虑到极端情况，比如一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 2~k~-1 个存储单元空间，造成了存储空间的浪费。所以顺序存储结构一般只用于完全二叉树。 二叉链表 一个数据域和两个指针域的链表叫做二叉链表。如果有需要，再增加一个指向其双亲的指针域，那样就叫做三叉链表。 遍历二叉树 二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，是的每个结点被访问一次且仅被访问一次。 前序遍历 若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */ PreOrderTraverse(T-&gt;lchild);/* 再先序遍历左子树 */ PreOrderTraverse(T-&gt;rchild);/* 最后先序遍历右子树 */&#125; 中序遍历 若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根结点，最后中序遍历右子树。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; PreOrderTraverse(T-&gt;lchild);/* 中序遍历左子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */ PreOrderTraverse(T-&gt;rchild);/* 最后中序遍历右子树 */&#125; 后序遍历 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; PreOrderTraverse(T-&gt;lchild);/* 先后序遍历左子树 */ PreOrderTraverse(T-&gt;rchild);/* 再后序遍历右子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */&#125; 层序遍历 若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下，从左到右依次访问。 总结：前中后序遍历最根本的区别是根节点在排序中的位置。如前序遍历根结点在头部。 线索二叉树 我们把一种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。 线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点，查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。(其线索化的过程就是在遍历的过程中修改空指针的过程) 位置区分结点的 lchild 和 rchild 指向的是前驱或后驱还是左孩子或右孩子，需要在每个结点再增设两个标志域 ltag 和 rtag(其只是存放 0 和 1 数字的布尔型变量)。总结其结点结构如下 lchild ltag data rtag rchild ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。rtag 同理。 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择 赫夫曼树及其应用 从树种一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度就是从树根到每一结点的路径长度之和。带权路径长度 WPL 最小的二叉树称做赫夫曼树也叫最优二叉树。 赫夫曼编码 一般的，设需要编码的字符集为{d~1~,d~2~,d~3~,…d~n~}, 各个字符在电文中出现的次数或频率集合为{w~1~,w~2~,w~3~,….w~n~}，以 d~1~,d~2~,…,d~n~ 作为叶子结点，以 w~1~,w~2~,w~3~,….w~n~ 最为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的做分支代表 0，有分支代表 1，则从根节点到叶子结点所经过的路径分支组成 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。 （若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码）]]></content>
      <categories>
        <category>数据结构 算法</category>
      </categories>
      <tags>
        <tag>数据结构  算法复杂度 线性表 链表 队列 二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构（二）]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[图 图的基本概念 图：是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E), 其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 顶点：线性表中的数据元素叫元素，树种的数据元素叫结点，图中的数据元素叫做顶点。 根据顶点到顶点之间的方向性分为无向图和有向图。 无向图：G~1~=(V~1~,{E~1~}) 无向边 V~1~={A,B,C,D}; 边集合 E~1~={(A,B),(B,C),(C,D),(D,A),(A,C)} 有向图：G~2~=(V~2~,{E~2~}) 有向边 V~2~={A,B,C,D}; 弧集合 E~2~={,,,} 简单图：在图中，若不存在顶点到其自身的边，且同一条边不重复出现。 无向完全图：在无向图中，任意两个顶点之间都存在边。 有向完全图：在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。 网：图的边或弧相关的数叫做权，带权的图通常称为网。 回路或环：第一个顶点到最后一个顶点相同的路径。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。 连通图：在无向图 G 中，对于图中任意两个顶点 v~i~,v~j~ 包含于 E，v~i~ 和 v~j~ 都是连通（从顶点 v~i~ 到顶点 v~j~ 有路径）的，则称 G 是连通图。 连通分量：无向图中的极大连通子图称为连通分量。连通子图含有极大顶点数，且包含依附于这些顶点的所有边。（一个图中可以有多个连通分量） 强连通图：在有向图 G 中，如对于每一对 v~i~,v~j~ 包含于 V，且 v~i~≠v~j~，从 v~i~ 到 v~j~ 和从 v~j~,v~i~ 都存在路径，则称 G 为强连通图。 强连通分量：有向图中的极大强连通子图称做有向图的强连通分量。 连通图的生成树：其是一个极小的连通子图。它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。如果一个图中有 n 个顶点和 小于 n-1 条边，则是非连通图，如果它多于 n-1 条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。 有向树：如果一个有向图掐有一个顶点的入度为 0，其余顶点的入度均为 1，则是一棵有向树。 图的抽象数据类型 图的存储结构 邻接矩阵 图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 邻接表 数组与链表相结合的方法称为邻接表。 有向图的逆邻接表：即对每个顶点 v~1~ 都建立一个链接为 v~1~ 为弧头的表。 邻接表和逆邻接表结合起来就很容易判断某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现。 十字链表 十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样更容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。 邻接多重表 边表结点结构如下 ivex ilink jvex jlink 其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标。ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构。 边集数组 边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。 它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。 图的遍历 从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。 深度优先遍历（DFS）它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径想通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止。(类似于树的前序遍历) 对无向图来说，邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量 O(n+e). 对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。 广度优先遍历（BFS）类似于树的层序遍历。 最小生成树 构造连通网的最小代价生成树称为最小生成树。 普里姆（Prim）算法 定义：假设 N = （P，{E}）是连通网，TE 是 N 上最小生成树中边的集合。算法从 U={u~0~}(u~0~∈V)，TE={}开始。重复执行下述操作：在所有 u∈U，v∈V-U 的边（u，v）∈E 中找一条代价最小的边（u~0~，v~0~）并入结合 TE，同时 v~0~ 并入 U，直至 U=V 为止。此时 TE 中必有 n-1 条边，则 T=（V，{TE}）为 N 的最小生成树。 克鲁斯卡尔（Kruskal）算法 定义：假设 N=（V，{E}）是连通网，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图 T={V，{}}，图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到 T 中，否则舍弃此边选择下一条代价最小的边。依次类推，直至 T 中所有顶点都在同一连通分量上为止。 对比而言，Kruskal 算法主要针对边来展开，边数少时效率会更非常高，所以对于稀疏图有很大的优势。而 Prim 算法对于稠密图，对于边数非常多的图效率更高。 最短路径 对于网图的最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。 迪杰斯特拉（Dijkstra）算法 按路径长度递增的次序产生最短路径的算法。（略 PHP 补充）。 弗洛伊德（Floyd）算法 一个二重循环初始化加一个三重循环权值修正。 拓扑排序AOV 网：在一个表示工程的有向图中，用顶点表示活动，用弧表示活动之间的优先关系，这样的有向图为顶点表示活动的网，我们成为 AOV 网。 拓扑排序：设 G=(V,E)是一个具有 n 个顶点的有向图，V 中的顶点序列 v~1~,v~2~,….,v~n~, 满足若从顶点 v~i~ 到 v~j~ 有一条路径，且在顶点序列中顶点 v~i~ 必在顶点 v~j~ 之前。我们称这样的顶点序列为一个拓扑序列。 拓扑排序：对一个有向图构造拓扑序列的过程。 拓扑排序算法 对 AOV 网进行拓扑排序的基本思路是：从 AOV 网中选择一个入度为 0 的顶点输出，然后删去此顶点，并删除以此顶点为尾的弧，继续重复此步骤 ，直到输出全部顶点或者 AOV 网中不存在入度为 0 的顶点为止。 关键路径AOE 网：在一个表示工程的带权有向图中，用顶点表示事件，用有向边表示活动，用边上的权值表示活动的持续事件，这种有向图的边表示活动的网，我们称之为 AOE 网。 路径长度：路径上各个活动所持续的时间之和。 关键路径：从源点到汇点具有最大长度的路径。 关键活动：在关键路径上的活动。 算法略； 总结回顾​ 图的存储结构 ​ 邻接矩阵 邻接表 边集数组 ​ 十字链表 邻接多重表 查找 查找表：由同一类型的数据元素构成的集合。 关键字：数据元素中某个数据项的值。又称为键值。 主关键字：关键字可以唯一地标识一个记录，则称此关键字为主关键字。主关键字所在的数据项称为主关键码。其他情况称为次关键字。 查找：根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素。 查找表按照操作方式分为两大种： 静态查找表：只作查找操作的查找表。 ​ 查询某个特定的数据元素是否在查找表中。 ​ 检索某个特定的数据元素和各种属性。 动态查找表：在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。 ​ 查找时插入数据元素 ​ 查找时删除数据元素 查找结构：面向查找操作的数据结构称为查找结构。 顺序表查找 顺序查找又叫线性查找，是最基本的查找技术，查找过程：从头到尾逐个遍历查找。 有序表查找 折半查找（二分查找）二分查找的前提是线性表中的记录必须是关键码有序（通常从小到大有序），线性表必须采用顺序存储。 插值查找 根据要查找的关键字 key 与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式。（比较适合表长较大，而关键字分布又比较均匀的查找表。） 斐波那契查找 利用黄金分割的原理来实现。 折半查找：mid = (low+high)/2 插值查找：mid = low +(high-low)*(key-a[low])/(a[high]-a[low]) 斐波那契查找：mid = low + F[k-1]-1 三种有序表的查找本质上是分隔点的选择不同。 线性索引查找 索引：就是把一个关键字与它对应的记录相关联的过程。 线性索引：就是将索引项集合组织为线性结构，也称为索引表。 稠密索引 是指在线性索引中，将数据集中的每个记录对应一个索引项。 而对于稠密索引表来说，索引项一定是按照关键码有序的排列。 分块索引 把数据集的记录分成若干块，并且这些块需要满足两个条件： 块内无序：即每一块内的记录不要求有序。 块间有序：例如，要求第二块所有记录的关键字均要大于第一块中所有记录的关键字等等。块间有序是，才有可能在查找时带来效率。 分块索引：对于分块有序的数据集，将每块对应一个索引项，这种索引方法叫做分块索引。 分块索引的索引项结构分三个数据项： 最大关键码：它存储每一块中的最大关键字，这样的好处是可以使得在它之后的下一块中的最小关键字也能比这一块最大的关键字大。 存储了块中记录个数，以便于循环时使用。 用于指向块首数据元素的指针，便于开始对这一块中记录进行遍历。 分块索引在兼顾了对细分快不需要有序的情况下，大大增加了整体查找的速度，所以普遍被用于数据库表查找等技术的应用当中。 倒排索引 下面表格显示了每个不同的单词分别出现在哪篇文章中。 英文单词 文章编号 a 2 and 1 be 1 book 12 …… …….. 在这里这张单词表就是索引表，索引项的通用结构是： 次关键码，如上面的英文单词。 记录号表，如上面的文章编号。 其中记录号表存储具有相同次关键字的所有记录的记录号（可以是指向记录的指针或者是该记录的主关键字）。这样的索引方法就是倒排索引。 二叉排序树 二叉排序树：又称作二叉查找树。它或者是一棵空树，或者是具有下列性质的二叉树。（便于查找，插入，删除） 若它的左子树不为空，则左子树上所有结点的值均小于它的根结构的值。 若它的右子树不为空，则右子树上所有结点的值均大于它的根结点的值。 它的左右子树也分别为二叉排序树 二叉排序树是以链接的方式存储，保持了链接存储结构在执行插入和删除操作时不用移动元素的优点，只要找到合适的插入和删除位置后，仅需修改链接指针即可。 平衡二叉树（AVL 树）平衡二叉树是一种二叉排序树，其中每一个节点的左子树和右子树的高度差至多等于 1. 二叉树上结点的左子树深度减去右子树深度的值称为平衡因子 BF（值只能是 -1，0，1）。 最小不平衡子树：距离插入结点最近的，且平衡因子的绝对值大于 1 的结点为根的子树，我们称为最小不平衡子树。 平衡二叉树比二叉排序树查找的效率高。此时的查找时间复杂度为 O(logn), 而插入和删除也为 O(logn)。 多路查找树 (B 树) 多路查找树：其每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素。由于它是查找树，所有元素之间存在某种特定的排序关系。 2-3 树2-3 树：其中的每一个结点都具有两个孩子（我们称它为 2 结点）或三个孩子（我们称它为 3 结点）。 一个 2 结点包含一个元素和两个孩子(或没有孩子)，且与二叉排序树类似。与二叉排序树不同的是，这个 2 结点要么没有孩子，要有就有两个，不能只有一个孩子。 一个 3 结点包含一小一大两个元素和三个孩子(或没有孩子)。一个 3 结点要么没有孩子，要么具有 3 个孩子。如果某个 3 结点有孩子的话，左子树包含小于较小元素的元素，右子树包含大于较大元素的元素，中间子树包含介于两元素之间的元素。 2-3-4 树2-3-4 树：其实就是 2-3 树的概念扩展，包括了 4 结点的使用。一个 4 结点包含小中大三个元素和四个孩子（或没有孩子），一个 4 结点要么没有孩子，要么具有 4 个孩子。 B 树B 树：一种平衡的多路查找树。2-3 树和 2-3-4 树都是 B 树的特例。结点最大的孩子数目称为 B 树的阶。 其中 K 为关键字，A 为指向子树根结点的指针。 在 B 树上查找的过程是一个顺指针查找结点和在结点中查找关键字的交叉过程。 对于一个 n 个关键字的 m 阶 B 树查找时， 从根结点到关键字结点的路径上涉及的结点数不超过 log~[m/2]~(n+1/2)+1. B+ 树 在 B 树中，每一个元素在该树中只出现一次，有可能在叶子结点上，也有可能在分支结点上。而在 B+ 树中，出现在分支结点中的元素会被当做它们在该分支结点位置的中序后继者 (叶子结点) 中再次列出。另外每一个叶子结点都会保存一个指向后一叶子结点的指针。 一棵 m 阶的 B+ 树和 m 阶的 B 树的差异在于： 有 n 棵子树的结点中包含有 n 个关键字 所有的叶子结点包含全部关键字的信息，及指向含这些关键字记录的指针，叶子结点本身依关键字的大小自小到大顺序链接。 所有分支结点可以看成是索引，结点中仅含有其子树中的最大 (或最小) 关键字。 B+ 树的结构特别适合带有范围的查找。 散列表查找 (哈希表) 概述 散列技术：是在记录的存储位置和它的关键字之间建立一个确定的对应关系 f，是的每个关键字 key 对应一个存储位置 f(key)。我们把这种对应关系 f 称为散列函数，又称为哈希 (Hash) 函数。按照这个思想，采用散列技术将记录存储在一块连续的存储空间中，这块连续存储空间称为散列表或哈希表。其中关键字对应的记录存储位置我们称为散列地址。 散列主要是面向查找的存储结构。散列技术最适合的求解问题是查找与给定值相等的记录。 冲突：当我们碰到两个关键字 key1 ≠ key2，但是却有 f(key1) = f(key2), 这种现象我们称为冲突，并把 key1 和 key2 称为这个散列函数的同义词。 散列函数的构造方法 直接定址法 取关键字的某个线性函数值为散列地址即 f(key) = a x key + b (a,b 为常数) 简单，均匀，不会产生冲突。但需事先知道关键字的分布情况，适合查找表较小且连续的情况。 数字分析法 通过分析使用抽取方法，使用要计算的关键字的一部分来计算散列存储位置的方法。 数字分析法通常适合处理关键字位数比较大的情况。如事先知道关键字的分布且关键字的若干位分布较均匀，就可以考虑用这个方法。 平方区中法 假设关键字为 1234，那它的平方就是 1522756，在抽取中间的 3 位就是 227 用做散列地址。平方取中法比较适合于不知道关键字的分布，而位数又不是很大的情况。 折叠法 是将关键字从左到右分割成位数相等的几部分，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。 事先不需知道关键字的分布，适合关键字位数较多的情况。 除留余数法 对于散列表长为 m 的散列函数公式为： f(key) = key mod p (p≤m) mod 是取模 (求余数) 的意思。这种方法不仅可以对关键字直接取模，也可在折叠，平方取中后再取模。 本方法的关键在于选择合适的 p，p 如果选的不好，就可能容易产生同义词。 根据前辈们的经验，若散列表表长为 m，通常 p 为小于或等于表长 (最好接近 m) 的最小质数或不包含小于 20 质因子 [待查] 的合数。 随机数法 f(key) = random(key) 当关键字的长度不等时，采用这个方法构造散列函数是比较合适的。 处理散列冲突的方法 开放定址法(线性探测法) 就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。 f~i~ (key) = (f(key) + d~i~) MOD m (d~i~=1,2,3,….,m-1) 堆积：对于本来不是同义词却需要争夺一个地址的情况，我们称这种现象为堆积。 二次探测法 f~i~ (key) = (f(key) + d~i~) MOD m (d~i~=1^2^,-1^2^,2^2^,-2^2^,…,q^2^,-q^2^,q≤m/2) 增加平方运算的目的是为了不让关键字都聚集在某一块区域。 随机探测法 在冲突时，对于位移量 d~i~ 采用随机函数计算得到，我们称之为随机探测法。 f~i~ (key) = (f(key) + d~i~) MOD m (d~i~ 是一个随机数) 再散列函数法 f~i~(key) = RH~i~(key) (i = 1,2,..,k) 其中的 RH~i~ 就是不同的散列函数，可以把之前说的除留余数，折叠，平方取中全部用上。这种方法能够使得关键字不产生聚集，当相应地也增加了计算的时间。 链地址法 是将所有关键字为同义词的记录存储在一个单链表中，我们称这种表为同义词子表，在散列表中只存储所有同义词子表的头指针。 对关键字集合{12,67,56,16,25,37,22,29,15,47,48,34}, 用前面同样的 12 为除数，进行除留余数法。得到下图。 这样会带来查找时需要遍历单链表的性能损耗。 公共溢出区法 为所有冲突的关键字建立一个公共的溢出区来存放。]]></content>
      <categories>
        <category>数据结构 算法</category>
      </categories>
      <tags>
        <tag>图表 路径算法 树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数据安全]]></title>
    <url>%2F2017%2F08%2F29%2FPHP%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[三种 PHP 数据安全防范示例 常见的转义 html 例如一个用户的表单输入获取 $a = $_GET[&#39;username&#39;] 其中的 username 值可能是一样有恶意的 JS 脚本可能造成不必要的麻烦。 解决办法 ·$a = htmlspecialchars($_GET[&#39;username&#39;],ENT_QUOTES); htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; > （大于）成为 &gt; 提示：如需把特殊的 HTML 实体转换回字符，请使用 htmlspecialchars_decode() 函数。 防止 SQL 注入 有两种方法 第一种是 php.ini 中的 magic_quotes_gpc 设置为 on. magic_quotes_gpc 函数在 php 中的作用是判断解析用户提示的数据，如包括有:post、get、cookie 过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 注意 这个设置在 PHP6 中已经不可使用了，所以根据情况使用. 第二种就是使用 mysql_real_escape_string()函数. ​ 语法： ​ mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 ​ 把获取的变量进行函数处理. ​ $a = mysql_real_escape_string($user); 对引号做两次转意 这通常在开发者的环境中 magic_quotes 设置为 off，而在部署的服务器上 magic_quotes =on. PHP 会在 GET, POST 和 COOKIE 中的数据上重复运行 addslashes() 造成两次转义的现象。 原始文本： It’s a string magic quotes on : It\’s a string 又运行一次 addslashes(): It\‘s a string HTML 输出: It\’s a string ​]]></content>
      <categories>
        <category>PHP数据安全</category>
      </categories>
      <tags>
        <tag>数据安全 PHP 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (四)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[面向对象基础 类的定义: 类就是具有相同的属性和功能的对象的抽象的集合。构造方法: 只针对于 JAVA 实例化 :对类进行实例化，构造方法与类同名，无返回值，也不需要 void, 在 new 时候调用。 构造方法 :所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了。 方法重载 :方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型。 属性和修饰符 :属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。[属性的名称一般首字母大写，而字段则一般首字母小写或前加‘_’]。（字段和属性时不同的。属性是特殊的方法，可以给对应的字段赋值） 属性有两个方法 get 和 set。get 访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用。set 访问器没有显示设置参数，但它有一个隐式参数，用关键字 value 表示，它的作用是调用属性时可以给内部的字段或引用赋值。 封装 :每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。 继承 子类拥有父类非 private 的属性和功能。 子类具有自己的属性和功能。 子类还可以以自己的方式实现父类的功能（方法重写）。 子类构造方法需要调用父类同样参数类型的构造方法，用 base 关键字代表父类。（对于构造方法，其不能被继承，只能被调用） 继承显然是一种类与类之间的强耦合的关系。 多态 :多态表示不同的对象可以执行相同的动作。但要通过它们自己的实现代码来执行。 添加（virtual）关键字虚拟化父类的成员。子类可以选择使用（override）关键字，将父类实现替换为它自己的实现，这就是方法重写 Override, 或者叫做方法覆写。 原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。[AMNFP] 抽象类 : 抽象类不能实例化。 抽象方法是必须被子类重写的方法。（抽象方法可以被看作是没有实现体的虚方法） 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类[J&amp;DP] 接口 :接口是把隐式公共方法和属性结合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。 不能实例化。不能有构造方法和字段。不能有修饰符。不能声明虚拟的或静态的。 声明接口在语法上与声明抽象类完全不同，但不允许提供接口中任何成员的执行方式。 实现接口的类就必须要实现接口中的所有方法和属性。 接口的命名，前面要加一个大写字母’I’(规范) 抽象类和接口的区别 形态上来说​ 抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口。 设计模式上来说​ 1. 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，他们的共性就是抽象 ​ 2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。 ​ 3. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛华出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。 ​ 4.[抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的] 泛型 :泛型是具有占位符（类型参数）的类、接口、和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符：类型参数作为其字段的类型或其方法的参数类型出现[MSDN]。 不是太懂，来个例子，自己领会吧:sad: 以下文字概念反正我没太懂 通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基结合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱[MSDN]。 委托和事件 :委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程[PC#] 委托对象用关键字 delegate 来声明，而事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。事件用 event 关键字声明。 主要参考文献 [DP] 《设计模式：可复用面向对象软件的基础》 [DPE] 《设计模式解析》 [ASD] 《敏捷软件开发：原则、模式和实践》 [RIDEC] 《重构–改善既有代码的设计》 [J&amp;DP] 《Java 与模式》 [R2P] 《重构与模式》 [Head First Design Patterns] ​ 再次贴上百度云代码链接 相关代码]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (三)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[设计模式分组 一、创建型模式 抽象工厂模式 提供一个创建一系列或相关依赖对象的接口，而无需指定他们具体的类[DP] 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示[DP] 工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到子类[DP] 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP] 单例模式 保证一个类只有一个实例，并提供一个访问它的全局访问点[DP] 总结 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么，谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。[DP] 关于松耦合：内聚性和耦合性 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DP] 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定[DP] 通常设计应是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地[DP] ​ 二、 结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作[DP] 桥接模式 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 组合模式 将对象组合成树形结构以表示‘部分 - 整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性[DP] 装饰模式 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活[DP] 外观模式 为子系统中的一组接口提供一个一致 的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] 享元模式 为运用共享技术有效地支持大量细粒度的对象[DP] 代理模式 为其他对象提供一种代理以控制对这个对象的访问[DP] 总结 问题 : 信息的隐藏促进了软件的复用，如何理解这句话？ ​ 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。 代理模式与外观模式的区别 代理对象代表一个单一对象而外观对象代表一个子系统 代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口[R2P] 代理与适配器之间来说，代理模式是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个对象交涉。而适配器则不需要虚构出一个代表着，只需要为应付特定使用目的，将原来的类进行一些组合[DP]。 三、行为型模式 观察者模式 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 ​ 模板方法模式 定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP]。 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销操作[DP]。 状态模式 允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类[DP]。 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch 中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止[DP]。 四、 行为型模式第二组 解释器模式 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP]。 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[DP] 策略模式 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[DP] 备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态[DP]。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界[DP]。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。[DP] 五、 总结 工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂[DPE]。 面向对象设计模式体现的就是抽象的思想。 类是对对象的抽象 抽象类是对类的抽象 接口是对行为的抽象]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (二)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[十三 、状态模式 状态模式（State）, 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。（DP） 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 使用时机 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据它的状态改变它的行为时，就可以考虑使用状态模式了。 [此处应有（meiyou）代码(zi ji kan)] 十四 、 适配器模式 适配器模式（Adapter）, 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP] 类适配器模式 通过多重继承对一个接口与另一个接口进行匹配，但大部分语言不支持多重继承（C++ 支持） 对象适配器模式 对象适配器模式结构图 代码示例 十五 、 备忘录模式 备忘录（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可将该对象恢复到原先保存的状态[DP]。 [DP] 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来[DP]. 当角色的状态改变时，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 十六 、 组合模式 组合模式（Composite）: 将对象组合成树形结构以表示‘部分 - 整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。[DP] 》接口是一种约束 十七 、 迭代器模式 迭代器模式（Iterator）: 提供了一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。[DP] foreach 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据 十八 、 单例模式 单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。[DP] 通常我们可以用一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的办法。[DP] 十九、 桥接模式 继承的麻烦 对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新问题，则父类必须重写或被其他更换的类替换。这种依赖关系限制了灵活性并最终限制了复用性。[DP] 在面向对象设计中，我们有一个很重要的设计原则，那就是合成 / 聚合复用原则。即优先使用对象合成 / 聚合，而不是类继承。[DP] 合成 / 聚合复用原则(CARP): 尽量使用合成 / 聚合，尽量不要使用类继承。[J&amp;DP] 聚合表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分: 合成表示一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]（看图） 好处 优先使用对象的合成 / 聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。[DP] 桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 二十、 命令模式 命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化; 对请求进行排队或记录请求日志，以及支持可撤销的操作。[DP] 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记入日志 允许接受请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他的类，因此增加的新的具体命令类很容易。 命令模式把请求一个操作的对象与知道怎样执行一个操作的对象分隔开[DP] ​ 二十一、 责任链模式 责任链模式（Chain of Responsibility）: 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[DP] 职责连的好处 可简化对象的互相连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。[DP] 可随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性[DP] 二十二、 中介者模式 中介者模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 应用场景 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 二十三 、享元模式 享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象[DP] 优点 享元模式可以避免大量相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。[减少对象的实例化数量] 二十四、 解释器模式 解释器模式（Interpreter）: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP] 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题[DP] (正则表达式是它的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式) 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式[DP] 解释器模式可以很容易地改变或扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。其也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写[DP] 举个例子就是人工智能机器人，机器人把人的具体指令解释成相应的行为。 二十五、 访问者模式 访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它可以使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作[DP] 访问者模式应用 适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 访问者模式使得增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式通常都会使增加新的数据结构变化困难。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (一)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[标签（空格分隔）： 设计模式 大话 设计 &gt; 仅供参考 /(ㄒ o ㄒ)/~~ 相关的对应的代码会贴上百度云，是用 JAVA 写的。想看的可以下载（在文章末尾）。暂时只是一些个概念和大体结构，大部分（jihu）是没有代码的，理解起来肯定会比较难（或许根本理解不了），whatever , 只是个人读书笔记，比较粗糙，凑活看吧。哈哈。 一 、简单工厂模式 用一个单独的类来实现易修改和扩展创造实例的过程。 有图 ​ ​ UML 类图图示样例 ​ ​ ‘+’表示 public ‘-‘表示 private ‘#’表示 protected ​ 继承关系用空心三角形 + 实线来表示 如图 ​ ​ 接口关系用空心三角形 + 虚线表示 形如上图（略） ​ 关联关系用实线箭头表示 形如上图（略）、 ​ 聚合关系 ​ 聚合表示一种弱的’拥有‘关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 –《设计模式》第二版 用空心的菱形 + 实线箭头表示 ​ 这个有图哦:happy: ​ ​ 组合关系 ​ 一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 –《设计模式》 ​ 组合关系用实心的菱形 + 实线箭头来表示，连线两端的数字 1,2，被称为基数表明这一端的类可以有几个实例（n 表示无数）。 这个也是有图的 看图 ​ ​ 依赖关系 用虚线箭头表示 UML 最后一张图 ​ 二 、策略模式​ 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP] ​ 面向对象的编程, 并不是越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 ​ 策略模式结构图 ​ ​ 策略模式反思 策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合 –《设计模式》[DPE] ​ 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 –《设计模式》【DPE】 ​ 1. 单一职责原则(SRP)​ 就一个类而言，应该仅有一个引起它变化的原因。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏【ASD】。 ​ 2. 开放 - 封闭原则[简称 OCP]​ 是说软件实体（类，模块，函数等等），应该可以扩展，但是不可修改【ASD】 ​ 开放 - 封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要【ASD】 ​ 3. 依赖倒转原则​ 抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程） ​ 依赖倒转原则 ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。【ASD】 ​ 4. 里氏代换原则【LSP】​ 子类型必须能够替换掉他们的父类型。【ASD】 ​ 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 如图 ​ ​ （依赖倒转其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如） ​ 原则总结​ 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了【ASD】 ​ 三 、装饰模式​ 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活【DP】 ​ 如图装饰模式结构图 ​ ​ 装饰模式实例代码（感觉穿衣服的例子比较有意思，是 java 代码:sad:, 逻辑能看懂:sad:） ​ 后面有例子总结，不想看图的直接跳到后面看。 ​ ​ ​ ​ ​ ​ 小结 ​ 我理解的大概的过程是这样一个工程。就是先从最后的具体服饰类开始往上逐个 装饰 的走。从具体服饰类到服饰类再到 Person 类。（可以从结果显示中看到这一过程）。 ​ ​ ​ 总结 ​ 装饰模式是为已有功能动态地添加更多功能的一种方式，装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有条件地，按顺序地使用装饰功能包装对象了【DP】 ​ （优点：把类中的装饰功能从类中搬除去除，这样可以简化原有的类。这样做的更大的好处是有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。） ​ 四 、代理模式（Proxy）​ 为其他对象提供一种代理以控制对这个对象的访问。【DP】 ​ 代理模式结构图 ​ ​ 注释 ​ 大概的意思就是，有一个公共的接口。中间代理和实际实体两者都实现接口的方法。当具体操作的时候，用代理操作，在代理内部实现实际方法的实例化操作来间接的替代实际方法。 ​ 应用场合 ​ 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。这样就可以达到性能的最优化，比如打开一个很大的 HTML 页面，虽然有很多图片但是还是能很快的打开它，此时看到的是文字，图片是一张一张的下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。其实，浏览器当中是用代理模式来优化下载的。 安全代理，用来控制真实对象访问时的权限[DP]。一般用于对象应该有不同的访问权限的时候。 智能指引，是指当调用真实的对象时，代理处理另外一些事情[DP]。如计算真实对象的引用次数，当该对象没有引用时，可以自动释放它: 或当第一次引用一个持久对象时，将它装入内存: 或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 ​ 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ​ 五 、工厂方法模式​ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 ​ 工厂方法模式 ，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。[DP] ​ ​ 工厂方法模式具体实现示例图 ​ ​ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。 ​ ​ ​ 六 、原型模式​ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP]. ​ 原型模式结构图 ​ ​ 注释 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。 ​ 原型模式中一般在初始化的信息不发生变化的情况下，克隆时最好的办法。这即隐藏了对象创建的细节，又对性能是大大的提高。同样也不用重新初始化对象，而是动态地获得对象运行时的状态。 ​ ‘浅复制’: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 ‘深复制’: 深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ​ 声明：这一模式，本人看的不是太懂。感觉有些东西不通。下面会有一个详细的例子，可以参考一下。不解释。 ​ 简历的深复制实现 ​ ​ ​ ​ ​ ​ 七 、模板方法模式​ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板模式方法处理。 ​ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP] ​ ​ 模板方法模式特点 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现其优势。 提供了一个很好的代码复用平台 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。 ​ 八、迪米特法则​ 迪米特法则（LoD）/ 最少知识原则[J&amp;DP]: 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。[J&amp;DP] ​ 九 、外观模式​ 外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] ​ ​ 十 、 建造者模式​ 建造者模式（Builder）: 将一个复杂对象的建造与它的表示分离，使得同样的建造过程可以创建不同的表示[DP] ​ 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ ​ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。 ​ 十一 、观察者模式​ 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己[DP]。 ​ ​ 观察者模式特点​ 当一个对象的改变需要同时改变其他对象时而且它并不知道具体有多少对象有待改变时，应该考虑使用观察中模式。 ​ 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将两者封装在独立的对象中使他们各自独立的改变和复用。 ​ 委托[这段有点突兀，我理解的大概意思是把观察者也抽象了，直接委托具体的类去实现观察类的抽象。] ​ 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 ​ 十二、抽象工厂模式​ 抽象工厂模式（Abstract Factory）, 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。[DP] ​ ​ 百度云链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 安全]]></title>
    <url>%2F2017%2F08%2F26%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[根本原则：数据与代码分离 同源策略1. 当 JS 被浏览器认为来自不同源是，请求被拒绝。2. 影响同源策略的因素 host(域名，IP 地址，子域名，端口和协议)。3.EXCEPT：script . img .iframe . link 标签可跨区加载资源而不受同源策略的影响。（原因是都带着 src 属性） 攻击手段类型 1. XSS 跨站脚本攻击 总的来说就是引用上面描述的不受同源策略影响的标签引入不合法的代码来进行攻击主要有四种 反射型 XSS 存储型 XSS DOM Based XSS XSS Payload Cookie 劫持攻击等 2. CSRF Cross Site Request Forgery 跨站点请求伪造 风险在于那些通过基于受信任的输入 form 和对特定行为无需授权的已认证的用户来执行某些行为的 web 应用。已经通过被保存在用户浏览器中的 cookie 进行认证的用户将在完全无知的情况下发送 HTTP 请求到那个信任他的站点，进而进行用户不愿做的行为。使用图片的 CSRF 攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用 JavaScript。 –百度百科 3.Click Jacking 点击劫持 点击劫持，clickjacking，也被称为 UI- 覆盖攻击。这个词首次出现在 2008 年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了 HTML 中 iframe 标签的透明属性。 4.SQL 注入 盲注（Blind Injection） 攻击存储过程 编码问题 Session 劫持 如果 SessionID 是保存在 cookie 中的，则这种攻击称为 cookie 劫持 Session Fixation（固定） 攻击：在用户登录网站的过程中，如果登陆前后用户的 sessionID 没有发生变化，则会存在 session fixation 问题 预防 SQL 注入的方式1. 使用预编译语句，绑定变量2. 使用存储过程3. 检查数据类型4. 使用安全函数 5.OAuth（单纯的名词解释）OAuth 是一个在不提供用户名密码的情况下授权第三方应用访问 web 资源的安全协议。 6. 绕过文件上传检查功能 1230x00 被认为是终止符[\0] 为十六进制的 0x00 字符 会利用上述特性截端字符串为脚本语言。 设计安全的文件上传功能1. 文件上传的目录设置为不可执行2. 判断文件类型3. 使用随机数改写文件名和文件路径4. 单独设置文件服务器的域名 在加密算法的选择和使用上 有一些建议1，不要使用 ECB 模式。2，不要使用流密码比如 RC4.3，使用 HMAC-SHAI 代替 MD5(甚至是 SHAI).4, 不要使用相同的 key 做不同的事情。5，salts 与 IV 需要随机产生。6，不要自己实现加密算法，尽量使用安全专家已经实现好的库7，不要依赖系统的保密性。 当不知道如何选择时1，使用 CBC 模式的 AES256 用于加密。2. 使用 HMAC-SHA512 用于完整性检查。3，使用带 salt 的 SHA-256 或 SHA-512 用于 Hashing. 7.DDOS 分布式拒绝服务 Distributed Denial of Service 最主要的便是限制请求频率，比如无限占用 http 请求，缓慢多次发送 http 请求。 Slowloris 攻击 1 以极低的速度往服务器发送 HTTP 请求，在正常的 HPPT 包头中，是以两个 CLRF（\r\n\r\n）表示 HTTP Headers 部分结束的。 HTTP POST DOS1在发送 HTTP POST 包是，指定一个非常大的 Content-Length 值，然后以很低的速度发包，比如 10~100s 发一个字节，保持住这个链接不断开。 Server Limit Dos1（Apache 所能接受的最大 HTTP 包头大小为 8192 字节（request header） request body 默认最大限制为 2GB）超过指定大小服务器会返回一个 4xx 错误。 正则 ReDOS1一种代码实现上的缺陷，正则表达式写的不好，有可能被恶意输入利用，消耗大量资源，从而造成 DOS。 小结 1 应用层拒绝服务攻击是传统的网络拒绝服务攻击的一种选择，本质也是对有限资源的无限滥用所造成的，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。 8. PHP 安全 文件包含漏洞 常见的导致文件包含的函数如下：PHP：include,require,fopen(),readfile();(PHP 内核并不会在意被包含的文件是什么类型)要想成功利用文件包含漏洞，需要满足下面两个条件： include()等函数通过动态变量的方式引入需要包含的文件。 用户能够控制该动态变量。 本地文件包含（LFI）能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞。PHP 配置设置 open_basedir 的作用是限制在某个特定目录下 PHP 能打开的文件，其作用与 safe_mode 是否开启无关。 远程文件包含PHP 的配置选项 allow_url_include 为 ON 的话，则 inlude/require 函数是可以远程加载文件的（RFI）。 PHP 会为上传文件创建临时文件，其目录在 php.ini 的 upload_tmp_dir 中定义，但改值默认为空，此时在 Linux 下回使用 /tmp 目录，在 Windows 下会使用 C:\windows\temp 目录。 变量覆盖漏洞 全局变量覆盖register_globals PHP 配置文件 unset()默认只会销毁局部变量，而要销毁全局变量必须使用 $GLOBALS; extract()变量覆盖 extract() 函数能将变量从数组导入当前的符号表。 遍历初始化变量 常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖（按下不表）。 import_request_variables 变量覆盖 次函数将 GET,POST,Cookie 中的变量导入到全局。 parse_str()变量覆盖 parse_str() 函数往往被用于解析 URL 的 query string.eg. 123$var = &apos;init&apos;;parse_str($_SERVER[&apos;QUERY_STRING&apos;]);print $var; 防止变量覆盖的安全建议 确保 register_globals = OFF, 若不能自定义 php.ini, 则应该在代码中控制。 熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。 养成初始换变量的好习惯。 代码执行漏洞 phpMyAdmin3.4.3.1 远程代码执行漏洞 MyBB 1.4 远程代码执行漏洞 挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用过程中用户是否有可能控制输入。 “文件写入”执行代码 其他执行代码方式 直接执行代码函数 eval(),assert(),exec(),shell_exec() 文件包含 本地文件写入 preg_replace()代码执行 preg_replace() 的第一个参数如果存在 /e 模式修饰符，则许代码执行。 动态函数执行 Curly Syntax {}将执行花括号间的代码，并将结果替换回去。 回调函数执行代码 unserialize()将导致代码执行 能将序列化的数据重新映射为 PHP 变量。 定制安全的 PHP 环境 register_globals = ON. open_basedir = /home/web/html/(指定目录) allow_url_include = offallow_url_fopen = off. display_errors = off log_errors = on magic_quotes_gpc = OFF. cgi.fix_pathinfo = 0(如果 PHP 以 CGI 的方式安装，则需要关闭此项，以避免出现文件解析问题) session.cookie_httponly = 1 session.cookie_secure = 1. sefe_mode disable_functions 能够在 PHP 中禁用函数disable_functions = eg… 10. WEB SERVER 配置安全 主要有五个方面（详略）1.apache 安全 2.nginx 安全3.jBoss 远程命令执行4.Tomcat 远程命令执行5.HTTP Parameter Pollution(通过 GET 或 POST 向服务器发起请求时，提交两个相同的参数) 入侵检测 常见的安全监控产品有 IDS(入侵检测系统)，IPS(入侵防御系统)，DDOS 监控设备。WAF(web 应用防火墙) ModSecurity:Apache 的一个 Module. 他能获取到所有的访问 Apache Httpd Server 的请求，并根据自己的规则对这些请求进行匹配，以检测那些请求存在攻击行为。 1声明：纯手打总结，劳动不易，转载请附上原文链接。谢谢支持]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>web 安全 协议 HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 配置文件详解（php.ini 详解 )]]></title>
    <url>%2F2017%2F08%2F26%2FPHP-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%88php.ini-%E8%AF%A6%E8%A7%A3-)%2F</url>
    <content type="text"><![CDATA[[PHP]; PHP 还是一个不断发展的工具，其功能还在不断地删减; 而 php.ini 的设置更改可以反映出相当的变化，; 在使用新的 PHP 版本前，研究一下 php.ini 会有好处的;;;;;;;;;;;;;;;;;;;; 关于这个文件 ;;;;;;;;;;;;;;;;;;;; ; 这个文件控制了 PHP 许多方面的观点。为了让 PHP 读取这个文件，它必须被命名为; ‘php.ini’。PHP 将在这些地方依次查找该文件：当前工作目录；环境变量 PHPRC; 指明的路径；编译时指定的路径。; 在 windows 下，编译时的路径是 Windows 安装目录。; 在命令行模式下，php.ini 的查找路径可以用 -c 参数替代。 ; 该文件的语法非常简单。空白字符和用分号’;’开始的行被简单地忽略（就象你可能 ; 猜到的一样）。 章节标题（例如 : [Foo]）也被简单地忽略，即使将来它们可能; 有某种的意义。;; 指示被指定使用如下语法：; 指示标识符 = 值; directive = value; 指示标识符 是 大小写敏感的 - foo=bar 不同于 FOO = bar。;; 值可以是一个字符串，一个数字，一个 PHP 常量 (如： E_ALL or M_PI), INI 常量中的; 一个 (On, Off, True, False, Yes, No and None) ，或是一个表达式; (如: E_ALL &amp; ~E_NOTICE), 或是用引号括起来的字符串(“ foo”).;; INI 文件的表达式被限制于位运算符和括号。; | bitwise OR; &amp; bitwise AND; ~ bitwise NOT; ! boolean NOT;; 布尔标志可用 1, On, True or Yes 这些值置于开的状态。; 它们可用 0, Off, False or No 这些值置于关的状态。;; 一个空字符串可以用在等号后不写任何东西表示，或者用 None 关键字:;; foo = ; 将 foo 置为空字符串; foo = none ; 将 foo 置为空字符串; foo = “ none” ; 将 foo 置为字符串’none’;; 如果你值设置中使用常量，而这些常量属于动态调入的扩展库（不是 PHP 的扩展，就是; Zend 的扩展），你仅可以调入这些扩展的行 之后 使用这些常量。;; 所有在 php.ini-dist 文件里设定的值与内建的默认值相同（这是说，如果 php.ini; 没被使用或者你删掉了这些行，默认值与之相同）。 ;;;;;;;;;;;;;;;;;;;;; 语言选项 ;;;;;;;;;;;;;;;;;;;;; engine = On; 使 PHP scripting language engine（PHP 脚本语言引擎）在 Apache 下有效。short_open_tag = On; 允许 tags 将被识别。asp_tags = Off; 允许 ASP-style tagsprecision = 14; 浮点类型数显示时的有效位数 y2k_compliance = Off; 是否打开 2000 年适应 (可能在非 Y2K 适应的浏览器中导致问题) output_buffering = Off; 输出缓存允许你甚至在输出正文内容之后发送 header（标头，包括 cookies）行; 其代价是输出层减慢一点点速度。你可以使用输出缓存在运行时打开输出缓存，; 或者在这里将指示设为 On 而使得所有文件的输出缓存打开。output_handler = ; 你可以重定向你的脚本的所有输出到一个函数，; 那样做可能对处理或以日志记录它有用。; 例如若你将这个 output_handler 设为” ob_gzhandler” ,; 则输出会被透明地为支持 gzip 或 deflate 编码的浏览器压缩。; 设一个输出处理器自动地打开输出缓冲。 implicit_flush = Off; 强制 flush（刷新）让 PHP 告诉输出层在每个输出块之后自动刷新自身数据。; 这等效于在每个 print() 或 echo() 调用和每个 HTML 块后调用 flush()函数。; 打开这项设置会导致严重的运行时冲突，建议仅在 debug 过程中打开。 allow_call_time_pass_reference = On; 是否让强迫函数调用时按引用传递参数。这一方法遭到抗议，; 并可能在将来版本的 PHP/Zend 里不再支持。; 受到鼓励的指定哪些参数按引用传递的方法是在函数声明里。; 你被鼓励尝试关闭这一选项并确认你的脚本仍能正常工作，以保证在将来版本的语言里; 它们仍能工作。（你将在每次使用该特点时得到一个警告，而参数将按值而不是按引用; 传递）。 ; Safe Mode 安全模式safe_mode = Offsafe_mode_exec_dir =safe_mode_allowed_envvars = PHP; ？Setting certain environment variables; ？may be a potential security breach.; 该指示包含用逗号分隔的前缀列表。安全模式中，用户仅可以替换; 以在此列出的前缀开头的环境变量的值。; 默认地，用户将仅能 设定以 PHP_开头的环境变量，（如: PHP_FOO=BAR）。; 注意: 如果这一指示为空，PHP 将让用户更改任意环境变量! safe_mode_protected_env_vars = LD_LIBRARY_PATH; 这条指示包含一个用逗号分隔的环境变量列表，那是最终用户将不能用 putenv () 更改的。; 这些变量甚至在 safe_mode_allowed_env_vars 设置为允许的情况下得到保护。 disable_functions =; 这条指示让你可以为了安全的原因让特定函数失效。; 它接受一个用逗号分隔的函数名列表。; 这条指示 不受 安全模式是否打开的影响。 ; 语法高亮模式的色彩。; 只要能被接受的东西就能工作。 highlight.string = #DD0000highlight.comment = #FF8000highlight.keyword = #007700highlight.bg = #FFFFFFhighlight.default = #0000BBhighlight.html = #000000 ; Misc 杂项expose_php = Off; 决定 PHP 是否标示它装在服务器上的事实（例如：加在它 — PHP— 给 Web 服务; 发送的信号上）。; （我个人的意见，在出现什么 power-by 的 header 的时候，把这关掉。）; 它不会有安全上的威胁, 但它使检查你的服务器上是否安装了 PHP 成为了可能。 ;;;;;;;;;;;;;;;;;;;; Resource Limits ;;;;;;;;;;;;;;;;;;;; max_execution_time = 30 ; 每个脚本的最大执行时间, 按秒计memory_limit = 8388608 ; 一个脚本最大可使用的内存总量 (这里是 8MB) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Error handling and logging ;; 出错控制和登记 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 错误报告是按位的。或者将数字加起来得到想要的错误报告等级。; E_ALL - 所有的错误和警告; E_ERROR - 致命性运行时错; E_WARNING - 运行时警告（非致命性错）; E_PARSE - 编译时解析错误; E_NOTICE - 运行时提醒(这些经常是是你的代码的 bug 引起的，; 也可能是有意的行为造成的。(如：基于未初始化的变量自动初始化为一个; 空字符串的事实而使用一个未初始化的变量) ; E_CORE_ERROR - 发生于 PHP 启动时初始化过程中的致命错误; E_CORE_WARNING - 发生于 PHP 启动时初始化过程中的警告(非致命性错); E_COMPILE_ERROR - 编译时致命性错; E_COMPILE_WARNING - 编译时警告(非致命性错); E_USER_ERROR - 用户产生的出错消息; E_USER_WARNING - 用户产生的警告消息; E_USER_NOTICE - 用户产生的提醒消息; 例子:; error_reporting = E_ALL &amp; ~E_NOTICE ; 显示所有的错误，除了提醒; error_reporting = E_COMPILE_ERROR|E_ERROR|E_CORE_ERROR ; 仅显示错误error_reporting = E_ALL &amp; ~E_NOTICE ; 显示所有的错误，除了提醒display_errors = On ; 显示出错误信息(作为输出的一部分); 在最终发布的 web 站点上，强烈建议你关掉这个特性，并使用; 错误日志代替（参看下面）。; 在最终发布的 web 站点继续让 display_errors 有效可能; 暴露一些有关安全的信息，例如你的 web 服务上的文件路径、; 你的数据库规划或别的信息。display_startup_errors = Off ; 甚至当 display_erroes 打开了，发生于 PHP 的启动的步骤中; 的错误也不会被显示。; 强烈建议保持使 display_startup_errors 关闭，; 除了在改错过程中。log_errors = Off ; 在日志文件里记录错误（服务器指定的日志，stderr 标准错误输出，或 error_log(下面的））; 正如上面说明的那样，强烈建议你在最终发布的 web 站点以日志记录错误; 取代直接错误输出。 track_errors = Off ; 保存最近一个 错误 / 警告 消息于变量 $php_errormsg (boolean);error_prepend_string = “ “ ; 于错误信息前输出的字符串;error_append_string = “ “ ; 于错误信息后输出的字符串;error_log = filename ; 记录错误日志于指定文件;error_log = syslog ; 记录错误日志于系统日志 syslog (NT 下的事件日志, Windows 95 下无效)warn_plus_overloading = Off ; 当将‘ +’ 用于字符串时警告 ;;;;;;;;;;;;;;;;;; Data Handling ;;;;;;;;;;;;;;;;;;variables_order = “ EGPCS” ; 这条指示描述了 PHP 记录; GET, POST, Cookie, Environment and Built-in 这些变量的顺序。; （以 G, P, C, E &amp; S 代表，通常以 EGPCS 或 GPC 的方式引用）。; 按从左到右记录，新值取代旧值。 register_globals = On ; 是否将这些 EGPCS 变量注册为全局变量。; 若你不想让用户数据不在全局范围内混乱的话，你可能想关闭它。; 这和 trackvars 连起来用更有意义 — 这样你可以通过; $HTTP*_VARS[] 数组访问所有的 GPC 变量。 register_argc_argv = On ; 这条指示告诉 PHP 是否声明 argv 和 argc 变量; （注：这里 argv 为数组,argc 为变量数）; （其中包含用 GET 方法传来的数据）。; 若你不想用这些变量，你应当关掉它以提高性能。 trackvars = On ; 使 $HTTP_VARS[]数组有效，这里 在使用时用; ENV, POST, GET, COOKIE or SERVER 替换post_max_size = 8M ; PHP 将接受的 POST 数据最大大小。 gpc_order = “ GPC” ; 这条指示被人反对。用 variables_order 代替。 ; Magic quotesmagic_quotes_gpc = On ; 在输入的 GET/POST/Cookie 数据里使用魔术引用 ; （原文就这样，呵呵，所谓 magic quotes 应该是指用转义符加在引用性的控制字符上，如 ‘….）magic_quotes_runtime= Off ; 对运行时产生的数据使用魔术引用，; 例如：用 SQL 查询得到的数据，用 exec() 函数得到的数据，等等magic_quotes_sybase = Off ; 采用 Sybase 形式的魔术引用（用 ‘’ 脱出 ‘ 而不用 ‘） ; 自动在 PHP 文档之前和之后添加文件auto_prepend_file =auto_append_file = ; 象 4.04b4 一样，PHP 默认地总是在 “ Content-type:” 头标输出一个字符的编码方式。; 让输出字符集失效，只要设置为空。; PHP 的内建默认值是 text/htmldefault_mimetype = “ text/html”;default_charset = “ iso-8859-1” ;;;;;;;;;;;;;;;;;;;;;;;;;; Paths and Directories ;;;;;;;;;;;;;;;;;;;;;;;;;;include_path = ; include 路径设置，UNIX: “ /path1:/path2” Windows: “ \path1;\path2”doc_root = ; php 页面的根路径，仅在非空时有效 user_dir = ; 告知 php 在使用 /~username 打开脚本时到哪个目录下去找，仅在非空时有效;upload_tmp_dir = ; 存放用 HTTP 协议上载的文件的临时目录（在没指定时使用系统默认的）upload_max_filesize = 2097152 ; 文件上载默认地限制为 2 Megextension_dir = c:\php\ ; 存放可加载的扩充库（模块）的目录enable_dl = On ; 是否使 dl() 有效。; 在多线程的服务器上 dl()函数 不能 很好地工作，; 例如 IIS or Zeus，并在其上默认为禁止 ;;;;;;;;;;;;;;;;; File Uploads ;;;;;;;;;;;;;;;;;file_uploads = On ; 是否允许 HTTP 方式文件上载;upload_tmp_dir = ; 用于 HTTP 上载的文件的临时目录（未指定则使用系统默认）upload_max_filesize = 2M ; 上载文件的最大许可大小 ; Fopen wrappers ;;;;;;;;;;;;;;;;;;;allow_url_fopen = On ; 是否允许把 URLs 当作 http:.. 或把文件当作 ftp:… ;;;;;;;;;;;;;;;;;;;;;;; 动态扩展 ;; Dynamic Extensions ;;;;;;;;;;;;;;;;;;;;;;;; 若你希望一个扩展库自动加载，用下面的语法：; extension=modulename.extension; 例如，在 windows 上，; extension=msql.dll; or 在 UNIX 下,; extension=msql.so; 注意，这只应当是模块的名字，不需要目录信息放在里面。; 用上面的 extension_dir 指示指定扩展库的位置。 ;Windows 扩展;extension=php_nsmail.dllextension=php_calendar.dll;extension=php_dbase.dll;extension=php_filepro.dllextension=php_gd.dll;extension=php_dbm.dll;extension=php_mssql.dll;extension=php_zlib.dll;extension=php_filepro.dll;extension=php_imap4r2.dll;extension=php_ldap.dll;extension=php_crypt.dll;extension=php_msql2.dll;extension=php_odbc.dll; 注意， MySQL 的支持现在是内建的，因此，不需要用它的 dll ;;;;;;;;;;;;;;;;;;;; 模块设定 ;; Module Settings ;;;;;;;;;;;;;;;;;;;; [Syslog]define_syslog_variables = Off ; 是否定义各种的系统日志变量; 如：$LOG_PID, $LOG_CRON, 等等。; 关掉它是个提高效率的好主意。; 运行时，你可以调用函数 define_syslog_variables()，来定义这些变量 [mail function]SMTP = localhost ; 仅用于 win32 系统sendmail_from = me@localhost.com ; 仅用于 win32 系统;sendmail_path = ; 仅用于 unix, 也可支持参数（默认的是’sendmail -t -i’） [Debugger]debugger.host = localhostdebugger.port = 7869debugger.enabled = False [Logging]; 这些配置指示用于示例的日志记录机制。; 看 examples/README.logging 以得到更多的解释;logging.method = db;logging.directory = /path/to/log/directory [Java];java.class.path = .\php_java.jar;java.home = c:\jdk;java.library = c:\jdk\jre\bin\hotspot\jvm.dll;java.library.path = .\ [SQL]sql.safe_mode = Off [ODBC];uodbc.default_db = Not yet implemented;uodbc.default_user = Not yet implemented;uodbc.default_pw = Not yet implementeduodbc.allow_persistent = On ; 允许或禁止 持久连接uodbc.check_persistent = On ; 在重用前检查连接是否还可用uodbc.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制uodbc.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制uodbc.defaultlrl = 4096 ; 控制 LONG 类型的字段。返回变量的字节数，0 代表通过（？）0 means passthruuodbc.defaultbinmode = 1 ; 控制 二进制数据。0 代表?????Handling of binary data. 0 means passthru, 1 return as is, 2 convert to char; 见有关 odbc_binmode 和 odbc_longreadlen 的文档以得到 uodbc.defaultlrl 和 uodbc.defaultbinmode 的解释。 [MySQL]mysql.allow_persistent = On ; 允许或禁止 持久连接mysql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制mysql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制mysql.default_port = ; mysql_connect() 使用的默认端口，如不设置，mysql_connect(); 将使用变量 $MYSQL_TCP_PORT，或在 /etc/services 下的 mysql-tcp 条目(unix)，; 或在编译是定义的 MYSQL_PORT(按这样的顺序); Win32 环境，将仅检查 MYSQL_PORT。mysql.default_socket = ; 用于本地 MySql 连接的默认的套接字名。为空，使用 MYSQL 内建值 mysql.default_host = ; mysql_connect() 默认使用的主机（安全模式下无效）mysql.default_user = ; mysql_connect() 默认使用的用户名（安全模式下无效）mysql.default_password = ; mysql_connect() 默认使用的密码（安全模式下无效）; 注意，在这个文件下保存密码通常是一个 坏主意 ; 任何 可以使用 PHP 访问的用户可以运行; ‘echo cfg_get_var(“ mysql.default_password”)’来显示那个密码!; 而且当然地，任何有读该文件权力的用户也能看到那个密码。 [mSQL]msql.allow_persistent = On ; 允许或禁止 持久连接msql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制msql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制 [PostgresSQL]pgsql.allow_persistent = On ; 允许或禁止 持久连接pgsql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制pgsql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制 [Sybase]sybase.allow_persistent = On ; 允许或禁止 持久连接sybase.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制sybase.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制;sybase.interface_file = “ /usr/sybase/interfaces”sybase.min_error_severity = 10 ; 显示的错误的最低严重性sybase.min_message_severity = 10 ; 显示的消息的最低重要性sybase.compatability_mode = Off ; 与旧版的 PHP 3.0 兼容的模式。若打开，这将导致 PHP 自动地; 把根据结果的 Sybase 类型赋予它们，; 而不是把它们全当成字符串。; 这个兼容模式不会永远留着，; 因此，将你的代码进行需要的修改，; 并将该项关闭。 [Sybase-CT]sybct.allow_persistent = On ; 允许或禁止 持久连接sybct.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制sybct.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制sybct.min_server_severity = 10 ; 显示的错误的最低严重性sybct.min_client_severity = 10 ; 显示的消息的最低重要性 [bcmath]bcmath.scale = 0 ; 用于所有 bcmath 函数的 10 十进制数数字的个数 number of decimal digits for all bcmath functions [browscap];browscap = extra/browscap.inibrowscap = C:\WIN\SYSTEM\inetsrv\browscap.ini[Informix]ifx.default_host = ; ifx_connect() 默认使用的主机（安全模式下无效）ifx.default_user = ; ifx_connect() 默认使用的用户名（安全模式下无效）ifx.default_password = ; ifx_connect() 默认使用的密码（安全模式下无效）ifx.allow_persistent = On ; 允许或禁止 持久连接ifx.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制ifx.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制ifx.textasvarchar = 0 ; 若打开，select 状态符返回一个 ‘ text blob’ 字段的内容，而不是它的 idifx.byteasvarchar = 0 ; 若打开，select 状态符返回一个 ‘ byte blob’ 字段的内容，而不是它的 idifx.charasvarchar = 0 ; 追踪从固定长度的字符列里剥离的空格。; 可能对 Informix SE 用户有效。ifx.blobinfile = 0 ; 若打开，text 和 byte blobs 的内容被导出到一个文件; 而不是保存到内存。ifx.nullformat = 0 ; NULL（空）被作为空字段返回，除非，这里被设为 1。; 这种情况下（为 1），NULL 作为字串 NULL 返回。 [Session]session.save_handler = files ; 用于保存 / 取回数据的控制方式session.save_path = C:\win\temp ; 在 save_handler 设为文件时传给控制器的参数，; 这是数据文件将保存的路径。session.use_cookies = 1 ; 是否使用 cookiessession.name = PHPSESSID; 用在 cookie 里的 session 的名字session.auto_start = 0 ; 在请求启动时初始化 sessionsession.cookie_lifetime = 0 ; 为按秒记的 cookie 的保存时间，; 或为 0 时，直到浏览器被重启session.cookie_path = / ; cookie 的有效路径session.cookie_domain = ; cookie 的有效域session.serialize_handler = php ; 用于连接数据的控制器; php 是 PHP 的标准控制器。session.gc_probability = 1 ; 按百分比的’garbage collection（碎片整理）’进程; 在每次 session 初始化的时候开始的可能性。session.gc_maxlifetime = 1440 ; 在这里数字所指的秒数后，保存的数据将被视为; ‘碎片(garbage)’并由 gc 进程清理掉。session.referer_check = ; 检查 HTTP 引用以使额外包含于 URLs 中的 ids 无效session.entropy_length = 0 ; 从文件中读取多少字节session.entropy_file = ; 指定这里建立 session id; session.entropy_length = 16; session.entropy_file = /dev/urandomsession.cache_limiter = nocache ; 设为{nocache,private,public}, 以决定 HTTP 的; 缓存问题session.cache_expire = 180 ; 文档在 n 分钟后过时session.use_trans_sid = 1 ; 使用过渡性的 sid 支持，若编译时许可了; –enable-trans-sidurl_rewriter.tags = “ a=href,area=href,frame=src,input=src,form=fakeentry” [MSSQL];extension=php_mssql.dllmssql.allow_persistent = On ; 允许或禁止 持久连接mssql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制mssql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制mssql.min_error_severity = 10 ; 显示的错误的最低严重性mssql.min_message_severity = 10 ; 显示的消息的最低重要性mssql.compatability_mode = Off ; 与旧版的 PHP 3.0 兼容的模式。 [Assertion]; ？？？？？;assert.active = On ; ？assert(expr); active by default;assert.warning = On ; issue a PHP warning for each failed assertion.;assert.bail = Off ; don’t bail out by default.;assert.callback = 0 ; user-function to be called if an assertion fails.;assert.quiet_eval = 0 ; eval the expression with current error_reporting(). set to trueif you want error_reporting(0) around the eval(). [Ingres II]ii.allow_persistent = On ; 允许或禁止 持久连接ii.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制ii.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制ii.default_database = ; 默认 database (format : [node_id::]dbname[/srv_class]ii.default_user = ; 默认 userii.default_password = ; 默认 password [Verisign Payflow Pro]pfpro.defaulthost = “ test.signio.com” ; 默认的 Signio 服务器pfpro.defaultport = 443 ; 连接的默认端口pfpro.defaulttimeout = 30 ; 按秒计的默认超时时间 ; pfpro.proxyaddress = ; 默认的代理的 IP 地址（如果需要）; pfpro.proxyport = ; 默认的代理的端口; pfpro.proxylogon = ; 默认的代理的登录（logon 用户名）; pfpro.proxypassword = ; 默认的代理的密码 [Sockets]sockets.use_system_read = On ; 使用系统的 read() 函数替代 php_read()封装; Local Variables: （局部变量）; tab-width: 4; End]]></content>
      <categories>
        <category>PHP转载</category>
      </categories>
      <tags>
        <tag>php.ini 转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php.ini 中 safe_mode 开启对 PHP 系统函数的影响]]></title>
    <url>%2F2017%2F08%2F26%2Fphp.ini%E4%B8%ADsafe_mode%E5%BC%80%E5%90%AF%E5%AF%B9PHP%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[​ 开启之后，主要会对系统操作、文件、权限设置等方法产生影响，平常项目基本上也用不到这些方法。主要我想还是用来应对 webshell 吧，减少被人植入 webshell 所带来的某些安全问题。 http://www.[PHP](http://lib.csdn.net/base/php).net/manual/zh/ini.sect.safe-mode.[php](http://lib.csdn.net/base/php) php safe_mode 影响参数 函数名 限制 dbmopen() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。dbase_open() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 filepro() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。filepro_rowcount() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。filepro_retrieve() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 ifx_ sql_safemode 限制, (!= safe mode)ingres sql_safemode 限制, (!= safe mode)mysql* sql_safe_mode 限制, (!= safe mode)pg_loimport() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。posix_mkfifo() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 putenv() 遵循 ini 设置的 safe_mode_protected_env_vars 和 safe_mode_allowed_env_vars 选项。请参考 putenv() 函数的有关文档。move_uploaded_file() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 chdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。dl() 本函数在安全模式下被禁用。backtick operator 本函数在安全模式下被禁用。shell_exec()（在功能上和 backticks 函数相同） 本函数在安全模式下被禁用。exec() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。system() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。passthru() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。popen() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。fopen() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。mkdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。rmdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。rename() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 unlink() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。copy() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 (on source and target)chgrp() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。chown() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。chmod() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 另外，不能设置 SUID、SGID 和 sticky bitstouch() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。symlink() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅 测试 target）link() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅测试 target） apache_request_headers() 在安全模式下，以“authorization”（区分大小写）开头的标头将不会被返回。header() 在安全模式下，如果设置了 WWW-Authenticate，当前脚本的 uid 将被添加到该标头的 realm 部分。PHP_AUTH 变量 在安全模式下，变量 PHP_AUTH_USER、PHP_AUTH_PW 和 PHP_AUTH_TYPE 在 $_SERVER 中不可用。但无论如何，您仍然可以使用 REMOTE_USER 来获取用户名称（USER）。（注意：仅 PHP 4.3.0 以后有效） highlight_file(), show_source() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效）parse_ini_file() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效） set_time_limit() 在安全模式下不起作用。max_execution_time 在安全模式下不起作用。mail() 在安全模式下，第五个参数被屏蔽。]]></content>
      <categories>
        <category>PHP转载</category>
      </categories>
      <tags>
        <tag>php.ini  safe_mode 配置 转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 之 ZEROFILL 数据类型属性补 0 操作]]></title>
    <url>%2F2017%2F08%2F17%2FMysql%E4%B9%8BZEROFILL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%A1%A50%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[建一张数据表 ‘t’: 查看一下表的数据结构： mysql&gt; select * from t;+——+——+| a | b |+——+——+| 1 | 2 |+——+——+1 row in set (0.03 sec)mysql&gt; desc t;+——-+——————+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+——————+——+—–+———+——-+| a | int(10) unsigned | YES | | NULL | || b | int(10) unsigned | YES | | NULL | |+——-+——————+——+—–+———+——-+2 rows in set (0.03 sec) 我们可以看到 a,b 字段的数据类型都是 int(10); 接下来让我们改变一下 a 列的数据类型属性。 mysql&gt; alter table t change column a a int(4) unsigned zerofill;Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0 为 a 字段添加了 zerofill 属性，并将默认的 int(10) 修改为 int(4). 查看表的数据结构： mysql&gt; select * from t;+——+——+| a | b |+——+——+| 0001 | 2 |+——+——+1 row in set (0.03 sec) mysql&gt; desc t;+——-+————————–+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+————————–+——+—–+———+——-+| a | int(4) unsigned zerofill | YES | | NULL | || b | int(10) unsigned | YES | | NULL | |+——-+————————–+——+—–+———+——-+2 rows in set (0.04 sec) 这就是 zerofill 属性的作用，如果宽度小于设定的宽度，则自动填充 0. 注意 ： 在 MySQL 中 a 字段实际存储的还是 1. 可用 hex 函数证明. mysql&gt; select a,hex(a) from t;+——+——–+| a | hex(a) |+——+——–+| 0001 | 1 |+——+——–+1 row in set (0.03 sec) 可以推测出 a 字段中的 0001 值的改变只是设置了 zerofill 属性后的一种格式化输出而已. 但为了一些业务的需求问题提供了一个很好的解决办法.]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql 字段类型属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月专业书籍读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[程序员的思维修炼：开发认知潜能的九堂课 亨特 自由的代价是永远提高警惕。 ——约翰•菲尔波特•柯伦的名言, 1790 年 ​ 对于专家来说最致命的弱点是像专家一样行动。一旦你相信自己的专业水平，你就会对其他的可能性视而不见。你停止了好奇心。你可能开始抵制所属领域的改变，担心在你花费了很多努力才得以精通的主题上失去权威。你自己的判断和看法不再支持你，而是囚禁你。 不管你能做什么，或者期望自己能做什么，现在就开始做。勇敢可以给人智慧、力量和神奇。现在就开始做吧。 ——歌德 ​ 如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继续发酵，这当然没问题。​ 好问题是没有答案的。它不是一个需要拧紧的螺栓，而是一颗种下的种子，由它可以收获一片思想的绿洲。 ——约翰•安东尼•查尔迪（John Anthony Ciardi，1916—1986），美国诗人和评论家 ​ 看法是基于预测的。 Perception is based on prediction.​ 很多感知是基于预测的，预测则基于情境和过去的经验，以至于当前的、实时的输入被抛在了后面。​ 认知胜过尝试 ​ 开头把事情做好并不重要，重要的是最后把事情做好。在任何不平凡的工作中，你都会犯错误。​ 错误有益于我们，因为它们让我们思索到底发生了什么，知道什么地方错了，然后通过理解，纠正它。​ 他人即地狱（L’enfer, c’est les autres）。 ——让•保罗•萨特，法国思想家、作家、存在主义哲学大师 ​ 在你出生时，世界上的任何事情都是平凡的，都是世界运转的天然组成部分。当你在十五岁到三十五岁之间时，世界上创造出的任何事物都是新鲜的、令人振奋的、革命性的，你可能以此为职业。三十五岁之后创造出的任何事物都是有悖于事物的自然顺序的。 ——道格拉斯•亚当斯，《怀疑的鲑鱼》​ ，并将它们组装成最合适的表现形式，这就是创作。​ 创造来自于选择和组装，它要选择最合适的部 ​ 设计并不是创造美，美来自于选择、共鸣、同化和爱 ​ 达尔文说过：“无知往往来自于自信而不是知识。 黑客与画家 –保罗·格雷厄姆 以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。 ​ 「“弱即是强”指的是一种软件传播的模式，由 Common Lisp 专家理査德·加布里埃尔（Richard P. Gabriel）于 1991 年在 Lisp: Good News, Bad News, How to Win Big（http://www.dreamsongs.com/WIB.html）一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中的一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能（“弱”）反而是更好的选择（“强”），因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力 任何 C 或 Fortran 程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是 bug 的、运行速度很慢的 Common Lisp 实现 大公司可以互相模仿，但是创业公司就不行。我觉得很多人没有意识到这一点，尤其是一些创业者 essay（论文）这个词来自法语的动词 essayer，意思是“试试看”。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。 设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。 编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。 所谓“编译器”，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。 推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。 科学和工程学的一些最重大的发现在形式上往往很简单，会使得你觉得自己也想到过。 德国包豪斯（Bauhaus）学派的设计师采纳了美国建筑师路易斯·沙利文（Louis Sullivan）的观点“功能决定形式”（form follows function）， 但是他们实际上的理解是“功能应当决定形式”^。真实情况是，如果开发“功能”非常艰难，那么“形式”将不得不全部都由“功能”决定，因为没有多余的精力再来单独开发“形式”了。人们常常觉得野生动物非常优美，原因就是它们的生活非常艰苦，在外形上不可能有多余的部分了。 当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。 ​ 一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程做出的事情。 ​ 技术的发展加大了贫富差距，这是不是一个社会问题？好像没有那么严重。技术在加大收入差距的同时，缩小了大部分的其他差距 ​ 在现实中，财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的 ​ ，他一个人的价值真的等于我们 100 个人的价值吗？你想一想，一个篮球队会同意用一个运动员交换 100 个普通人吗？如果苹果公司不是由乔布斯掌管，而是由一个 100 人组成的委员会掌管，那么这家公司的下一代产品会是什么样 ^？人与人之间的差别并不是那么稳定的线性关系。也许 CEO 和运动员的技能和决心只比普通人高出 10 倍（倍数不重要），但是人与人之间就是存在着重大差别。 ​ 每个人的技能不同，导致收入不同，这才是贫富分化的主要原因，正如逻辑学的“奥卡姆剃刀”原则所说，简单的解释就是最好的解释。 为什么财富的分配问题引起这么多争论？部分原因是反对声最大的人当中，很多人都少有创造财富的经验：大学生、继承人、教授、政客、新闻记者。（如果你在酒吧里听过大家议论体育赛事，你一定很熟悉这种现象。） ​ 一旦自己的财产有了保证，那些想致富的人就会愿意去创造财富，而不是去偷窃。由此导致的新技术不仅被转化成财富，还被转化成军事力量。隐形飞机的理论是由前苏联数学家提出的，但是因为前苏联没有计算机工业，它就只能是一个理论，无法变成产品。前苏联没有足够快的硬件来完成设计飞机所需要的大量计算。 ​ 理解这些有助于回答一个重要的问题：为什么欧洲在历史上变得如此强大？是因为欧洲优越的地理位置，还是因为欧洲人天生就比较优秀，或者是宗教原因？答案（或者至少是近因）可能就是欧洲人接受了一个威力巨大的新观点：允许赚到大钱的人保住自己的财富。 ​ 缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。开发新技术是非常痛苦的经历，正如爱迪生所说，百分之一的灵感加上百分之九十九的汗水。没有财富的激励，就不会有人愿意去做技术革新。工程师愿意接受普通薪水去做一些诱人的项目（比如战斗机和登月火箭），而与日常生活关系更密切的技术革新（比如电灯泡和半导体）只能由创业者来发明。 ​ 「充分条件在这里可能也成立。但是如果成立的话，为什么工业革命没有早一点发生呢？两个可能的（但是互相排斥的）解释是：（a）变化其实早发生了，工业革命只是一系列革命中的一环，（b）中世纪的城镇存在垄断经营和行会制度，延缓了新生产方式的诞生。」 ​ 创造财富不是致富的唯一方法。在人类的历史长河中，它甚至不是最常见的方法。就在几个世纪前，财富的主要来源还是矿石、奴隶、农奴、土地、牲畜，而快速获得财富的方法只有继承、婚姻、征服、没收。所以，很自然地，财富的名声不好。 ​ ^「平均数（mean）是算数平均值，会受到个别极端值的影响，中位数（median）是最中间的那个值，不受个别极端值的影响。所以，这句话的意思就是，由于存在个别极其成功的创业者，所以回报的平均值被拉到了 30 倍，但是大多数创业者其实都以失败告终，所以中位数是 0。——译者注」 「近代历史上，政府有时都搞不清楚金钱和财富的区别。亚当·斯密在《国富论》中提到，许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是，黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。」 ​ 经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。 1989 年，一些聪明的研究人员设计了一个实验，给放射科医生看胸部 X 光片，请他们判断病人有没有肺癌迹象。研究人员记录了医生检査 X 光片时的眼球运动 ^。研究发现，即使那些医生漏掉了一个癌症病灶，他们的目光通常也会在那个地方停留一会。这说明他们的头脑深处已经意识到那里有问题，但是这种深层的反应没有上升为自觉的意识。我认为，类似的思维机制存在于每个人的头脑中，很多看似叛逆的“异端邪说”，早就“潜伏”在我们的思维深处。如果我们暂时关闭自我审查意识，它们就会第一个浮现出来。 ​ 大公司为了避免设计上的灾难，选择了减少设计结果的标准差。但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。大公司只要做到不太烂，就能赢。 「塞缪尔·约翰逊在他编辑的《莎士比亚戏剧集》的前言中写道：“他（莎士比亚）的影响远远超过他的时代，时间就是对他文学成就的检验。不管他的作品从那时的暗语、风俗、政治局势之中，得到过怎样的优势，这些优势都已经消逝多年了。他在毎一幕戏剧中，通过模拟那时的生活所产生的每一个欢乐的主题或悲伤的动机，都已经趋于平淡，而不再是戏剧的亮点。贵族的宠爱和对手的竞争，都不再产生效果，朋友和敌人都走进了坟墓，他的作品再也不是支持一方、打击另一方的舆论工具；它们既不能产生虚名，也不会带来恶意的攻击。人们阅读这些作品，只有一个理由，那就是欣赏作品本身。因此，只有人们真正欣赏它们，才会发出赞美……”」 塞缪尔·约翰逊 ^ 说过，人们对一个作家的评价，需要 100 年才能达成一致 ^^。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。 当工作的专业程度越来越高时，我们就必须接受更长时间的训练。工业化时代来临之前，儿童最晚大约在 14 岁就要参加工作，如果是在农庄（那个时代大多数人生活在农村），参加工作的时间就更早。如今，只要一个青少年读大学，他就要等到 21 岁或 22 岁才开始全职工作。如果再读更髙的学位，比如医学博士或哲学博士，可能要拖到 30 岁才能完成学业。 这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式 ^。 你的灯亮着吗？：发现问题的真正所在 唐纳德·高斯 人们永远没有足够的时间去考虑到底是不是想要它，但永远有足够的时间去为之后悔 ​ 但在更多情况下，交流不畅不是困难的根源。对于不了解的事情，或者不想了解的事情，人们无法有效交流。​ 大多数情况下，问题的根源在你自己身上。​ 在社会上，很多问题源自系统的设计者和决策者，他们并未亲身体会过应该由他们“负责任”的问题。​ 只要可行，人们会首先把问题置于让自己觉得最舒适的语义层面上 ​ 每转换一次视角，都会发现新的不协调之处。 在把一项“解决方案”付诸实践之前从各个视角对其审视一遍，不是比等到出现灾难性后果才意识到问题存在好得多吗？​ 在这次大型“实验”之前，没有人确切知道为什么每年有 50000 人死在高速公路上。汽车制造商归罪于司机，与制酒业无关的所有人指责醉酒驾驶者是罪魁祸首，但从没有人因为立法者设定了如此之高的车速上限而责怪他们。​ 每一个解决方案都是下一个问题的来源。 我们永远都没法避开问题。问题、解决方案、新问题循环出现，构成了无尽的链条。能指望的最理想状态就是新问题比我们“已经解决”的问题要好对付一些。​ 问题就是理想状态和现实状态之间的差别。 人月神话 –弗雷德里克·布鲁克斯 人件：高生产率的项目和团队 ​ 编程人员被屏蔽而不是暴露在他人模块内部结构面前。这种情况下，工作效率最高 ​ 老板的不良反应肯定会对信息的完全公开造成压制；相反，仔细区分状态报告、毫无惊慌地接收报告、决不越俎代庖，将能鼓励诚实的汇报。​ 状态的获取是困难的，因为下属经理有充分的理由不提供信息共享 ​ 系统文档中的巨大容量带来了新的不理解问题 [例如，看看 Unix]，但是它比大多数未能详细描述编程系统特性的短小文章更加可取。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。​ 很容易为不同的晋升线建立相互一致的薪水级别，但要同等威信的建立需要一些强烈的心理措施：相同的办公室、一样的支持和技术调动的优先补偿 ​ 目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。​ 户的实际需要和用户感觉会随着程序的构建、测试和使用而变化 ​ 将开发的第一个系统–丢弃原型–发布给用户，可以获得时间，但是它的代价高昂–对于用户，使用极度痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使最好的再设计也难以挽回名声 ​ 对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。​ 一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法–既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。​ 向软件项目中增派人手从三个方面增加了项目必要的总体工作量：任务重新分配本身和所造成的工作中断；培训新人员；额外的相互沟通。​ 2.10 因为我们对自己的估计技术不确定，所以在管理和客户的压力下，我们常常缺乏坚持的勇气。 2.11 Brook 法则：向进度落后的项目中增加人手，只会使进度更加落后。​ 在若干人员中分解任务会引发额外的沟通工作量–培训和相互沟通。 2.8 关于进度安排，我的经验是为 1/3 计划、1/6 编码、1/4 构件测试以及 1/4 系统测试。​ 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。​ .. 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外 ​ 。实际上，类的容易重用和通过继承方便地定制是面向对象技术最吸引人的地方 ​ 在所有被误导的科学探索中，最悲惨的莫过于对一种能够将一般金属变成金子的物质，即点金石的研究。这个由统治者不断地投入金钱，被一代代的研究者不懈追求的、炼金术中至高无上的法宝，是一种从理想化想象和普遍假设中–以为事情会像我们所认为的那样–提取出的精华。它是人类纯粹信仰的体现，人们花费了大量的时间和精力来认可和接受这个无法解决的问题。即使被证明是不存在，那种寻找出路和希望能一劳永逸的愿望，依然十分的强烈。而我们中的绝大多数总是很同情这些明知不可为而为之的人，因此它们总是得以延续。所以，将圆形变方的论文被发表，恢复脱发的洗液被研制和出售，提高软件生产率的方法被提出并成功地推销。​ 在软件开发中，我称为”必要（essence）”的部分是构思这些概念上的结构；我称为”次要（accident）”的部分指它的实现过程。​ 那些想看到完美方案的人，其实在心底里就认为它们以前不存在，以后也不可能出现。 - 亚历山大·波普，批判散文 ​ 没有任何软件机构可以忽视这项挑战。尽管公司可能缺少良好的管理人员，但决不会比良好设计人员的需求更加迫切，而卓越的管理人员和设计人员都是非常缺乏的。大多数机构花费了大量的时间和精力来寻找和培养管理人员，但据我所知，它们中间没有任何的一家在寻求和培育杰出的设计人员上投入相同的资源，而产品的技术特色最终依赖于这些设计人员。​ 其中的差异并不小–就象萨列里和莫扎特。一个接一个的研究显示，非常卓越的设计者产生的成果更快、更小、更简单、更优雅，实现的代价更少。卓越和一般之间的差异接近于一个数量级。​ 。低劣设计和良好设计之间的区别可能在于设计方法中的完善性，而良好设计和卓越设计之间的区别肯定不是如此。卓越设计来自卓越的设计人员。软件开发是一个创造性的过程。完备的方法学可以培养和释放创造性的思维，但它无法孕育或激发创造性的过程。​ 无限扩展。日常生活中，建筑有可能发生变化，但众所周知，建筑修改的成本很高，从而打消了那些想提出修改的人的念头。​ 所有成功的软件都会发生变更。现实工作中，经常发生两种情况。当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。​ 自文档化方法 ​ 不了解，就无法真正拥有。 - 歌德 ​ 减少角色的冲突。首先老板必须区别行动信息和状态信息。他必须规范自己，不对项目经理可以解决的问题做出反应，并且决不在检查状态报告的时候做安排。我曾经认识一个老板，他总是在状态报告的第一个段落结束之前，拿起电话发号施令。这样的反应肯定压制信息的完全公开。​ 关键的地方和构建无 bug 程序的核心，是把系统的结构作为控制结构来考虑，而不是独立的跳转语句。这种思考方法是我们在程序设计发展史上向前迈出的一大步 ​ 我能召唤遥远的精灵。 那又怎么样，我也可以，谁都可以，问题是你真的召唤的时候，它们会来吗？ - 莎士比亚，《亨利四世》，第一部分 ​ 这正是历史的关键。使用卓越的能源–构建文明–成立杰出的机构，但是每次总会出现问题。一些致命的缺陷会将自私和残酷的人带到塔尖，接着一切开始滑落，回到到痛苦和堕落。实际上，机器失灵了。看上去，就好像是机器正常启动，跑了几步，然后垮掉了 7。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。令人吃惊的是，该成本受用户数目的严重影响。用户越多，所发现的错误也越多。​ 不过，他提出了一种卓越的见解。他观察到不愿意为设计书写文档的原因，不仅仅是由于惰性或者时间压力。相反，设计人员通常不愿意提交尝试性的设计决策，再为它们进行辩解。”通过设计文档化，设计人员将自己暴露在每个人的批评之下，他必须能够为他的每个结果进行辩护。如果团队架构因此受到任何形式的威胁，则没有任何东西会被文档化，除非架构是完全受到保护的 ​ 数据的表现形式是编程的根本 ​ 规格说明的风格必须清晰、完整和准确。用户常常会单独提到某个定义，所以每条说明都必须重复所有的基本要素，所以所有文字都要相互一致。这往往使手册读起来枯燥乏味，但是精确比生动更加重要。​ 概念的完整性的确要求系统只反映唯一的设计理念，用户所见的技术说明来自少数人的思想。实际工作被划分成体系结构、设计实现和物理实现，但这并不意味着该开发模式下的系统需要更长的时间来创建。经验显示恰恰相反，整个系统将会开发得更快，所需要的测试时间将更少。同工作的水平分割相比，垂直划分从根本上大大减少了劳动量，结果是使交流彻底地简化，概念完整性得到大幅提高。​ 体系结构同实现必须仔细地区分开来。如同 Blaauw 所说的，”体系结构陈述的是发生了什么，而实现描述的是如何实现 3。”他举了一个简单的例子–时钟。它的结构包括表面、指针和上发条的旋钮。当一个小孩知道了时钟的外表结构，他很容易从手表或者教堂上的时钟辨认时间。而时钟的实现，描述了表壳中的事物–很多种动力提供装置中的一种，以及众多控制精度方案的一种。​ 而进度压力却要求很多人员来开发系统。有两种方法可以解决这种矛盾。第一种是仔细地区分设计方法和具体实现。第二种是前一章节中所讨论的、一种崭新的组建编程开发团队的方法。​ 。项目的时间依赖于顺序上的限制，人员的数量依赖于单个子任务的数量。从这两个数值可以推算出进度时间表，该表安排的人员较少，花费的时间较长（唯一的风险是产品可能会过时）。相反，分派较多的人手，计划较短的时间，将无法得到可行的进度表。总之，在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大 ​ 向进度落后的项目中增加人手，只会使进度更加落后。（Adding manpower to a late software project makes it later​ 因为软件开发本质上是一项系统工作–错综复杂关系下的一种实践–沟通、交流的工作量非常大，它很快会消耗任务分解所节省下来的个人时间。从而，添加更多的人手，实际上是延长了，而不是缩短了时间进度。]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>人月神话 黑客与画家 程序员思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[皮囊 –蔡崇达 我没能说出口的是：厚朴，或许能真实地抵达这个世界的，能确切地抵达梦想的，不是不顾一切投入想象的狂热，而是务实、谦卑的，甚至你自己都看不起的可怜的隐忍。 梦想原来是卑微的执着。 他以为再走进去，就是无限宽广的可能；他以为正在和他对话的，已经是整个世界。 台风在于我从来没有悲伤的色彩，直到那一年。 小王子 –圣. 埃克苏佩里 。如果一个人听任自己被人驯服，那他就要冒流泪的风险…… 重要的东西眼睛是看不见的。 你一直不懂我的爱，这是我的错。不过这并不重要。但是你——你却和我一样傻。祝你幸福……将玻璃罩拿走吧，我不需要。” 我本应该根据事实而不是花言巧语来判断她。她用她的芬芳环绕着我，用她的光辉照耀着我。我真不该离开她……我应该猜出隐藏在她拙劣伎俩背后的所有温情。但我当时太小了，根本不知道怎样去爱她……” 月亮与六便士 –毛姆 恐惧使人们变得残酷无情…… 女人们禀性善良、喜爱虚荣，因此便认为这种感情极富于精神价值。但是在冲动的热情前面，这 种感情是毫无防卫能力的。 这是一种对任何一个人都可能产生的被动的感情，正象藤蔓可以攀附在随便哪株树上一样。因为 这种感情可以叫一个女孩子嫁给任何一个需要她的男人，相信日久天长便会对这个人产生爱情， 所以世俗的见解便断定了它的力量。但是说到底，这种感情是什么呢？它只不过是对有保障的生 活的满足，对拥有家资的骄傲，对有人需要自己沾沾自喜，和对建立起自己的家庭洋洋得意而已。 我觉得，在爱情的事上如 果考虑起自尊心来，那只能有 一个原因：实际上你还是最爱自己 有一些人很不幸，即使他们流露的是最真挚的感情也令人感到滑稽可笑，戴尔克·施特略夫正是这样一个人。 有人说灾难不幸可以使人性高贵，这句话并不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人们变得心胸狭小、报复心更强。 到了这一 地步，对那些不肯受良心约束的人，他就会觉得怎样责骂也不过分，因为他已经是社会的一名成 员，他知道得很清楚，绝对没有力量造自己的反了。 一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”​ 这种生活模式给人以安详亲切之感。它使人想到一条平静 的小河，蜿蜒流过绿茸茸的牧场，与郁郁的树荫交相掩映，直到最后泻入烟波浩渺的大海中。但是大海却总是那么平静，总是沉默无言、声色不动，你会突然感到一种莫名的不安。也许这只是我自己的一种怪想法（就是在那些日子这种想法也常在我心头作祟），我总觉得大多数人这样度过一生好象欠缺一点什么。我承认这种生活的社会价值，我也看到了它的井然有序的幸福，但是 我的血液里却有一种强烈的愿望，渴望一种更狂放不羁的旅途。这种安详宁静的快乐好象有一种 叫我惊惧不安的东西。我的心渴望一种更加惊险的生活。只要在我的生活中能有变迁——变迁和 无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。 人们常常发现一位离了职的首相当年只不过是个大言不惭的演说家；一个解甲归田的将军无非是个平淡乏味的市井英雄。 目送 –龙应台 原来所有自己的当下啊，都是别人的过去。 幸福就是，寻常的日子依旧 幸福就是，生活中不必时时恐惧 你告诉我，什么是家，我就可以告诉你，什么是永恒。 有一段初始的生命，全世界只有这几个人知道，譬如你的小名，或者，你在哪一棵树上折断了手 是的，没有一种笑是铁打的 甚至眼泪也不是…… 你们之中，今天最聪明、最优秀的四个孩子，两个人会成为医生或工程师或商人，另外两个人会终其一生落魄而艰辛。所有其它的人，会经历结婚、生育、工作、退休，人生由淡淡的悲伤和淡淡的幸福组成，在小小的期待、偶尔的兴奋和沉默的失望中过每一天，然后带着一种想说却又说不来的『懂』，作最后的转身离开。」 如果在我们十二岁那年，有人跟我们这样上课，会怎么样？ 当然，没有一个老师，会对十二岁的孩子们这样说话。因为，这，哪能作人生的「座右铭」呢？ 天心月圆 也还相信。 譬如国也许不可爱，但是土地和人可以爱。譬如史也许不能信，但是对于真相的追求可以无止尽。譬如文明也许脆弱不堪，但是除文明外我们其实别无依靠。譬如正义也许极为可疑，但是在乎正义比不在乎要安全。譬如理想主义者也许成就不了大事大业，但是没有他们社会一定不一样。譬如爱情总是幻灭的多，但是萤火虫在夜里发光从来就不是为了保持光。譬如海枯石烂的永恒也许不存在，但是如果一粒沙里有一个无穷的宇宙，一刹那里想必也有一个不变不移的时间。 曾经相信过爱情，后来知道，原来爱情必须转化为亲情才可能持久，但是转化为亲情的爱情，犹如化入杯水中的冰块——它还是冰块吗？ 情人 –杜拉斯 我已经老了，有一天，在一处公共场所的大厅里，有一个男人向我走来。他主动介绍自己，他对我说：“我认识你，永远记得你。那时候，你还很年轻，人人都说你美，现在，我是特为来告诉你，对我来说，我觉得现在你比年轻的时候更美，那时你是年轻女人，与你那时的面貌相比，我更爱你现在备受摧残的面容。” 恨之所在，就是沉默据以开始的门槛。只有沉默可以从中通过，对我这一生来说，这是绵绵久远的苦役。我至今依然如故，面对这么多受苦受难的孩子，我始终保持着同样的神秘的距离。我自以为我在写作，但事实上我从来就不曾写过，我以为在爱，但我从来也不曾爱过，我什么也没有做，不过是站在那紧闭的门前等待罢了。 不要求取得什么，只求从当前的处境中脱身而去。 菊于刀 –本尼德克特 萨苏 刘锋 我们通常为因为财富产生的不平等而感到愤恨，但是在历史上，以财富的不平等代替出身的不平等却是人类的一个进步。因为，人无法选择出身，却可能通过自己的努力致富；虽然依然是不平等，却为每个人在人格上的平等打下了基础。为了争取到这样的不平等，法国付出了几十年不断的革命，英国经历了王位的反复兴废，从欧洲到亚洲染满了血腥……历史的发展中，五十步和一百步差别就是这样大。 荣枯鉴 –冯道 谤而不辩，其事自明，人恶稍减也；谤而强辩，其事反浊，人怨益增也 人微不诤，才庸不荐 位高节低，人贱义薄 人冀人愚而自明，示人以愚，其谋乃大；人忌人明而自愚，智无潜藏，其害无止 l 有的人总希望别人愚蠢而自己聪明，展示在众人面前是很愚笨的，这样的人具有非同小可的谋略；有的人忌妒别人聪明而自己愚蠢，才智也没有能力深深隐藏，这样的人将祸患无穷。 祸于上，无辩自罪者全；祸于下，争而罪人者免 孤独六讲 –蒋勋 这个社会要有一个从群众里走出去的孤独者，他才会比较有思考性，因为他走出去，可以回看群众的状态；如果他在群众当中，便没办法自觉。 我们看高空弹跳、赛车、极限表演，都是藉助观赏他者的冒险，发泄自己生命潜意识里的暴力倾向。 群体的道德意识往往会变成对他人的指责，在西方，道德观已经回归到个体的自我检视，对他人的批判不叫道德，对自己行为的反省才是 少有人走的路 –斯科特. 派克 你不可能宽恕一个没有罪过的人。宽恕只有在有罪裁决后才生效。 停止一个游戏，唯一的方式就是停止， 一个没有灵魂的人就像一张破碎的纸片，盲目地追逐着每一阵风，完全失去了掌控自己的能力，最终会成为魔鬼撒旦的工具，干出许多邪恶的事情。 恶，可以定义为：为了维护病态的自我， 不择手段去毁灭别人的自我。 恩典与个人之间的关系：“就像身体包裹在衣服里，血肉包裹在皮肤里，骨骼包裹在血肉里，心脏包裹在胸腔一样，我们的心灵和身体包裹在上帝的慈善之中。衣服、血肉、骨骼和心脏都会衰朽，而上帝的慈善却永远保持完整。 自由与约束相辅相成，没有约束作基础，自由带来的就不是真正的爱，而是情感的毁灭。 精神贯注表面上的代价之一，就是你迟早要为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中的许多事物，包括子女、婚姻、性爱、晋升和友谊，但唯有这些事物才能够使人生丰富多彩。在拓展自我的过程中，除了痛苦和悲伤，你同样可以收获快乐和幸福。完整的人生势必伴随着痛苦，其中最大的痛苦之一，就是心爱之人或心爱之物的逝去。如果你想避免其中的痛苦，那你恐怕只有完全脱离现实，去过没有任何意义的生活。 有些时候，我们宁可拒绝改变，也不愿忍受改变带来的痛苦，此时我们最需要的就是勇气。勇气，并不意味着永不恐惧，而是面对恐惧时能够坦然行动，克服畏缩心理，大步走向未知的未来。在某种意义上，心智的成熟（也即爱的实质）需要勇气，也需要冒险。 把“爱”挂在口头上，或只在脑海里去想象真正的爱，并以此作为爱的证据，这显然是轻而易举的事情，而表现出爱的行动却相当困难。真正的爱，其价值在于始终如一的行动，这远远大于转瞬即逝的感觉或者精神贯注。真正的爱出自自我意愿，只能依靠实际行动来证明。 ​ 想让别人真正爱你，只有让自己成为值得爱的人 坠入情网本身并不是爱，但它却是爱的神秘架构中最重要的一环。 对于某种事物长期的爱，使我们生活在了精神贯注的境界里，于是，我们的自我界限便开始延伸，延伸到一定程度后，自我界限就会淡化，而这时，我们的心智便获得了成熟 为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由。 哈佛商业评论 对美好事情的期待。比起美好事情，我们可能更钟情的是对其“渴求”的过程 对商场上的成功而言，技巧和好运缺一不可。就像文章开头所说，并没有简单的规则。但总体而言，战略勇气、适应能力和价值观决定的领导力在商场和战场上均可提高成功的可能性。 我们所畅想的新型雇主－雇员契约的重要性在于：虽然它并不以忠诚为基础，但它也不仅仅是纯粹的交易。它是组织与个人之间的联盟，联盟双方都致力于帮助彼此走向成功。 因为这种契约仍旧鼓励人员流动，这有碍于发挥员工生产力。更重要的是，虽然缺乏职业安全感直接促使员工更具适应能力与创业精神，但由于缺乏共同利益，其导致了逆向选择，也就是最具适应力与创业精神的员工反而另谋高就。企业节约了成本，但损失的是创新性与适应能力。 杀死一只知更鸟 –哈珀·李 从马耶拉张嘴喊叫的那一刻起，汤姆就死定了。 她们慢晃摇椅，轻挥罗扇，细斟慢饮地喝着冰水。 这个世界从表面上看来，只是一群香喷喷的女士 因为他刚安慰了我，所以我就说它看起来很可爱，但实际上我什么也没看见。“真不错，杰姆 他告诉过我，说带枪就等于邀请别人来射你。 勇敢是，当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。 道理很简单，不能因为我们开始前已经失败了一百年，就认为我们没有理由去争取胜利。 阿蒂克斯说过去掉那些形容词，剩下的就是事实了 当然不应该那样做，不过他永远不会改变他的生活方式。你不会再抱怨他的孩子们了吧？​ 霍乱时期的爱情 –加西亚. 马尔克斯 他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 ​ 无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了 “你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定 当她在成为寡妇后的第一个早晨醒来，闭着眼睛在床上翻了个身，想找一个更舒服的姿势继续睡下去，就在这一刻，她才真正意识到他死了。也只有在这时，她才察觉到，这是他多年来第一次没有在家过夜。另一个触动她的情境是在餐桌前，但不是因为感到孤单，尽管事实的确如此，而是因为她奇怪地相信，自己正在同某个已不存在的人一起用餐 ​ 她无法摆脱隐藏在心底的怨恨，怨丈夫将她孤零零地遗弃在这汪洋大海之中 ​ 在这么多年一次次精心算计的爱情之后，天真无邪的生涩味道别有一番新鲜的堕落的快乐 “我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。” 曾经，每天的每分每秒都胜似他的盟友，如今却开始算计他 但最终，他还是让步了，弗洛伦蒂诺·阿里萨把镜子挂到了自己家中，却并不是因为那镜框的精雕细琢，而是因为镜子里的那片天地，他爱恋的形象曾在那里占据了两个小时之久 ​ 他们终于彻底了解了对方，在结婚将近三十年时，他们变得好似一个人被分成了两半，常常因为对方猜出自己没有说出口的心事，或者一个抢先把另一个想说的话公之于众的荒唐事件而感到不悦。 ​ 她丈夫爱她胜过一切，胜过世间所有的人，但这也仅仅是为了他自己：这是他的神圣义务。 ，唯一可能的解释——就像她常说的那样——便是她怨恨丈夫明知故犯地为一群黑人牺牲了性命，而唯一正确的牺牲应该是为了她活下去 ​ 但当她们独自去望弥撒时，才逐渐意识到，自己又一次成为自己意愿的主人，当初，为了换取一种安全感，她们不仅放弃了自己家庭的姓氏，甚至放弃了自我，可那种安全感不过是她们做姑娘时许多幻想中的一个罢了。只有她们自己知道，她们曾经疯狂爱着的那个男人——尽管他或许也爱着她们——给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 ​ 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 ​ 说不清究竟是欧洲之行改变了他们，还是爱情改变了他们，因为这两者是同时发生的。它们都起了作用，更深一层说，改变的不仅是他们两人，也是所有人，就像弗洛伦蒂诺·阿里萨在那个不幸的星期日，他们回来两周后，看见他们望完弥撒从教堂中走出来时所察觉到的那样。 ​ 尽管并非有意，但这样处理匿名信的方式是正确的，其实那些不敢留名的人所属的阶层，在历史的嘲弄下，早已习惯了对既成的事实低头 ​ 可洛伦索·达萨以桶匠的大度吞下所受的侮辱，继续执著地依靠智慧创造偶遇胡维纳尔·乌尔比诺的机会，却没有发现其实是胡维纳尔·乌尔比诺付出了更为超常的努力，尽一切可能让两人相遇 “这座城市还真是伟大，”他常常说，“我们用了四百年的时间来摧毁它，至今仍没有达成目的。 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们靠私下里抽签来决定谁做他的女伴，而他也乐得与她们相处，但总是若即若离，始终保持着清雅，直到最后，他不可救药地被费尔明娜·达萨那种质朴的魅力迷住了 ​ 但与那时不同，此刻她没有感到爱情的震撼，而是坠入了失望的深渊。 ​ 四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生 不可避免，苦杏仁的气味总是让他想起爱情受阻后的命运]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书书摘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开发规范手册总结 - 数据库]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[MySQL 数据库设计规范 建表规约 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint(1 表示是，0 表示否)。说明: 任何字段如果为非负数，必须是 unsigned。正例: 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。说明:MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写。因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝。 正例:aliyun_admin，rdc_config，level3name 反例:AliyunAdmin，rdcConfig，level_3_name 【强制】表名不使用复数名词。 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 【强制】主键索引名为 pk字段名; 唯一索引名为 uk字段名; 普通索引名则为 idx_字段名。 说明:pk 即 primary key;uk 即 unique key;idx_ 即 index 的简称。 【强制】小数类型为 decimal，禁止使用 float 和 double。说明:float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不 正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【推荐】表的命名最好是加上“业务名称_表的作用”。正例:alipay_task / force_project / trade_config 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循:1)不是频繁修改的字段。2)不是 varchar 超长字段，更不能是 text 字段。 正例: 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。说明: 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。 索引规约 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 【强制】超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致; 多表关联查询时，保证被关联的字段需要有索引。说明: 即使双表 join 也要注意表索引、SQL 性能。 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。说明: 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90% 以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 说明: 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。正例:where a=? and b=? order by c; 索引:a_b_c 反例: 索引中有范围查找，那么索引有序性无法利用，如:WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。 【推荐】利用覆盖索引来进行查询操作，避免回表。说明: 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗? 目录浏览 一下就好，这个目录就是起到覆盖索引的作用。正例: 能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查 询的一种效果，用 explain 的结果，extra 列会出现:using index。 【推荐】利用延迟关联或者子查询优化超多分页场景。说明:MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过 特定阈值的页数进行 SQL 改写。正例: 先快速定位需要获取的 id 段，然后再关联: SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20) b where a.id=b.id 【推荐】SQL 性能优化的目标: 至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。 说明: 1)consts 单表中最多只有一个匹配行(主键或者唯一索引)，在优化阶段即可读取到数据。2)ref 指的是使用普通的索引(normal index)。3)range 对索引进行范围检索。 反例:explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 【推荐】建组合索引的时候，区分度最高的在最左边。正例: 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即 可。说明: 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如:where a&gt;?and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 【参考】创建索引时避免有如下极端误解: 1)宁滥勿缺。认为一个查询就需要建一个索引。2)宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。3)抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 SQL 语句 【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明:count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinctcol1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。正例: 可以使用如下方式来避免 sum 的 NPE 问题:SELECT IF(ISNULL(SUM(g)),0,SUM(g))FROM table; 【强制】使用 ISNULL()来判断是否为 NULL 值。说明:NULL 与任何值的直接比较都为 NULL。 1) NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 2) NULL=NULL 的返回结果是 NULL，而不是 true。 3) NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。 【强制】 在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风险; 外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正 (特别是删除、修改记录操作) 时，要先 select，避免出现误删除，确认 无误才能执行更新语句。 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数 的区别。 说明: SELECT LENGTH(“轻松工作”); 返回为 12SELECT CHARACTER_LENGTH(“轻松工作”); 返回为 4如果需要存储表情，那么选择 utf8mb4 来进行存储，注意它与 utf-8 编码的区别。 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。说明:TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM 映射 【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。 说明:1)增加查询分析器解析成本。2)增减字段容易与 resultMap 配置不一致。 【强制】sql.xml 配置参数使用:#{}，#param# 不要使用 ${} 此种方式容易出现 SQL 注入。 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。 说明:resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 【参考】中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带 上此条件;表示不为空且不为 null 时执行;表示不为 null 值时 执行。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>开发规范 编程规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里巴巴开发规范手册总结 - 编程规范]]></title>
    <url>%2F2017%2F01%2F10%2F%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[编程规范 命名规范 【强制】类名使用 UpperCamelCase 风格。 正例:MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion 反例:macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。 正例: localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例:MAX_STOCK_COUNT反例:MAX_COUNT 【强制】杜绝完全不规范的缩写，避免望文不知义。 反例:AbstractClass“缩写”命名成 AbsClass;condition“缩写”命名成 condi，此类随 意缩写严重降低了代码的可阅读性。 【推荐】如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。说明: 将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 正例:public class OrderFactory;public class LoginProxy;public class ResourceObserver; 【参考】各层命名规约: 1) 获取单个对象的方法用 get 作前缀。2) 获取多个对象的方法用 list 作前缀。3) 获取统计值的方法用 count 作前缀。4) 插入的方法用 save/insert 作前缀。5) 删除的方法用 remove/delete 作前缀。6) 修改的方法用 update 作前缀。 常量定义 【推荐】不要使用一个常量类维护所有常量，按常量功能进行归类，分开维护。 说明: 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 代码格式 【强制】 左小括号和字符之间不出现空格; 同样，右小括号和字符之间也不出现空格。详见 第 5 条下方正例提示。反例:if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。 【强制】任何二目、三目运算符的左右两边都需要加一个空格。 说明: 运算符包括赋值运算符 =、逻辑运算符 &amp;&amp;、加减乘除符号等。 123456789101112131415161718public static void main(String[] args) &#123; // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) &#123; System.out.println(say); &#125; // 左大括号前加空格且不换行; 左大括号后换行 if (flag == 1) &#123; System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 &#125; else &#123; System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 &#125; &#125; 【强制】注释的双斜线与注释内容之间有且仅有一个空格。 12// 这是示例注释，请注意在双斜线之后有一个空格String ygb = new String(); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 正例: 下例中实参的”a”, 后边必须要有一个空格。method(“a”, “b”, “c”); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式， 不要使用 Windows 格式。 【推荐】不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。说明: 没有必要插入多个空行进行隔开。 OOP 规约 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字:1) 不允许被继承的类，如:String 类。2) 不允许修改引用的域对象，如:POJO 类的域变量。3) 不允许被重写的方法，如:POJO 类的 setter 方法。 4) 不允许运行过程中重新赋值的局部变量。 5) 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止; 在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使空代码。 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。说明: 如果并发控制没有处理好，容易产生等值判断被“击穿”的情况，使用大于或小于的区间 判断条件来代替。 反例: 判断剩余奖品数量等于 0 时，终止发放奖品，但因为并发处理错误导致奖品数量瞬间变 成了负数，这样的话，活动无法终止。 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成: if (condition) {… return obj;} // 接着写 else 的业务逻辑代码;说明: 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维 护困难，请勿超过 3 层。 正例: 超过 3 层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下: 123456789public function overIf()&#123; if(isBusy())&#123; return; &#125; if(isFree())&#123; return; &#125; return;&#125; 【参考】下列情形，需要进行参数校验:1) 调用频次低的方法。2) 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参 数错误导致中间执行回退，或者错误，那得不偿失。3) 需要极高稳定性和可用性的方法。4) 对外提供的开放接口，不管是 RPC/API/HTTP 接口。5) 敏感权限入口。 注释规约 【强制】所有的类都必须添加创建者和创建日期。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用 // 注释。方法内部多行注释 使用 / / 注释，注意与代码对齐。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的 一个极端: 过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。 反例: // put elephant into fridge put(elephant, fridge); 方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 异常日志 异常处理 【强制】异常不要用来做流程控制，条件控制。说明: 异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式 要低很多。 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。（解释原因） 日志规约 【强制】应用中的扩展日志 (如打点、临时监控、访问日志等) 命名方式:appName_logType_logName.log。logType: 日志类型，推荐分类有 stats/monitor/visit 等;logName: 日志描述。这种命名的好处: 通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 正例:mppserver 应用中单独监控时区转换异常，如:mppserver_monitor_timeZoneConvert.log 说明: 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 【推荐】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。如非必要，请不要在此场景打出 error 级别，避免频繁报警。说明: 注意日志输出的级别，error 级别只记录系统逻辑出错、异常或者重要的错误信息。 其他 【推荐】及时清理不再使用的代码段或配置信息。说明: 对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。正例: 对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠 (///) 来说明注释掉代码的理由。 单元测试 【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 反例: 删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。 【参考】为了更方便地进行单元测试，业务代码应避免以下情况:  构造方法中做的事情过多。  存在过多的全局变量和静态方法。  存在过多的外部依赖。  存在过多的条件语句。说明: 多层条件语句建议使用卫语句、策略模式、状态模式等方式重构。 安全规约 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。说明: 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷导致资损。说明: 如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。]]></content>
      <categories>
        <category>开发规范</category>
      </categories>
      <tags>
        <tag>开发规范 编程规范</tag>
      </tags>
  </entry>
</search>
