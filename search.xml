<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[大话设计模式 (三)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[设计模式分组 一、创建型模式 抽象工厂模式 提供一个创建一系列或相关依赖对象的接口，而无需指定他们具体的类[DP] 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示[DP] 工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到子类[DP] 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP] 单例模式 保证一个类只有一个实例，并提供一个访问它的全局访问点[DP] 总结 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么，谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。[DP] 关于松耦合：内聚性和耦合性 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DP] 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定[DP] 通常设计应是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地[DP] ​ 二、 结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作[DP] 桥接模式 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 组合模式 将对象组合成树形结构以表示‘部分 - 整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性[DP] 装饰模式 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活[DP] 外观模式 为子系统中的一组接口提供一个一致 的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] 享元模式 为运用共享技术有效地支持大量细粒度的对象[DP] 代理模式 为其他对象提供一种代理以控制对这个对象的访问[DP] 总结 问题 : 信息的隐藏促进了软件的复用，如何理解这句话？ ​ 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。 代理模式与外观模式的区别 代理对象代表一个单一对象而外观对象代表一个子系统 代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口[R2P] 代理与适配器之间来说，代理模式是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个对象交涉。而适配器则不需要虚构出一个代表着，只需要为应付特定使用目的，将原来的类进行一些组合[DP]。 三、行为型模式 观察者模式 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 ​ 模板方法模式 定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP]。 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销操作[DP]。 状态模式 允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类[DP]。 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch 中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止[DP]。 四、 行为型模式第二组 解释器模式 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP]。 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[DP] 策略模式 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[DP] 备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态[DP]。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界[DP]。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。[DP] 五、 总结 工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂[DPE]。 面向对象设计模式体现的就是抽象的思想。 类是对对象的抽象 抽象类是对类的抽象 接口是对行为的抽象]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (一)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[大话设计模式 标签（空格分隔）： 设计模式 大话 设计 仅供参考 /(ㄒ o ㄒ)/~~ 相关的对应的代码会贴上百度云，是用 JAVA 写的。想看的可以下载（在文章末尾）。暂时只是一些个概念和大体结构，大部分（jihu）是没有代码的，理解起来肯定会比较难（或许根本理解不了），whatever , 只是个人读书笔记，比较粗糙，凑活看吧。哈哈。 一 、简单工厂模式 用一个单独的类来实现易修改和扩展创造实例的过程。 有图 ​ ​ UML 类图图示样例 ​ ​ ‘+’表示 public ‘-‘表示 private ‘#’表示 protected ​ 继承关系用空心三角形 + 实线来表示 如图 ​ ​ 接口关系用空心三角形 + 虚线表示 形如上图（略） ​ 关联关系用实线箭头表示 形如上图（略）、 ​ 聚合关系 ​ 聚合表示一种弱的’拥有‘关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 –《设计模式》第二版 用空心的菱形 + 实线箭头表示 ​ 这个有图哦:happy: ​ ​ 组合关系 ​ 一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 –《设计模式》 ​ 组合关系用实心的菱形 + 实线箭头来表示，连线两端的数字 1,2，被称为基数表明这一端的类可以有几个实例（n 表示无数）。 这个也是有图的 看图 ​ ​ 依赖关系 用虚线箭头表示 UML 最后一张图 ​ 二 、策略模式​ 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP] ​ 面向对象的编程, 并不是越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 ​ 策略模式结构图 ​ ​ 策略模式反思 策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合 –《设计模式》[DPE] ​ 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 –《设计模式》【DPE】 ​ 1. 单一职责原则(SRP)​ 就一个类而言，应该仅有一个引起它变化的原因。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏【ASD】。 ​ 2. 开放 - 封闭原则[简称 OCP]​ 是说软件实体（类，模块，函数等等），应该可以扩展，但是不可修改【ASD】 ​ 开放 - 封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要【ASD】 ​ 3. 依赖倒转原则​ 抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程） ​ 依赖倒转原则 ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。【ASD】 ​ 4. 里氏代换原则【LSP】​ 子类型必须能够替换掉他们的父类型。【ASD】 ​ 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 如图 ​ ​ （依赖倒转其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如） ​ 原则总结​ 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了【ASD】 ​ 三 、装饰模式​ 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活【DP】 ​ 如图装饰模式结构图 ​ ​ 装饰模式实例代码（感觉穿衣服的例子比较有意思，是 java 代码:sad:, 逻辑能看懂:sad:） ​ 后面有例子总结，不想看图的直接跳到后面看。 ​ ​ ​ ​ ​ ​ 小结 ​ 我理解的大概的过程是这样一个工程。就是先从最后的具体服饰类开始往上逐个 装饰 的走。从具体服饰类到服饰类再到 Person 类。（可以从结果显示中看到这一过程）。 ​ ​ ​ 总结 ​ 装饰模式是为已有功能动态地添加更多功能的一种方式，装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有条件地，按顺序地使用装饰功能包装对象了【DP】 ​ （优点：把类中的装饰功能从类中搬除去除，这样可以简化原有的类。这样做的更大的好处是有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。） ​ 四 、代理模式（Proxy）​ 为其他对象提供一种代理以控制对这个对象的访问。【DP】 ​ 代理模式结构图 ​ ​ 注释 ​ 大概的意思就是，有一个公共的接口。中间代理和实际实体两者都实现接口的方法。当具体操作的时候，用代理操作，在代理内部实现实际方法的实例化操作来间接的替代实际方法。 ​ 应用场合 ​ 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。这样就可以达到性能的最优化，比如打开一个很大的 HTML 页面，虽然有很多图片但是还是能很快的打开它，此时看到的是文字，图片是一张一张的下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。其实，浏览器当中是用代理模式来优化下载的。 安全代理，用来控制真实对象访问时的权限[DP]。一般用于对象应该有不同的访问权限的时候。 智能指引，是指当调用真实的对象时，代理处理另外一些事情[DP]。如计算真实对象的引用次数，当该对象没有引用时，可以自动释放它: 或当第一次引用一个持久对象时，将它装入内存: 或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 ​ 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ​ 五 、工厂方法模式​ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 ​ 工厂方法模式 ，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。[DP] ​ ​ 工厂方法模式具体实现示例图 ​ ​ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。 ​ ​ ​ 六 、原型模式​ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP]. ​ 原型模式结构图 ​ ​ 注释 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。 ​ 原型模式中一般在初始化的信息不发生变化的情况下，克隆时最好的办法。这即隐藏了对象创建的细节，又对性能是大大的提高。同样也不用重新初始化对象，而是动态地获得对象运行时的状态。 ​ ‘浅复制’: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 ‘深复制’: 深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ​ 声明：这一模式，本人看的不是太懂。感觉有些东西不通。下面会有一个详细的例子，可以参考一下。不解释。 ​ 简历的深复制实现 ​ ​ ​ ​ ​ ​ 七 、模板方法模式​ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板模式方法处理。 ​ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP] ​ ​ 模板方法模式特点 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现其优势。 提供了一个很好的代码复用平台 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。 ​ 八、迪米特法则​ 迪米特法则（LoD）/ 最少知识原则[J&amp;DP]: 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。[J&amp;DP] ​ 九 、外观模式​ 外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] ​ ​ 十 、 建造者模式​ 建造者模式（Builder）: 将一个复杂对象的建造与它的表示分离，使得同样的建造过程可以创建不同的表示[DP] ​ 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ ​ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。 ​ 十一 、观察者模式​ 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己[DP]。 ​ ​ 观察者模式特点​ 当一个对象的改变需要同时改变其他对象时而且它并不知道具体有多少对象有待改变时，应该考虑使用观察中模式。 ​ 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将两者封装在独立的对象中使他们各自独立的改变和复用。 ​ 委托[这段有点突兀，我理解的大概意思是把观察者也抽象了，直接委托具体的类去实现观察类的抽象。] ​ 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 ​ 十二、抽象工厂模式​ 抽象工厂模式（Abstract Factory）, 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。[DP] ​ ​ 百度云链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (二)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[十三 、状态模式 状态模式（State）, 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。（DP） 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 使用时机 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据它的状态改变它的行为时，就可以考虑使用状态模式了。 [此处应有（meiyou）代码(zi ji kan)] 十四 、 适配器模式 适配器模式（Adapter）, 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP] 类适配器模式 通过多重继承对一个接口与另一个接口进行匹配，但大部分语言不支持多重继承（C++ 支持） 对象适配器模式 对象适配器模式结构图 代码示例 十五 、 备忘录模式 备忘录（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可将该对象恢复到原先保存的状态[DP]。 [DP] 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来[DP]. 当角色的状态改变时，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 十六 、 组合模式 组合模式（Composite）: 将对象组合成树形结构以表示‘部分 - 整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。[DP] 》接口是一种约束 十七 、 迭代器模式 迭代器模式（Iterator）: 提供了一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。[DP] foreach 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据 十八 、 单例模式 单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。[DP] 通常我们可以用一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的办法。[DP] 十九、 桥接模式 继承的麻烦 对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新问题，则父类必须重写或被其他更换的类替换。这种依赖关系限制了灵活性并最终限制了复用性。[DP] 在面向对象设计中，我们有一个很重要的设计原则，那就是合成 / 聚合复用原则。即优先使用对象合成 / 聚合，而不是类继承。[DP] 合成 / 聚合复用原则(CARP): 尽量使用合成 / 聚合，尽量不要使用类继承。[J&amp;DP] 聚合表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分: 合成表示一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]（看图） 好处 优先使用对象的合成 / 聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。[DP] 桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 二十、 命令模式 命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化; 对请求进行排队或记录请求日志，以及支持可撤销的操作。[DP] 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记入日志 允许接受请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他的类，因此增加的新的具体命令类很容易。 命令模式把请求一个操作的对象与知道怎样执行一个操作的对象分隔开[DP] ​ 二十一、 责任链模式 责任链模式（Chain of Responsibility）: 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[DP] 职责连的好处 可简化对象的互相连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。[DP] 可随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性[DP] 二十二、 中介者模式 中介者模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 应用场景 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 二十三 、享元模式 享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象[DP] 优点 享元模式可以避免大量相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。[减少对象的实例化数量] 二十四、 解释器模式 解释器模式（Interpreter）: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP] 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题[DP] (正则表达式是它的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式) 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式[DP] 解释器模式可以很容易地改变或扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。其也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写[DP] 举个例子就是人工智能机器人，机器人把人的具体指令解释成相应的行为。 二十五、 访问者模式 访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它可以使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作[DP] 访问者模式应用 适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 访问者模式使得增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式通常都会使增加新的数据结构变化困难。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (四)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[面向对象基础 类的定义: 类就是具有相同的属性和功能的对象的抽象的集合。构造方法: 只针对于 JAVA 实例化 :对类进行实例化，构造方法与类同名，无返回值，也不需要 void, 在 new 时候调用。 构造方法 :所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了。 方法重载 :方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型。 属性和修饰符 :属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。[属性的名称一般首字母大写，而字段则一般首字母小写或前加‘_’]。（字段和属性时不同的。属性是特殊的方法，可以给对应的字段赋值） 属性有两个方法 get 和 set。get 访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用。set 访问器没有显示设置参数，但它有一个隐式参数，用关键字 value 表示，它的作用是调用属性时可以给内部的字段或引用赋值。 封装 :每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。 继承 子类拥有父类非 private 的属性和功能。 子类具有自己的属性和功能。 子类还可以以自己的方式实现父类的功能（方法重写）。 子类构造方法需要调用父类同样参数类型的构造方法，用 base 关键字代表父类。（对于构造方法，其不能被继承，只能被调用） 继承显然是一种类与类之间的强耦合的关系。 多态 :多态表示不同的对象可以执行相同的动作。但要通过它们自己的实现代码来执行。 添加（virtual）关键字虚拟化父类的成员。子类可以选择使用（override）关键字，将父类实现替换为它自己的实现，这就是方法重写 Override, 或者叫做方法覆写。 原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。[AMNFP] 抽象类 : 抽象类不能实例化。 抽象方法是必须被子类重写的方法。（抽象方法可以被看作是没有实现体的虚方法） 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类[J&amp;DP] 接口 :接口是把隐式公共方法和属性结合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。 不能实例化。不能有构造方法和字段。不能有修饰符。不能声明虚拟的或静态的。 声明接口在语法上与声明抽象类完全不同，但不允许提供接口中任何成员的执行方式。 实现接口的类就必须要实现接口中的所有方法和属性。 接口的命名，前面要加一个大写字母’I’(规范) 抽象类和接口的区别 形态上来说​ 抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口。 设计模式上来说​ 1. 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，他们的共性就是抽象 ​ 2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。 ​ 3. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛华出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。 ​ 4.[抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的] 泛型 :泛型是具有占位符（类型参数）的类、接口、和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符：类型参数作为其字段的类型或其方法的参数类型出现[MSDN]。 不是太懂，来个例子，自己领会吧:sad: 以下文字概念反正我没太懂 通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基结合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱[MSDN]。 委托和事件 :委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程[PC#] 委托对象用关键字 delegate 来声明，而事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。事件用 event 关键字声明。 主要参考文献 [DP] 《设计模式：可复用面向对象软件的基础》 [DPE] 《设计模式解析》 [ASD] 《敏捷软件开发：原则、模式和实践》 [RIDEC] 《重构–改善既有代码的设计》 [J&amp;DP] 《Java 与模式》 [R2P] 《重构与模式》 [Head First Design Patterns] ​ 再次贴上百度云代码链接 相关代码]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 安全]]></title>
    <url>%2F2017%2F08%2F26%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[WEB 安全笔记 根本原则：数据与代码分离 同源策略1. 当 JS 被浏览器认为来自不同源是，请求被拒绝。2. 影响同源策略的因素 host(域名，IP 地址，子域名，端口和协议)。3.EXCEPT：script . img .iframe . link 标签可跨区加载资源而不受同源策略的影响。（原因是都带着 src 属性） 攻击手段类型 1. XSS 跨站脚本攻击 总的来说就是引用上面描述的不受同源策略影响的标签引入不合法的代码来进行攻击主要有四种 反射型 XSS 存储型 XSS DOM Based XSS XSS Payload Cookie 劫持攻击等 2. CSRF Cross Site Request Forgery 跨站点请求伪造 风险在于那些通过基于受信任的输入 form 和对特定行为无需授权的已认证的用户来执行某些行为的 web 应用。已经通过被保存在用户浏览器中的 cookie 进行认证的用户将在完全无知的情况下发送 HTTP 请求到那个信任他的站点，进而进行用户不愿做的行为。使用图片的 CSRF 攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用 JavaScript。 –百度百科 3.Click Jacking 点击劫持 点击劫持，clickjacking，也被称为 UI- 覆盖攻击。这个词首次出现在 2008 年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了 HTML 中 iframe 标签的透明属性。 4.SQL 注入 盲注（Blind Injection） 攻击存储过程 编码问题 Session 劫持 如果 SessionID 是保存在 cookie 中的，则这种攻击称为 cookie 劫持 Session Fixation（固定） 攻击：在用户登录网站的过程中，如果登陆前后用户的 sessionID 没有发生变化，则会存在 session fixation 问题 预防 SQL 注入的方式1. 使用预编译语句，绑定变量2. 使用存储过程3. 检查数据类型4. 使用安全函数 5.OAuth（单纯的名词解释）OAuth 是一个在不提供用户名密码的情况下授权第三方应用访问 web 资源的安全协议。 6. 绕过文件上传检查功能 1230x00 被认为是终止符[\0] 为十六进制的 0x00 字符 会利用上述特性截端字符串为脚本语言。 设计安全的文件上传功能1. 文件上传的目录设置为不可执行2. 判断文件类型3. 使用随机数改写文件名和文件路径4. 单独设置文件服务器的域名 在加密算法的选择和使用上 有一些建议1，不要使用 ECB 模式。2，不要使用流密码比如 RC4.3，使用 HMAC-SHAI 代替 MD5(甚至是 SHAI).4, 不要使用相同的 key 做不同的事情。5，salts 与 IV 需要随机产生。6，不要自己实现加密算法，尽量使用安全专家已经实现好的库7，不要依赖系统的保密性。 当不知道如何选择时1，使用 CBC 模式的 AES256 用于加密。2. 使用 HMAC-SHA512 用于完整性检查。3，使用带 salt 的 SHA-256 或 SHA-512 用于 Hashing. 7.DDOS 分布式拒绝服务 Distributed Denial of Service 最主要的便是限制请求频率，比如无限占用 http 请求，缓慢多次发送 http 请求。 Slowloris 攻击 1 以极低的速度往服务器发送 HTTP 请求，在正常的 HPPT 包头中，是以两个 CLRF（\r\n\r\n）表示 HTTP Headers 部分结束的。 HTTP POST DOS1在发送 HTTP POST 包是，指定一个非常大的 Content-Length 值，然后以很低的速度发包，比如 10~100s 发一个字节，保持住这个链接不断开。 Server Limit Dos1（Apache 所能接受的最大 HTTP 包头大小为 8192 字节（request header） request body 默认最大限制为 2GB）超过指定大小服务器会返回一个 4xx 错误。 正则 ReDOS1一种代码实现上的缺陷，正则表达式写的不好，有可能被恶意输入利用，消耗大量资源，从而造成 DOS。 小结 1 应用层拒绝服务攻击是传统的网络拒绝服务攻击的一种选择，本质也是对有限资源的无限滥用所造成的，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。 8. PHP 安全 文件包含漏洞 常见的导致文件包含的函数如下：PHP：include,require,fopen(),readfile();(PHP 内核并不会在意被包含的文件是什么类型)要想成功利用文件包含漏洞，需要满足下面两个条件： include()等函数通过动态变量的方式引入需要包含的文件。 用户能够控制该动态变量。 本地文件包含（LFI）能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞。PHP 配置设置 open_basedir 的作用是限制在某个特定目录下 PHP 能打开的文件，其作用与 safe_mode 是否开启无关。 远程文件包含PHP 的配置选项 allow_url_include 为 ON 的话，则 inlude/require 函数是可以远程加载文件的（RFI）。 PHP 会为上传文件创建临时文件，其目录在 php.ini 的 upload_tmp_dir 中定义，但改值默认为空，此时在 Linux 下回使用 /tmp 目录，在 Windows 下会使用 C:\windows\temp 目录。 变量覆盖漏洞 全局变量覆盖register_globals PHP 配置文件 unset()默认只会销毁局部变量，而要销毁全局变量必须使用 $GLOBALS; extract()变量覆盖 extract() 函数能将变量从数组导入当前的符号表。 遍历初始化变量 常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖（按下不表）。 import_request_variables 变量覆盖 次函数将 GET,POST,Cookie 中的变量导入到全局。 parse_str()变量覆盖 parse_str() 函数往往被用于解析 URL 的 query string.eg. 123$var = &apos;init&apos;;parse_str($_SERVER[&apos;QUERY_STRING&apos;]);print $var; 防止变量覆盖的安全建议 确保 register_globals = OFF, 若不能自定义 php.ini, 则应该在代码中控制。 熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。 养成初始换变量的好习惯。 代码执行漏洞 phpMyAdmin3.4.3.1 远程代码执行漏洞 MyBB 1.4 远程代码执行漏洞 挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用过程中用户是否有可能控制输入。 “文件写入”执行代码 其他执行代码方式 直接执行代码函数 eval(),assert(),exec(),shell_exec() 文件包含 本地文件写入 preg_replace()代码执行 preg_replace() 的第一个参数如果存在 /e 模式修饰符，则许代码执行。 动态函数执行 Curly Syntax {}将执行花括号间的代码，并将结果替换回去。 回调函数执行代码 unserialize()将导致代码执行 能将序列化的数据重新映射为 PHP 变量。 定制安全的 PHP 环境 register_globals = ON. open_basedir = /home/web/html/(指定目录) allow_url_include = offallow_url_fopen = off. display_errors = off log_errors = on magic_quotes_gpc = OFF. cgi.fix_pathinfo = 0(如果 PHP 以 CGI 的方式安装，则需要关闭此项，以避免出现文件解析问题) session.cookie_httponly = 1 session.cookie_secure = 1. sefe_mode disable_functions 能够在 PHP 中禁用函数disable_functions = eg… 10. WEB SERVER 配置安全 主要有五个方面（详略）1.apache 安全 2.nginx 安全3.jBoss 远程命令执行4.Tomcat 远程命令执行5.HTTP Parameter Pollution(通过 GET 或 POST 向服务器发起请求时，提交两个相同的参数) 入侵检测 常见的安全监控产品有 IDS(入侵检测系统)，IPS(入侵防御系统)，DDOS 监控设备。WAF(web 应用防火墙) ModSecurity:Apache 的一个 Module. 他能获取到所有的访问 Apache Httpd Server 的请求，并根据自己的规则对这些请求进行匹配，以检测那些请求存在攻击行为。 1声明：纯手打总结，劳动不易，转载请附上原文链接。谢谢支持]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>web 安全 协议 HTTP</tag>
      </tags>
  </entry>
</search>
