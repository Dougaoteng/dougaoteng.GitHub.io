<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 优化篇（二）]]></title>
    <url>%2F2017%2F11%2F12%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[优化数据库对象 优化表的数据类型 ​ 使用 PROCEDURE ANALYSE() 对当前已有应用的表类型的判断，该函数可 以对数据表中的列的数据类型提出优化建议，可以根据应用的实际情况酌情考虑是否实施优 化。12SELECT * FROM tbl_name PROCEDURE ANALYSE();SELECT * FROM tbl_name PROCEDURE ANALYSE(16,256); ​ 输出的每一列信息都会对数据表中的列的数据类型提出优化建议。第二个例子告诉 PROCEDURE ANALYSE()不要为那些包含的值多于 16 个或者 256 字节的 ENUM 类型提出建议。如果没有这样的限制，输出信息可能很长;ENUM 定义通常很难阅读。 通过拆分，提高表的访问效率 主要是针对 Myisam 类型的表，拆分的方法可以分成两种情况: 纵向拆分: 纵向拆分是只按照应用访问的频度，将表中经常访问的字段和不经常访问的字段拆分成两个表，经常访问的字段尽量是定长的，这样可以有效的提高表的查询和更新的效率。 横向拆分: 横向拆分是指按照应用的情况，有目的的将数据横向拆分成几个表或者通过分区分到多个分区中，这样可以有效的避免 Myisam 表的读取和更新导致的锁问题。 逆规范化​ 数据库的规范化设计强调数据的独立性，数据应该尽可能少地冗余，因为存在过多的冗余数据，这就意味着要占用了更多的物理空间，同时也对数据的维护和一致性检查带来了问题。 但是对于查询操作很多的应用，一次查询可能需要访问多表进行，如果通过冗余纪录在相同表中，更新的代价增加不多，但是查询操作效率可以有明显提高，这种情况就可以考虑通过冗余数据来提高效率。 使用冗余统计表​ 使用 create temporary table 语法，它是基于 session 的表，表的数据保存在内存里面，当 session 断掉后，表自然消除。 ​ 对于大表的统计分析，如果统计的数据量不大，利用 insert。。。 select 将数据移到临时表中比直接在大表上做统计要效率更高。 选择更合适的表类型 如果应用出现比较严重的锁冲突，请考虑是否更改存储引擎到 innodb，行锁机制可以有效的减少锁冲突的出现。 如果应用查询操作很多，且对事务完整性要求不严格，则可以考虑使用 Myisam 存储引擎。 锁问题 获得锁等待情况 可以通过检查 table_locks_waited 和 table_locks_immediate 状态变量来分析系统上的表锁定争夺: 12mysql&gt; show status like &apos;Table%&apos;; +----------------------------+----------+ | Variable_name | Value | +----------------------------+----------+ | Table_locks_immediate | 105 || Table_locks_waited | 3 | +----------------------------+----------+ 2 rows in set (0.00 sec) 可以通过检查 Innodb_row_lock 状态变量来分析系统上的行锁的争夺情况: 123456789mysql&gt; show status like &apos;innodb_row_lock%&apos;; +----------------------------------------+----------+| Variable_name | Value | +----------------------------------------+----------+| Innodb_row_lock_current_waits | 0 || Innodb_row_lock_time | 2001 || Innodb_row_lock_time_avg | 667 || Innodb_row_lock_time_max | 845 || Innodb_row_lock_waits | 3 |+----------------------------------------+----------+5 rows in set (0.00 sec) 另外，针对 Innodb 类型的表，如果需要察看当前的锁等待情况，可以设置 InnoDBMonitors，然后通过 Show innodb status 察看，设置的方式是: 1CREATE TABLE innodb_monitor(a INT) ENGINE=INNODB; 监视器可以通过发出下列语句来被停止: 1DROP TABLE innodb_monitor; 什么情况使用表锁 很多操作都是读表。 在严格条件的索引上读取和更新，当更新或者删除可以用单独的索引来读取得到时: UPDATE tbl_name SET column=value WHERE unique_key_col=key_value; DELETE FROM tbl_name WHERE unique_key_col=key_value; SELECT 和 INSERT 语句并发的执行，但是只有很少的 UPDATE 和 DELETE 语句。 很多的扫描表和对全表的 GROUP BY 操作，但是没有任何写表。 什么情况使用行锁 行级锁定的优点: 当在许多线程中访问不同的行时只存在少量锁定冲突。 回滚时只有少量的更改。 可以长时间锁定单一的行。 行级锁定的缺点: 比页级或表级锁定占用更多的内存。 当在表的大部分中使用时，比页级或表级锁定速度慢，因为你必须获取更多的锁。 如果你在大部分数据上经常进行 GROUP BY 操作或者必须经常扫描整个表，比其它锁定 明显慢很多。 用高级别锁定，通过支持不同的类型锁定，你也可以很容易地调节应用程序，因为其锁 成本小于行级锁定。 如何减少锁冲突 对 Myisam 类型的表： Myisam 类型的表可以考虑通过改成 Innodb 类型的表来减少锁冲突。 根据应用的情况，尝试横向拆分成多个表或者改成 Myisam 分区对减少锁冲突也会有一定的帮助。 对 Innodb 类型的表 首先要确认，在对表获取行锁的时候，要尽量的使用索引检索纪录，如果没有使用索引访问，那么即便你只是要更新其中的一行纪录，也是全表锁定的。要确保 sql 是使用索引来访问纪录的，必要的时候，请使用 explain 检查 sql 的执行计划，判断是否按照预期使用了索引。 由于 mysql 的行锁是针对索引加的锁，不是针对纪录加的锁，所以虽然是访问不同行的纪录，但是如果是相同的索引键，是会被加锁的。应用设计的时候也要注意，这里和 Oracle 有比较大的不同。 当表有多个索引的时候，不同的事务可以使用不同的索引锁定不同的行，当表有主键或者唯一索引的时候，不是必须使用主键或者唯一索引锁定纪录，其他普通索引同样可以用来检索纪录，并只锁定符合条件的行。 用 SHOW INNODB STATUS 来确定最后一个死锁的原因。查询的结果中，包括死锁的事务的详细信息，包括执行的 SQL 语句的内容，每个线程已经获得了什么锁，在等待什么锁，以及最后是哪个线程被回滚。详细的分析死锁产生的原因，可以通过改进程序有效的避免死锁的产生。 如果应用并不介意死锁的出现，那么可以在应用中对发现的死锁进行处理。 确定更合理的事务大小，小事务更少地倾向于冲突。 如果你正使用锁定读，(SELECT … FOR UPDATE 或 … LOCK IN SHARE MODE)，试着用更低的隔离级别，比如 READ COMMITTED。 以固定的顺序访问你的表和行。则事务形成良好定义的查询并且没有死锁。 优化 Mysql Server影响 Mysql 性能的重要参数 key_buffer_size 键缓存 (变量 key_buffer_size) 被所有线程共享; 服务器使用的其它缓存则根据需要分配。此参数只适用于 myisam 存储引擎。 下面的语句将表 t1、t2 和 t3 的索引分配给名为 hot_cache 的 键高速缓冲: 1mysql&gt; CACHE INDEX t1, t2, t3 IN hot_cache; 可以用 SET GLOBAL 参数设置语句或使用服务器启动选项设置在 CACHE INDEX 语句中引用的键高速缓冲的大小来创建键高速缓冲。 1mysql&gt; SET GLOBAL keycache1.key_buffer_size=128*1024; 要想删除键高速缓冲，将其大小设置为零: 1mysql&gt; SET GLOBAL keycache1.key_buffer_size=0; 请注意不能删除默认键高速缓冲。删除默认键高速缓冲的尝试将被忽略 如果你很少使用 MyISAM 表，那么也保留低于 16-32MB 的 key_buffer_size 以适应给予磁盘的临时表索引所需。 Table_cache ​ 数据库中打开表的缓存数量。table_cache 与 max_connections 有关。例如，对于 200 个并行运行的连接，应该让表的缓存至少有 200 * N，这里 N 是可以执行的查询的一个联接中表的最大数量。还需要为临时表和文件保留一些额外的文件描述符。 设置技巧： ​ 可以通过检查 mysqld 的状态变量 Opened_tables 确定表缓存是否太小: 123456mysql&gt; SHOW STATUS LIKE &apos;Opened_tables&apos;;+---------------+-------+| Variable_name | Value |+---------------+-------+| Opened_tables | 2741 |+---------------+-------+ 如果值很大，即使你没有发出许多 FLUSH TABLES 语句，也应增加表缓存的大小。 innodb_buffer_pool_size 的设置 缓存 InnoDB 数据和索引的内存缓冲区的大小。你把这个值设得越高，访问表中数据需要得磁盘 I/O 越少。在一个专用的数据库服务器上，你可以设置这个参数达机器物理内存大小的 80%。尽管如此，还是不要把它设置得太大，因为对物理内存的竞争可能在操作系统上导致内存调度。 innodb_table_locks InnoDB 重视 LOCK TABLES，直到所有其它线程已经释放他们所有对表的锁定，MySQL 才从 LOCK TABLE .. WRITE 返回。默认值是 1，这意为 LOCK TABLES 让 InnoDB 内部锁定一个表。在使用 AUTOCOMMIT=1 的应用里，InnoDB 的内部表锁定会导致死锁 。可以通过设置 innodb_table_locks=0 来消除这个问题。 innodb_lock_wait_timeout Mysql 可以自动的监测行锁导致的死锁并进行相应的处理，但是对于表锁导致的死锁不能自动的监测，所以该参数主要被用来在出现类似情况的时候对锁定进行的后续处理。默认值是 50 秒，根据应用的需要进行调整。 innodb_doublewrite 默认地，InnoDB 存储所有数据两次，第一次存储到 doublewrite 缓冲，然后存储到确实的数据文件。如果对性能的要求高于对数据完整性的要求，那么可以通过–skip-innodb-doublewrite 关闭这个设置。 innodb_log_buffer_size 默认的设置在中等强度写入负载以及较短事务的情况下，服务器性能还可以。如果存在更新操作峰值或者负载较大，就应该考虑加大它的值了。如果它的值设置太高了，可能会浪费内存 – 它每秒都会刷新一次，因此无需设置超过 1 秒所需的内存空间。通常 8-16MB 就足够了。越小的系统它的值越小。 innodb_log_file_size 在高写入负载尤其是大数据集的情况下很重要。这个值越大则性能相对越高，但是要注意到可能会增加恢复时间。 I/O 问题 使用磁盘阵列或虚拟文件卷分布 I/O使用 Symbolic Links 分布 I/O​ 可以将表和数据库从数据库目录移动到其它的位置并且用指向新位置的符号链接进行替换。推荐的方法只需要将数据库通过符号链接指到不同的磁盘。符号链接表仅作为是最后的办法。 ​ 符号链接一个数据库的方法是，首先在一些有空闲空间的硬盘上创建一个目录，然后从 MySQL 数据目录中创建它的一个符号链接。 12shell&gt; mkdir /dr1/databases/testshell&gt; ln -s /dr1/databases/test /path/to/datadir 注意: 只有 MyISAM 表完全支持符号链接。对于其它表类型，如果试图在操作系统中 的文件上用前面的任何语句使用符号链接，可能会出现奇怪的问题。 应用优化 使用连接池 对于访问数据库来说，建立连接的代价比较昂贵，因此，我们有必要建立”连接池”以提高访问的性能。我们可以把连接当作对象或者设备，池中又有许多已经建立的连接，访问本来需要与数据库的连接的地方，都改为和池相连，池临时分配连接供访问使用，结果返回后，访问将连接交还。 减少对 Mysql 的访问 避免对同一数据做重复检索​ 应用中需要理清楚对数据库的访问逻辑，需要对相同表的访问，尽量集中在相同 sql 访问，一次提取结果，减少对数据库的重复访问。 使用 mysql query cache​ 作用：查询缓存存储 SELECT 查询的文本以及发送给客户端的相应结果。如果随后收到一个相同的查询，服务器从查询缓存中重新得到查询结果，而不再需要解析和执行查询。 ​ 使用范围：不发生数据更新的表。当表更改 (包括表结构和表数据) 后，查询缓存值 的相关条目被清空。 ​ 参数描述： ​ show variables like ‘%query_cache%’; ​ have_query_cache 表明服务器在安装使已经配置了高速缓存​ query_cache_size 表明缓存区大小，单位为 M ​ query_cache_type 的变量值从 0 到 2，含义分别为 ​ 0 或者 off(缓存关闭) ​ 1 或者 on(缓存打开，使用 sql_no_cache 的 select 除外) ​ 2 或者 demand(只有带 sql_cache 的 select 语句提供高速缓存) 在 SHOW STATUS 中，你可以监视查询缓存的性能: 变量 含义 Qcache_queries_in_cache 在缓存中已注册的查询数目 Qcache_inserts 被加入到缓存中的查询数目 Qcache_hits 缓存采样数数目 Qcache_lowmem_prunes 因为缺少内存而被从缓存中删除的查询数目 Qcache_not_cached 没有被缓存的查询数目 (不能被缓存的，或由于 QUERY_CACHE_TYPE) Qcache_free_memory 查询缓存的空闲内存总数 Qcache_free_blocks 查询缓存中的空闲内存块的数目 Qcache_total_blocks 查询缓存中的块的总数目 加 cache 层 ​ Cache(高速缓存)、Memory(内存)、Hard disk(硬盘) 都是数据存取单元，但存取速度却有很大差异，呈依次递减的顺序。对于 CPU 来说，它可以从距离自己最近的 Cache 高速地存取数据，而不是从内存和硬盘以低几个数量级的速度来存取数据。而 Cache 中所存储的数据，往往是 CPU 要反复存取的数据，有特定的机制 (或程序) 来保证 Cache 内数据的命中率(Hit Rate)。因此，CPU 存取数据的速度在应用高速缓存后得到了巨大的提高。 ​ 因为将数据写入高速缓存的任务由 Cache Manager 负责，所以对用户来说高速缓存的内容肯定是只读的。需要你做的工作很少，程序中的 SQL 语句和直接访问 DBMS 时没有分别，返回的结果也看不出有什么差别。而数据库厂商往往会在 DB Server 的配置文件中提供与 Cache 相关的参数，通过修改它们，可针对我们的应用优化 Cache 的管理。 负载均衡​ 1. 利用 mysql 复制分流查询操作 ​ 利用 mysql 的主从复制可以有效的分流更新操作和查询操作，具体的实现是一个主服务器，承担更新操作，多台从服务器，承担查询操作，主从之间通过复制实现数据的同步。多台从服务器一方面用来确保可用性，一方面可以创建不同的索引满足不同查询的需要。 ​ 对于主从之间不需要复制全部表的情况，可以通过在主的服务器上搭建一个虚拟的从服务器，将需要复制到从服务器的表设置成 blackhole 引擎，然后定义 replicate-do-table 参数只复制这些表，这样就过滤出需要复制的 binlog，减少了传输 binlog 的带宽。因为搭建的虚拟的从服务器只起到过滤 binlog 的作用，并没有实际纪录任何数据，所以对主数据库服务器的性能影响也非常的有限。 ​ 通过复制分流查询的存在的问题是主数据库上更新频繁或者网络出现问题的时候，主从之 间的数据可能存在差异，造成查询结果的异议，应用在设计的时候需要有所考虑。 ​ 2. 采用分布式数据库架构 ​ mysql 从 5.0.3 开始支持分布式事务，当前分布式事务只对 Innodb 存储引擎支持。分布式的数据库架构适合大数据量，负载高的情况，有良好的扩展性和高可用性。通过在多台服务器之间分布数据实现在多台服务器之间的负载平均，提高了访问的执行效率。具体实现的时候，可以使用 mysql 的 Cluster 功能 (NDB 引擎) 或者自己编写程序来实现全局事务 。 ​ ​​​]]></content>
      <tags>
        <tag>Mysql Server 优化 锁 优化表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 优化篇（一）]]></title>
    <url>%2F2017%2F11%2F10%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E4%BC%98%E5%8C%96%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[SQL 优化 优化 SQL 的一般步骤 通过 show status 和应用特点了解各种 SQL 的执行频率 通过 SHOW STATUS 可以提供服务器状态信息， 也可以使用 mysqladmin extended- status 命令获得。SHOW STATUS 可以根据需要显示 session 级别的统计结果和 global 级别的统计结果。 Connections 试图连接 Mysql 服务器的次数 Uptime 服务器工作时间 Slow_queries 慢查询的次数 Com_select/Innodb_rows_read select 针对 Myisam 和 Innodb 存储引擎执行操作的次数，累加（包括批量操作）为 1. 对于事务型的应用，通过 Com_commit 和 Com_rollback 可以了解事务提交和回滚 的情况，对于回滚操作非常频繁的数据库，可能意味着应用编写存在问题。 定位执行效率较低的 SQL 语句 可以通过慢查询日志定位那些执行效率较低的 sql 语句，用–log-slow-queries[=file_name]选项启动时，mysqld 写一个包含所有执行时间超过 long_query_time 秒的 SQL 语句的日志文件。可以链接到管理维护中的相关章节。 慢查询日志在查询结束以后才纪录， 所以在应用反映执行效率出现问题的时候询查慢查询日志并不能定位问题，可以使用 show processlist 命令查看当前 MySQL 在进行的线程，包括线程的状态，是否锁表等等，可以实时的查看 SQL 执行情况，同时对一些锁表操作进行优化。 通过 EXPLAIN 分析低效 SQL 的执行计划 ​ 可以通过 explain 或者 desc 获取 MySQL 如何执行 SELECT 语句的信息， 包括 select 语句执行过程表如何连接和连接的次序。 ​ explain 可以知道什么时候必须为表加入索引以得到一个使用索引来寻找记录的更快的 SELECT。 1234567891011121314mysql&gt; explain select sum(moneys) from sales a,companys b where a.company_id =b.id and a.year = 2006;+----------------+----------+-----------+----------------+----------------+--------- -+-----------+----------------+| select_type | table | type | possible_keys| key | key_len | rows | Extra |+----------------+----------+-----------+----------------+----------------+----------+-----------+----------------+网易技术部47www.163.com | SIMPLE | b | index | PRIMARY | PRIMARY | 4 | 1 | Using index || SIMPLE | a | ALL | NULL | NULL | NULL | 12 | Using where |+----------------+----------+-----------+----------------+----------------+--------- -+-----------+----------------+2 rows in set (0.02 sec) select_type: select 类型 table: 输出结果集的表 ​type: 表示表的连接类型 当表中仅有一行是 type 的值为 system 是最佳的连接类型; 当 select 操作中使用索引进行表连接时 type 的值为 ref; 当 select 的表连接没有使用索引时，经常会看到 type 的值为 ALL，表示对该表进行了全表扫描，这时需要考虑通过创建索引来提高表连接的效率。 possible_keys: 表示查询时, 可以使用的索引列. key: 表示使用的索引 key_len: 索引长度 rows: 扫描范围 Extra: 执行情况的说明和描述 确定问题，并采取相应的优化措施 ​ 经过以上步骤，基本可以确认问题出现的原因，可以根据情况采取相应的措施，进行优化提高执行的效率。 例如上面的例子，我们确认是对 a 表的全表扫描导致效率的不理想，我们对 a 表的 year 字段创建了索引，查询需要扫描的行数明显较少。 索引问题 如何使用索引​ 查询要使用索引最主要的条件是查询条件中需要使用索引关键字，如果是多列索引，那么只有查询条件使用了多列关键字最左边的前缀时，才可以使用索引，否则将不能使用索引。 下列情况下，Mysql 不会使用已有的索引: 如果 mysql 估计使用索引比全表扫描更慢，则不使用索引。例如: 如果 key_part1 均匀分布在 1 和 100 之间，下列查询中使用索引就不是很好:SELECT * FROM table_name where key_part1 &gt; 1 and key_part1 &lt; 90 如果使用 heap 表并且 where 条件中不用 = 索引列，其他 &gt; 、&lt;、 &gt;=、 &lt;= 均不使用索引; 如果不是索引列的第一部分; 如果 like 是以 % 开始; 对 where 后边条件为字符串的一定要加引号，字符串如果为数字 mysql 会自动转为字符串，但是不使用索引。 查看索引的使用情况1mysql&gt; show status like &apos;Handler_read%&apos;; ​ Handler_read_rnd_next 的值高则意味着查询运行低效，并且应该建立索引补救。这个值的含义是在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明表索引不正确或写入的查询没有利用索引。 索引优化 定期分析表 ANALYZE TABLE 1ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 本语句用于分析和存储表的关键字分布。在分析期间，使用一个读取锁定对表进行锁定。这对于 MyISAM, BDB 和 InnoDB 表有作用。对于 MyISAM 表，本语句与使用 myisamchk-a 相当。 CHECK TABLE 12CHECK TABLE tbl_name [, tbl_name] ... [option] ...option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125; 检查一个或多个表是否有错误。CHECK TABLE 对 MyISAM 和 InnoDB 表有作用。对于MyISAM 表，关键字统计数据被更新。 CHECK TABLE 也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。 CHECKSUM TABLE 1CHECKSUM TABLE tbl_name [, tbl_name] ... [QUICK | EXTENDED] 报告一个表校验和。 使用 optimize table 1OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... 如果已经删除了表的一大部分，或者如果您已经对含有可变长度行的表 (含有 VARCHAR, BLOB 或 TEXT 列的表) 进行了很多更改，则应使用 OPTIMIZE TABLE。被删除的记录被保持在链接清单中，后续的 INSERT 操作会重新使用旧的记录位置。您可以使用 OPTIMIZE TABLE 来重新利用未使用的空间，并整理数据文件的碎片。OPTIMIZE TABLE 只对 MyISAM, BDB 和 InnoDB 表起作用。 SQL 具体优化 大批量插入数据 对于 Myisam 类型的表，可以通过以下方式快速的导入大量的数据。 123ALTER TABLE tblname DISABLE KEYS;loading the dataALTER TABLE tblname ENABLE KEYS; 这两个命令用来打开或者关闭 Myisam 表非唯一索引的更新。在导入大量的数据到一 个非空的 Myisam 表时，通过设置这两个命令，可以提高导入的效率。对于导入大量 数据到一个空的 Myisam 表，默认就是先导入数据然后才创建索引的，所以不用进行 设置。 对于 Innodb 类型的表，这种方式并不能提高导入数据的效率。对于 Innodb 类型 的表，我们有以下几种方式可以提高导入的效率 因为 Innodb 类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果 Innodb 表没有主键，那么系统会默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这个优势提高导入数据的效率。 在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行 SETUNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。 如果应用使用自动提交的方式，建议在导入前执行 SET AUTOCOMMIT=0，关闭自动 提交，导入结束后再执行 SET AUTOCOMMIT=1，打开自动提交，也可以提高导入的效率。 优化 inser 语句 将索引文件和数据文件分在不同的磁盘上存放(利用建表中的选项); 如果进行批量插入，可以增加 bulk_insert_buffer_size 变量值的方法来提高速度，但是，这只能对 myisam 表使用; 当从一个文本文件装载一个表时，使用 LOAD DATA INFILE。这通常比使用很多 INSERT 语句快 20 倍; 根据应用情况使用 replace 语句代替 insert; 根据应用情况使用 ignore 关键字忽略重复记录。 如果你从不同客户插入很多行，能通过使用 INSERT DELAYED 语句得到更高的速度。Delayed 的含义是让 insert 语句马上执行，其实数据都被放在内存的队列中，并没有真正写入磁盘; 这比每条语句分别插入要快的多;LOW_PRIORITY 刚好相反，在所有其他用户对表的读写完后才进行插入; 如果你同时从同一客户插入很多行，使用多个值表的 INSERT 语句。这比使用分开 INSERT 语句快(在一些情况中几倍)。 1Insert into test values(1,2),(1,3),(1,4)... 优化 group by 语句 默认情况下，MySQL 排序所有 GROUP BY col1，col2，….。查询的方法如同在查询 中指定 ORDER BY col1，col2，…。如果显式包括一个包含相同的列的 ORDER BY子句，MySQL 可以毫不减速地对它进行优化，尽管仍然进行排序。如果查询包括 GROUP BY 但你想要避免排序结果的消耗，你可以指定 ORDER BY NULL禁止排序。 例如: 1SELECT a, COUNT(*) FROM bar GROUP BY a ORDER BY NULL; 优化 or 条件 对于 or 子句，如果要利用索引，则 or 之间的每个条件列都必须用到索引; 如果没有索引，则应该考虑增加索引。 Mysql 默认调度策略 写入操作优先于读取操作。 对某张数据表的写入操作某一时刻只能发生一次，写入请求按照它们到达的次序来处理。 对某张数据表的多个读取操作可以同时地进行。 MySQL 提供了几个语句调节符，允许你修改它的调度策略: LOW_PRIORITY 关键字应用于 DELETE、INSERT、LOAD DATA、REPLACE 和 UPDATE。 HIGH_PRIORITY 关键字应用于 SELECT 和 INSERT 语句。 DELAYED 关键字应用于 INSERT 和 REPLACE 语句。 使用 SQL 提示 当处理一个会让客户端耗费点时间才能处理的大结果集时，可以考虑使用 SQL_BUFFER_RESULT 提示字。这样可以告诉 MySQL 将结果集保存在一个临时表中，这 样可以尽早的释放各种锁。 USE INDEX 在你查询语句中表名的后面，添加 USE INDEX 来提供你希望 MySQ 去参考的索引列 表，就可以让 MySQL 不再考虑其他可用的索引。 1Eg:SELECT * FROM mytable USE INDEX (mod_time, name) ... IGNORE INDEX 如果你只是单纯的想让 MySQL 忽略一个或者多个索引，可以使用 IGNORE INDEX 作为 Hint。 1Eg:SELECT * FROM mytale IGNORE INDEX (priority) ... FORCE INDEX 为强制 MySQL 使用一个特定的索引，可在查询中使用 FORCE INDEX 作为 Hint。 1Eg:SELECT * FROM mytable FORCE INDEX (mod_time) ... 其他优化措施 使用持久的连接数据库以避免连接开销。 经常检查所有查询确实使用了必要的索引。 避免在频繁更新的表上执行复杂的 SELECT 查询，以避免与锁定表有关的由于读、写冲突发生的问题。 对于没有删除的行操作的 MyISAM 表，插入操作和查询操作可以并行进行，因为没有删除操作的表查询期间不会阻塞插入操作. 对于确实需要执行删除操作的表，尽量在空闲时间进行批量删除操作，避免阻塞其他操作。 充分利用列有默认值的事实。只有当插入的值不同于默认值时，才明确地插入值。这减 少 MySQL 需要做的语法分析从而提高插入速度。 对经常访问的可以重构的数据使用内存表，可以显著提高访问的效率。 通过复制可以提高某些操作的性能。可以在复制服务器中分布客户的检索以均分负载。为了防止备份期间对应用的影响，可以在复制服务器上执行备份操作。 表的字段尽量不使用自增长变量，在高并发情况下该字段的自增可能对效率有比较大的 影响，推荐通过应用来实现字段的自增长。]]></content>
      <tags>
        <tag>SQL优化 索引优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出 MySQL 数据库开发、优化与管理维护 - 开发篇（一）]]></title>
    <url>%2F2017%2F11%2F07%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91%E3%80%81%E4%BC%98%E5%8C%96%E4%B8%8E%E7%AE%A1%E7%90%86%E7%BB%B4%E6%8A%A4-%E5%BC%80%E5%8F%91%E7%AF%87%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Mysql 字符集介绍 ​ mysql 的字符集包括字符集(CHARACTER) 和校对规则 (COLLATION) 两个概念。字符集是用来定义 mysql 存储字符串的方式，校对规则则是定义了比较字符串的方式。字符集和校对规则是一对多的关系, MySQL 支持 30 多种字符集的 70 多种校对规则。每个字符集至少对应一个校对规则。 可以 S 用 HOW COLLATION LIKE ‘utf8%’; 命令查看相关字符集的校对规则。 Unicode 一种字符编码方法。 全名 ‘Universal Multiple-Octet Coded Character Set’ 简称 UCS。 字符集 选择字符集​ 通常建议在能够完全满足应用的前提下，尽量使用小的字符集。因为更小的字符集意味着能够节省空间，减少网络传输字节数，同时由于存储空间的较小间接的提高了系统的性能。 ​ 有很多字符集可以保存汉字，比如 utf8、gb2312、gbk、latin1 等等，但是常用的是 gb2312 和 gbk。因为 gb2312 字库比 gbk 字库小，有些偏僻字 (例如: 洺) 不能保存，因此在选择字符集的时候一定要权衡这些偏僻字在应用出现的几率以及造成的影响， 不能做肯出定答复的话最好选用 gbk。 Mysql 字符集的设置​ mysql 的字符集和校对规则有 4 个级别的默认设置: 服务器级、 数据库级、 表级和段字级。分别在不同的地方设置，作用也不相同。 服务器字符集和校对，在 mysql 服务启动的时候确定。可以在 my.cnf 中设置:[mysqld]default-character-set=utf8 或者在启动选项中指定:mysqld –default-character-set=utf8或者在编译的时候指定:./configure –with-charset=utf8 如果没有特别的指定服务器字符集，默认使用 latin1 作为服务器字符集。上面三种设置的方式都只指定了字符集， 没有指定校对规则， 这样是使用该字符集默认的校对规则如，果要使用该字符集的非默认校对规则，则需要在指定字符集的同时指定校对规则。 可以用 show variables like ‘character_set_server’; 命令查询当前服务器的字符集和校对规则。 索引的设计和使用​ 所有 MySQL 列类型可以被索引。对相关列使用索引是提高 SELECT 操作性能的最佳途径。 根据存储引擎定义每个表的最大索引数和最大索引长度。 所有存储引擎支持每个表少至 16 个索引，总索引长度至少为 256 字节。大多数存储引擎有更高的限制。 ​ 还可以创建 FULLTEXT 索引。该索引可以用于全文搜索。只有 MyISAM 存储引擎支持 FULLTEXT 索引，并且只为 CHAR、VARCHAR 和 TEXT 列。索引总是对整个列进行，不支持局部 (前缀) 索引。也可以为空间列类型创建索引。只有 MyISAM 存储引擎支持空间类型。空间索引使用 R- 树。默认情况 MEMORY(HEAP)存储引擎使用 hash 索引，但也支持 B- 树索引。 设计索引的原则 搜索的索引列， 不一定是所要选择的列。 换句话说， 最适合索引的列是出现在 WHERE 子句中的列， 或连接子句中指定的列， 而不是出现 S 在 ELECT 关键字后的选择列表中的列。 使用惟一索引。 考虑某列中值的分布。 对于惟一值的列， 索引的效果最好， 而具有多个重复值的列，其索引效果最差。例如，存放年龄的列具有不同值，很容易区分 各行。而用来记录性别的列，只含有“ M”和“F”，则对此列进行索引没有多大用处(不管搜索哪个值，都会得出大约一半的行) 使用短索引。 如果对串列进行索引， 应该指定一个前缀长度， 只要有可能就应该这做。样例如，如果有一个 CHAR(200) 列，如果在前 10 个或 20 个字符内，多数值是惟一的，那么就不要对整个列进行索引。对前 10 个或 20 个字符进行索引能够节省大量索引空间，也可能会使查询更快。较小的索引涉及的磁盘 I/O 较少，较短的值比较起来更快。更为重要的是， 对于较短的键值， 索引高速缓存中的块能容纳更多的键值， 因 M 此 yS，QL 也可以在内存中容纳更多的值。这增加 了找到行而不用读取索引中较多块的可能性。 (当然， 应该利用一些常识。 如仅用列值的一第个字符进行索引是不可能有多大好处的，因为这个索引中不会有许多不 同的值。) 利用最左前缀。在创建 一个 n 列的索引时，实际是创建了 MySQL 可利用的 n 个索引。多列索引可起几个索引的作用， 因为可利用索引中最左边的列集来匹配行。 这样的集列称为最左前缀。 (这与索引一个列的前缀不同，索引一个列的前缀是利用该的 n 前个字符作为索引值。) 不要过度索引。 不要以为索引“越多越好”， 什么东西都用索引是错的。 每个额外的索引都要占用额外的磁盘空间，并降低写操作的性能，这一点我们前面已经介绍 过。在修改表的内容时， 索引必须进行更新， 有时可能需要重构， 因此， 索引越多， 所花时的间越长。如果有一个索引很少利用或从不使用，那么会不必要地减缓表 的修改速度。此外，MySQL 在生成一个执行计划时，要考虑各个索引，这也要费时间。创建多余的索引给查询优化带来了更多的工作。索引太多，也可能会使 MySQL 选择不到所要使用的最好索引。 只保持所需的索引有利于查询优化。 如果想给已索引的表增加索引， 应考该虑所要增加的索引是否是现有多列索引的最左 索引。如果是，则就不要费力去增加这个索引了，因为已经有了。 考虑在列上进行的比较类型。索引可用于“ &lt;”、“ &lt; = ”、“ = ”、“ &gt; =”、“ &gt;”和 BETWEEN 运算。在模式具有一个直接量前缀时，索引也用于 LIKE 运算。如果只 将某个列用于其他类型的运算时(如 STRCMP()) ，对其进行索引没有价值 Myssql 如何使用索引 索引用于快速找出在某个列中有一特定值的行。不使用索引，MySQL 必须从第 1 条记录开始然后读完整个表直到找出相关的行。 表越大， 花费的时间越多。 如果表中查询的有列一个索引，MySQL 能快速到达一个位置去搜寻到数据文件的中间，没有必要看所有数据。如果一个表有 1000 行，这比顺序读取至少快 100 倍。注意如果你需要访问大部分行，顺序读取要快得多，因为此时我们避免磁盘搜索。 大多数 MySQL 索引 (PRIMARY KEY、UNIQUE、INDEX 和 FULLTEXT) 在 B 树中存储。只是空间列类型的索引使用 R- 树，并且 MEMORY 表还支持 hash 索引。 锁机制和事务控制 如何加锁和解锁 锁定表的语法:LOCK TABLES123tbl_name [AS alias] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125;[, tbl_name [AS alias] &#123;READ [LOCAL] | [LOW_PRIORITY] WRITE&#125;] ... 解锁语法:1UNLOCK TABLES innodb 的存储引擎提供行级锁，支持共享锁和排他锁两种锁定模式，以及四种不同的隔离级别。 死锁​ InnoDB 自动检测事务的死锁， 并回滚一个或几个事务来防止死锁 In。noDB 不能在 MySQL LOCK TABLES 设定表锁定的地方或者涉及 InnoDB 之外的存储引擎设置锁定的地方检测死锁。你必须通过设定 innodb_lock_wait_timeout 系统变量的值来解决这些情况。 如果要依靠等锁待超时来解决死锁问题， 对于更新事务密集的应用， 将有可能导致大量事务的锁等待，致导系统异常， 所以不推荐在一个事务中混合更新不同存储类型的表， 也不推荐相同类型的采表用不同的锁定方式加锁。 事务控制​ 当开始一个事务时，会造成一个隐含的 unlock tables 被执行。因此， 在同一个事务中， 最好不使用不同存储引擎的表， 否 r 则 ollback 时需要对非事务类型的表进行特别的处理，因为 commit、rollback 只能对事务类型的表进行提交和回滚。 ​ 在事务中可以通过定义 savepoint，指定回滚事务的一个部分，但是不能指定提交事务的一个部分。对于复杂的应用，可以定义多个不同的 savepoint，满足不同的条件时，回滚不同的 savepoint。需要注意的是，如果定义了相同名字的 savepoint，则后面定义的 savepoint 会覆盖之前的定义。 对于不再需要使用 s 的 avepoint， 可以通过 release savepoint 命令删除 savepoint，删除后 savepoint，不能再执行 rollback to savepoint 命令。 SQL Mode 及相关问题 SQL Mode 简介​ 通常在 linux 下安装完 mysql 后，默认的 sql-mode 值是空，在这种情形下 mysql 执行的是一 种不严格的检查，例如日期字段可以插入 ’0000-00-00 00:00:00’这样的值，还有如果要插入 的字段长度超过列定义的长度， 那么 mysql 不会终止操作， 而是会自动截断后面的字符继续 插入操作，如下例： 1234567mysql&gt; create table t5 (c1 char(3)); mysql&gt; insert into t5 values(&apos;abcd&apos;); mysql&gt; select * from t5;+------+|c1 |+------+|abc |+------+1 row in set (0.00 sec) 我们可以设置 sql_mode 为 STRICT_TRANS_T ABLES，如下: 1mysql&gt; set session sql_mode=&apos;STRICT_TRANS_T ABLES&apos; 这样我们再执行同样的操作，mysql 就会告诉我们插入的值太长，操作被终止，如下: 123mysql&gt; insert into t5 values(&apos;abcd&apos;);ERROR 1406 (22001): Data too long for column &apos;c1&apos; at row 1 Sql_mode 值 描述 ANSI 更改语法和行为，使其更符合标准 SQL。 STRICT_TRANS_TABLES 如果不能将给定的值插入到事务表中， 则放弃该语句。 对于非事表，务如果值出现在单行语句或多行语句的第 1 行，则放弃该语句。 TRADITIONAL Make MySQL 的行为象“传统”SQL 数据库系统。该模式的简单描述是当在列中插入不正确的值时“给出错误而不是警告”。注释: 一旦发现错误立即放弃 INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。 SQL Mode 与数据效验 SQL Mode 还可以实现对数据效验和转移等功能如:·效验日期数据合法性.·在 INSERT 或 UPDATE 过程中，如果被零除(或 MOD(X，0))，则产生错误·将‘“’视为识别符引号(‘`’引号字符)·禁用反斜线字符(‘\’) 做为字符串内的退出字符。启用 NO_BACKSLASH_ESCAPES 模式，反斜线则成为普通字符。·将 || 视为字符串连接操作符(+)(同 CONCAT())，而不视为 OR。 ​​​ ​​​ ​​​​​​ ​​​]]></content>
      <tags>
        <tag>MySQL SQL Mode 索引 事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构（一）]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[图 图的基本概念 图：是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为：G(V,E), 其中，G 表示一个图，V 是图 G 中顶点的集合，E 是图 G 中边的集合。 顶点：线性表中的数据元素叫元素，树种的数据元素叫结点，图中的数据元素叫做顶点。根据顶点到顶点之间的方向性分为无向图和有向图。 无向图：G~1~=(V~1~,{E~1~}) 无向边 V~1~={A,B,C,D}; 边集合 E~1~={(A,B),(B,C),(C,D),(D,A),(A,C)} 有向图：G~2~=(V~2~,{E~2~}) 有向边 V~2~={A,B,C,D}; 弧集合 E~2~={,,,} 简单图：在图中，若不存在顶点到其自身的边，且同一条边不重复出现。 无向完全图：在无向图中，任意两个顶点之间都存在边。 有向完全图：在有向图中，任意两个顶点之间都存在方向互为相反的两条弧。 网：图的边或弧相关的数叫做权，带权的图通常称为网。 回路或环：第一个顶点到最后一个顶点相同的路径。序列中顶点不重复出现的路径称为简单路径。除了第一个顶点和最后一个顶点之外，其余顶点不重复出现的回路，称为简单回路或简单环。 连通图：在无向图 G 中，对于图中任意两个顶点 v~i~,v~j~ 包含于 E，v~i~ 和 v~j~ 都是连通（从顶点 v~i~ 到顶点 v~j~ 有路径）的，则称 G 是连通图。 连通分量：无向图中的极大连通子图称为连通分量。连通子图含有极大顶点数，且包含依附于这些顶点的所有边。（一个图中可以有多个连通分量） 强连通图：在有向图 G 中，如对于每一对 v~i~,v~j~ 包含于 V，且 v~i~≠v~j~，从 v~i~ 到 v~j~ 和从 v~j~,v~i~ 都存在路径，则称 G 为强连通图。 强连通分量：有向图中的极大强连通子图称做有向图的强连通分量。 连通图的生成树：其是一个极小的连通子图。它含有图中全部的 n 个顶点，但只有足以构成一棵树的 n-1 条边。如果一个图中有 n 个顶点和 小于 n-1 条边，则是非连通图，如果它多于 n-1 条边，必定构成一个环，因为这条边使得它依附的那两个顶点之间有了第二条路径。 有向树：如果一个有向图掐有一个顶点的入度为 0，其余顶点的入度均为 1，则是一棵有向树。 图的抽象数据类型 图的存储结构##### 邻接矩阵 图的邻接矩阵存储方式是用两个数组来表示图。一个一维数组存储图中顶点信息，一个二维数组（称为邻接矩阵）存储图中的边或弧的信息。 邻接表 数组与链表相结合的方法称为邻接表。 有向图的逆邻接表：即对每个顶点 v~1~ 都建立一个链接为 v~1~ 为弧头的表。 邻接表和逆邻接表结合起来就很容易判断某个顶点的入度或出度是多少，判断两顶点是否存在弧也很容易实现。 十字链表 十字链表的好处就是因为把邻接表和逆邻接表整合在了一起，这样更容易求得顶点的出度和入度。而且它除了结构复杂一点外，其实创建图算法的时间复杂度是和邻接表相同的，因此，在有向图的应用中，十字链表是非常好的数据结构模型。 邻接多重表 边表结点结构如下 ivex ilink jvex jlink 其中 ivex 和 jvex 是与某条边依附的两个顶点在顶点表中的下标。ilink 指向依附顶点 ivex 的下一条边，jlink 指向依附顶点 jvex 的下一条边。这就是邻接多重表结构。 边集数组 边集数组是由两个一维数组构成。一个是存储顶点的信息；另一个是存储边的信息，这个边数组每个数据元素由一条边的起点下标（begin）、终点下标（end）和权（weight）组成。 它更适合对边依次进行处理的操作，而不适合对顶点相关的操作。 图的遍历 从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次，这一过程就叫做图的遍历。 深度优先遍历（DFS）它从图中某个顶点 v 出发，访问此顶点，然后从 v 的未被访问的邻接点出发深度优先遍历图，直至图中所有和 v 有路径想通的顶点都被访问到。若图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点做起始点，重复上述过程，直至图中所有顶点都被访问到为止。(类似于树的前序遍历) 对无向图来说，邻接表做存储结构时，找邻接点所需的时间取决于顶点和边的数量 O(n+e). 对于点多边少的稀疏图来说，邻接表结构使得算法在时间效率上大大提高。 广度优先遍历（BFS）类似于树的层序遍历。 最小生成树 构造连通网的最小代价生成树称为最小生成树。 普里姆（Prim）算法 定义：假设 N = （P，{E}）是连通网，TE 是 N 上最小生成树中边的集合。算法从 U={u~0~}(u~0~∈V)，TE={}开始。重复执行下述操作：在所有 u∈U，v∈V-U 的边（u，v）∈E 中找一条代价最小的边（u~0~，v~0~）并入结合 TE，同时 v~0~ 并入 U，直至 U=V 为止。此时 TE 中必有 n-1 条边，则 T=（V，{TE}）为 N 的最小生成树。 克鲁斯卡尔（Kruskal）算法 定义：假设 N=（V，{E}）是连通网，则令最小生成树的初始状态为只有 n 个顶点而无边的非连通图 T={V，{}}，图中每个顶点自成一个连通分量。在 E 中选择代价最小的边，若该边依附的顶点落在 T 中不同的连通分量上，则将此边加入到 T 中，否则舍弃此边选择下一条代价最小的边。依次类推，直至 T 中所有顶点都在同一连通分量上为止。 对比而言，Kruskal 算法主要针对边来展开，边数少时效率会更非常高，所以对于稀疏图有很大的优势。而 Prim 算法对于稠密图，对于边数非常多的图效率更高。 最短路径 对于网图的最短路径，是指两顶点之间经过的边上权值之和最少的路径，并且我们称路径上的第一个顶点是源点，最后一个顶点是终点。 迪杰斯特拉（Dijkstra）算法 按路径长度递增的次序产生最短路径的算法。（略 PHP 补充）。 弗洛伊德（Floyd）算法 一个二重循环初始化加一个三重循环权值修正。]]></content>
      <tags>
        <tag>图表 路径算法 树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话数据结构（一）]]></title>
    <url>%2F2017%2F10%2F31%2F%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[数据结构绪论 基本概念和术语 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，病输入给计算机处理的符号集合。数据不仅仅包括整形，实型等数据类型，还包括字符及声音，图像，视频等非数值类型。数据元素：是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理，也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 ### 逻辑结构 和 物理结构 逻辑结构 ：是指数据对象中数据元素之间的相互关系。 逻辑结构包括四种：集合结构（集合）、线性结构（一对一）、树形结构（一对多）、图形结构（多对多）。 物理结构：是指数据的逻辑结构在计算机中的存储形式。 数据元素的存储结构形式有两种： 顺序存储结构：是把数据元素存放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：是把数据元素存放在任意的存储单元里，这组存储单元可以使连续的，也可以是不连续的。数据元素的存储关系并不能反映其逻辑关系，因此需要用一个指针存放数据元素的地址，这样通过地址就可以找到相关数据元素的位置。 抽象数据类型 数据类型：是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。 抽象数据类型：是指一个数学模型及定义在该模型上的一组操作。（如：’整数‘ 类型）。其定义仅仅取决于它的一组逻辑特性，而与其在计算机内部如何表示和实现无关。 一个抽象数据类型定义了：一个数据对象、数据对象中各数据元素之间的关系及对数据元素的操作。至于一个抽象数据类型到底需要哪些操作，就只能由设计者根据实际需要来定。 抽象数据类型体现了程序设计中问题分解，抽象和信息隐藏的特性。 算法 算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。 算法五个特性：输入、输出、有穷性、确定性、可行性。 算法设计要求：正确性、可读性、健壮性、高效率和低存储量。 #### 函数的渐进增长 函数的渐进增长特性：使得判断一个函数的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数。 算法时间复杂度 定义：在井陉算法分析时，语句总的执行次数 T（n）是关于问题规模 n 的函数，进而分析 T（n）随 n 的变化情况并确定 T（n）的数量级。算法的事件复杂度，也就是算法的时间量度，记作：T(n)= O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。 这样用大写 O()来体现算法时间复杂度的记法，我们称之为大 O 记法。一般情况下，随着 n 的增大，T（n）增长最慢的算法为最优算法。 O（1）常数阶 O（n）线性阶 O（n^2^）平方阶。 推导大 O 阶： 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶项存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。 算法空间复杂度 算法的空间复杂度通过计算算法所需的存储空间实现，其计算公式记作 S(n) = O(f(n)), 其中 n 为问题的规模， f(n)为语句关于 n 所占存储空间的函数。 线性表 线性表（List）: 零个或多个数据元素的有限序列。 #### 线性表的顺序存储结构 指的是用一段地址连续的存储单元依次存储线性表的数据元素。 线性表的顺序存储结构的优缺点： 优点：无需为表示表中元素之间的逻辑关系而增加额外的存储空间 ​ 可以快速地存取表中任一位置的元素 缺点：插入和删除操作需要移动大量元素 ​ 当线性表长度变化较大时，难以确定存储空间的容量 ​ 造成存储空间的“碎片” #### 线性表的链式存储结构 单链表 对于其存储的数据元素（a~i~）来说, 除了存储其本身的信息之外，还需存储一个指示其直接后继的信息（即直接后继的存储位置）。我们把存储数据元素信息的域成为数据域，把存储直接后继位置的域成为指针域。指针域中存储的信息称为指针或链。这两部分信息组成数据元素（a~i~）的存储映像，称为结点（Node）。 n 个结点（a~i~）链结成一个链表，即为线性表的链式存储结构，因为此链表的每个节点中只包含一个指针域，所以叫做单链表。 头结点和头指针的区别：头指针只有指针域（必要元素） 头结点数据域和指针域都有（非必要）【头结点包含头指针】。 单链表的优势：对于插入或删除数据越频繁的操作，单链表的效率优势越是明显。 优缺点分析 顺序存储结构 单链表 存储分配方式 用一段连续的存储单元依次存储线性表的数据元素 采用链式存储结构，用一组任意的存储单元存放线性表的元素 时间性能 查找：O(1) 插入删除：O(n) 查找：O(n) 插入删除：O(1) 空间性能 需要预分配存储空间，分大了，浪费，分小了易发生上溢 不需要分配存储空间，元素个数也不受限制 ##### 静态链表 用数组描述的链表叫做静态链表。 重要的截图： 优点 缺点 在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了在顺序存储结构中的插入和删除操作需要移动大量元素的缺点 没有解决连续存储分配带来的表长难以确定的问题。失去了顺序存储结构随机存取的特性。 ​ 静态链表其实是为了给没有指针的高级语言设计的一种实现单链表能力的方法。 循环链表 将单链表中终端结点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相连的单链表称为单循环链表，简称循环链表。 双向链表 双向链表是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。 栈与队列（特殊的线性表）栈 栈是限定仅在表尾进行插入和删除操作的线性表。简称 LIFO 结构。 栈的顺序与链式存储结构使用区别 如果栈的使用过程中元素变化不可预料，有时很小，有时很大，那么最好用链栈，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的应用 - 递归 斐波那契数列：前面相邻两项之和，构成了后一项。 递归函数：把一个直接调用自己或者通过一系列的调用语句间接地调用自己的函数，称作递归函数。 （简单的说，就是在前行阶段，对于每一层递归，函数的局部变量，参数值以及返回地址都被压入栈中。在退回阶段，位于栈顶的局部变量，参数值和返回地址被弹出，用于返回调用层次中中执行代码的其余部分，也就是恢复了调用的状态。） 栈的应用 - 四则运算表达式求值 后缀（逆波兰）表示法定义— 一种不需要括号的后缀表示法，也称为逆波兰表示。叫后缀的原因是所有的符号都是在要运算数字的后面出现。 eg. “9 3 1 - 3* +10 2 /+”（后缀表达式） = “9+(3-1)x3+10÷2”(也称作中缀表达式) 将中缀表达式转换成后缀表达式（栈用来进出运算的符号） 将后缀表达式进行运算得出结果（栈用来进出运算的数字） 队列 队列是只允许一端进行插入操作，而在另一端进行删除操作的线性表。队列是一种先进先出的线性表，简称 FIFL。 循环队列 把队列的头尾相接的 顺序存储结构 称为循环队列。 队列的链式存储结构 其就是线性表的 单链表，只不过只能尾进头出，简称链队列。 循环队列和链队列的区别 时间上：循环队列事先申请好空间，使用期间不释放，链队列每次申请和释放结点也会存在一些时间开销。 空间上：循环队列必须有一个固定长度，所以就有了存储元素个数和空间浪费的问题。链队列不存在这个问题。 总之，在可以确定队列长度最大值的情况下，建议用循环队列，如果无法预估队列的长度时，则用链队列。 串（字符串）由零个或多个字符组成的有限序列。 朴素的模式匹配算法 子串的定位操作通常称为串的模式匹配。 朴素的模式匹配是根据两个需匹配的字符串各自的每个字符进行循环匹配的操作。容易出现极端情况，比如 00000…..0000001 与 00000001 的匹配，随着前者的长度越大，其匹配的效率越低。 KMP 模式匹配算法 克努特 Knuth - 莫里斯 Morris- 普拉特 Pratt 算法。 具体算法略 KMP 算法仅当模式与主串之间存在许多“部分匹配”的情况下才体现出它的优势，否则两者差异并不明显。 KMP 算法待补充。 树 树的定义 树：树（Tree）是 n(n≥0)个结点的有限集。n=0 时称为空树。在任意一棵非空树中： （1）有且仅有一个特定的称为根（Root）的结点。 （2）当 n&gt;1 时，其余结点可分为 m(m&gt;0)个互不相交的有限集 T~1~、T~2~ 、…、T~m~，其中每个集合本身又是一棵树，并且称为根的子树（Subtree）。子树之间是不可相交的。 结点：树的结点包含一个数据元素及若干指向其子树的分支。 结点拥有的子树数称为结点的度。度为 0 的结点称为叶结点或终端结点。度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支节点也称为内部结点。树的度是树内其中结点的度的最大值。 结点间的关系 树的抽象数据类型 双亲表示法 就是在每个结点中，附设一个指示器指示其双亲结点到链表中的位置。 当我们又关注结点的双亲，又关注结点的孩子，还关注结点的兄弟，而且对事件遍历要求还比较高，那么我们还可以把此结构扩展为有双亲域、长子域、再有右兄弟域。 存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适，方便，时间复杂度好不好等。 孩子表示法 多重链表表示法：每个结点有多个指针域，其中每个指针指向一棵子树的根节点。 孩子表示法：把每个结点的孩子结点排列起来，以单链表做存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。 当也需要找到某个结点的双亲时，可以和双亲表示法结合 孩子兄弟表示法 设置了两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。这个表示法的最大好处是它把一棵复杂的树变成了一棵二叉树。 二叉树的定义 二叉树：是 n(n≥0)个结点的有限集合，该集合或者为空集（空二叉树），或者由一个根节点和两棵互不相交的、分别称为根节点的左子树和右子树的二叉树组成。 特殊的二叉树：斜树 满二叉树 完全二叉树（编号连续）（满二叉树一定是一棵完全二叉树，但完全二叉树不一定是满的） 二叉树的性质 在二叉树的第层上 至多 有 2^i-1^ 个结点 深度为 k 的二叉树至多有 2^k^-1 个结点 对任何二叉树 T，如果其终端结点数为 n~0~，度为 2 的结点数为 n~2~，则 n~0~=n~2~+1。（需要推导） 具有 n 个结点的完全二叉树的深度为 [log~2~n]+1(需要推导) 如果对一棵有 n 个结点的完全二叉树（深度为[log~2~n]+1）的结点按层序编号，对任一结点 i（1≤i≤n）有: 如果 i=1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1, 则其双亲结点为[i/2]。 如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。 如果 2i+1&gt;2 ，则结点 i 无右孩子；否则其右孩子是结点 2i+1。 二叉树的存储结构 二叉树顺序存储结构 用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系。但是考虑到极端情况，比如一棵深度为 k 的右斜树，它只有 k 个结点，却需要分配 2~k~-1 个存储单元空间，造成了存储空间的浪费。所以顺序存储结构一般只用于完全二叉树。 二叉链表 一个数据域和两个指针域的链表叫做二叉链表。如果有需要，再增加一个指向其双亲的指针域，那样就叫做三叉链表。 遍历二叉树 二叉树的遍历是指从根节点出发，按照某种次序依次访问二叉树中所有结点，是的每个结点被访问一次且仅被访问一次。 前序遍历 若二叉树为空，则空操作返回，否则先访问根节点，然后前序遍历左子树，再前序遍历右子树。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */ PreOrderTraverse(T-&gt;lchild);/* 再先序遍历左子树 */ PreOrderTraverse(T-&gt;rchild);/* 最后先序遍历右子树 */&#125; 中序遍历 若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根节点），中序遍历根节点的左子树，然后是访问根结点，最后中序遍历右子树。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; PreOrderTraverse(T-&gt;lchild);/* 中序遍历左子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */ PreOrderTraverse(T-&gt;rchild);/* 最后中序遍历右子树 */&#125; 后序遍历 若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 12345678void PreOrderTraverse(BiTress T)&#123; if(T==null) return; PreOrderTraverse(T-&gt;lchild);/* 先后序遍历左子树 */ PreOrderTraverse(T-&gt;rchild);/* 再后序遍历右子树 */ printf(&quot;%c&quot;,T-&gt;data);/* 显示结点数据，可以更改为其他对结点操作 */&#125; 层序遍历 若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下，从左到右依次访问。 总结：前中后序遍历最根本的区别是根节点在排序中的位置。如前序遍历根结点在头部。 线索二叉树 我们把一种指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树称为线索二叉树。 线索二叉树，等于是把一棵二叉树转变成了一个双向链表，这样对我们的插入删除结点，查找某个结点都带来了方便。所以我们对二叉树以某种次序遍历使其变为线索二叉树的过程称做是线索化。(其线索化的过程就是在遍历的过程中修改空指针的过程) 位置区分结点的 lchild 和 rchild 指向的是前驱或后驱还是左孩子或右孩子，需要在每个结点再增设两个标志域 ltag 和 rtag(其只是存放 0 和 1 数字的布尔型变量)。总结其结点结构如下 lchild ltag data rtag rchild ltag 为 0 时指向该结点的左孩子，为 1 时指向该结点的前驱。rtag 同理。 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择 赫夫曼树及其应用 从树种一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称为路径长度。树的路径长度就是从树根到每一结点的路径长度之和。带权路径长度 WPL 最小的二叉树称做赫夫曼树也叫最优二叉树。 赫夫曼编码 一般的，设需要编码的字符集为{d~1~,d~2~,d~3~,…d~n~}, 各个字符在电文中出现的次数或频率集合为{w~1~,w~2~,w~3~,….w~n~}，以 d~1~,d~2~,…,d~n~ 作为叶子结点，以 w~1~,w~2~,w~3~,….w~n~ 最为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的做分支代表 0，有分支代表 1，则从根节点到叶子结点所经过的路径分支组成 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。 （若要设计长短不等的编码，则必须是任一字符的编码都不是另一个字符的编码的前缀，这种编码称作前缀编码） ——其后还有图，查找，排序章节]]></content>
      <tags>
        <tag>数据结构  算法复杂度 线性表 链表 队列 二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数据安全]]></title>
    <url>%2F2017%2F08%2F29%2FPHP%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[三种 PHP 数据安全防范示例 常见的转义 html 例如一个用户的表单输入获取 $a = $_GET[&#39;username&#39;] 其中的 username 值可能是一样有恶意的 JS 脚本可能造成不必要的麻烦。 解决办法 ·$a = htmlspecialchars($_GET[&#39;username&#39;],ENT_QUOTES); htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。 预定义的字符是： &amp; （和号）成为 &amp; “ （双引号）成为 “ ‘ （单引号）成为 ‘ &lt; （小于）成为 &lt; > （大于）成为 &gt; 提示：如需把特殊的 HTML 实体转换回字符，请使用 htmlspecialchars_decode() 函数。 防止 SQL 注入 有两种方法 第一种是 php.ini 中的 magic_quotes_gpc 设置为 on. magic_quotes_gpc 函数在 php 中的作用是判断解析用户提示的数据，如包括有:post、get、cookie 过来的数据增加转义字符“\”，以确保这些数据不会引起程序，特别是数据库语句因为特殊字符引起的污染而出现致命的错误 注意 这个设置在 PHP6 中已经不可使用了，所以根据情况使用. 第二种就是使用 mysql_real_escape_string()函数. ​ 语法： ​ mysql_real_escape_string() 函数转义 SQL 语句中使用的字符串中的特殊字符。 ​ 把获取的变量进行函数处理. ​ $a = mysql_real_escape_string($user); 对引号做两次转意 这通常在开发者的环境中 magic_quotes 设置为 off，而在部署的服务器上 magic_quotes =on. PHP 会在 GET, POST 和 COOKIE 中的数据上重复运行 addslashes() 造成两次转义的现象。 原始文本： It’s a string magic quotes on : It\’s a string 又运行一次 addslashes(): It\‘s a string HTML 输出: It\’s a string ​]]></content>
      <categories>
        <category>PHP数据安全</category>
      </categories>
      <tags>
        <tag>数据安全 PHP 函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (四)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E5%9B%9B)%2F</url>
    <content type="text"><![CDATA[面向对象基础 类的定义: 类就是具有相同的属性和功能的对象的抽象的集合。构造方法: 只针对于 JAVA 实例化 :对类进行实例化，构造方法与类同名，无返回值，也不需要 void, 在 new 时候调用。 构造方法 :所有类都有构造方法，如果你不编码则系统默认生成空的构造方法，若你有定义的构造方法，那么默认的构造方法就会失效了。 方法重载 :方法重载提供了创建同名的多个方法的能力，但这些方法需使用不同的参数类型。 属性和修饰符 :属性是一个方法或一对方法，但在调用它的代码看来，它是一个字段，即属性适合于以字段的方式使用方法调用的场合。[属性的名称一般首字母大写，而字段则一般首字母小写或前加‘_’]。（字段和属性时不同的。属性是特殊的方法，可以给对应的字段赋值） 属性有两个方法 get 和 set。get 访问器返回与声明的属性相同的数据类型，表示的意思是调用时可以得到内部字段的值或引用。set 访问器没有显示设置参数，但它有一个隐式参数，用关键字 value 表示，它的作用是调用属性时可以给内部的字段或引用赋值。 封装 :每个对象都包含它能进行操作所需要的所有信息，这个特性称为封装，因此对象不必依赖其他对象来完成自己的操作。 继承 子类拥有父类非 private 的属性和功能。 子类具有自己的属性和功能。 子类还可以以自己的方式实现父类的功能（方法重写）。 子类构造方法需要调用父类同样参数类型的构造方法，用 base 关键字代表父类。（对于构造方法，其不能被继承，只能被调用） 继承显然是一种类与类之间的强耦合的关系。 多态 :多态表示不同的对象可以执行相同的动作。但要通过它们自己的实现代码来执行。 添加（virtual）关键字虚拟化父类的成员。子类可以选择使用（override）关键字，将父类实现替换为它自己的实现，这就是方法重写 Override, 或者叫做方法覆写。 原理是当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用。也就是说，虚方法是按照其运行时类型而非编译时类型进行动态绑定调用的。[AMNFP] 抽象类 : 抽象类不能实例化。 抽象方法是必须被子类重写的方法。（抽象方法可以被看作是没有实现体的虚方法） 如果类中包含抽象方法，那么类就必须定义为抽象类，不论是否还包含其他一般方法。 抽象类通常代表一个抽象概念，它提供一个继承的出发点，当设计一个新的抽象类时，一定是用来继承的，所以，在一个以继承关系形成的等级结构里面，树叶节点应当是具体类，而树枝节点均应当是抽象类[J&amp;DP] 接口 :接口是把隐式公共方法和属性结合起来，以封装特定功能的一个集合。一旦类实现了接口，类就可以支持接口所指定的所有属性和成员。 不能实例化。不能有构造方法和字段。不能有修饰符。不能声明虚拟的或静态的。 声明接口在语法上与声明抽象类完全不同，但不允许提供接口中任何成员的执行方式。 实现接口的类就必须要实现接口中的所有方法和属性。 接口的命名，前面要加一个大写字母’I’(规范) 抽象类和接口的区别 形态上来说​ 抽象类可以给出一些成员的实现，接口却不包含成员的实现，抽象类的抽象成员可被子类实现，接口的成员需要实现类完全实现，一个类只能继承一个抽象类，但可实现多个接口。 设计模式上来说​ 1. 类是对对象的抽象；抽象类是对类的抽象；接口是对行为的抽象。不论是接口、抽象类、类甚至对象，都是在不同层次、不同角度进行抽象的结果，他们的共性就是抽象 ​ 2. 如果行为跨越不同类的对象，可使用接口；对于一些相似的类对象，用继承抽象类。 ​ 3. 从设计角度讲，抽象类是从子类中发现了公共的东西，泛华出父类，然后子类继承父类，而接口是根本不知道子类的存在，方法如何实现还不确认，预先定义。 ​ 4.[抽象类是自底而上抽象出来的，而接口则是自顶向下设计出来的] 泛型 :泛型是具有占位符（类型参数）的类、接口、和方法，这些占位符是类、结构、接口和方法所存储或使用的一个或多个类型的占位符。泛型集合类可以将类型参数用作它所存储的对象的类型的占位符：类型参数作为其字段的类型或其方法的参数类型出现[MSDN]。 不是太懂，来个例子，自己领会吧:sad: 以下文字概念反正我没太懂 通常情况下，都建议使用泛型集合，因为这样可以获得类型安全的直接优点而不需要从基结合类型派生并实现类型特定的成员。此外，如果集合元素为值类型，泛型集合类型的性能通常优于对应的非泛型集合类型（并优于从非泛型基集合类型派生的类型），因为使用泛型时不必对元素进行装箱[MSDN]。 委托和事件 :委托是对函数的封装，可以当作给方法的特征指定一个名称。而事件则是委托的一种特殊形式，当发生有意义的事情时，事件对象处理通知过程[PC#] 委托对象用关键字 delegate 来声明，而事件是说在发生其他类或对象关注的事情时，类或对象可通过事件通知它们。事件用 event 关键字声明。 主要参考文献 [DP] 《设计模式：可复用面向对象软件的基础》 [DPE] 《设计模式解析》 [ASD] 《敏捷软件开发：原则、模式和实践》 [RIDEC] 《重构–改善既有代码的设计》 [J&amp;DP] 《Java 与模式》 [R2P] 《重构与模式》 [Head First Design Patterns] ​ 再次贴上百度云代码链接 相关代码]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (三)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%89)%2F</url>
    <content type="text"><![CDATA[设计模式分组 一、创建型模式 抽象工厂模式 提供一个创建一系列或相关依赖对象的接口，而无需指定他们具体的类[DP] 建造者模式 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示[DP] 工厂模式 定义一个用于创建对象的接口，让子类决定实例化哪一个类，工厂模式使一个类的实例化延迟到子类[DP] 原型模式 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP] 单例模式 保证一个类只有一个实例，并提供一个访问它的全局访问点[DP] 总结 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么，谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。[DP] 关于松耦合：内聚性和耦合性 内聚性描述的是一个例程内部组成部分之间相互联系的紧密程度。而耦合性描述的是一个例程与其他例程之间联系的紧密程度。软件开发的目标应该是创建这样的例程：内部完整，也就是高内聚，而与其他例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合[DP] 创建型模式抽象了实例化的过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。创建型模式都会将关于该系统使用哪些具体的类的信息封装起来。允许客户用结构和功能差别很大的‘产品’对象配置一个系统。配置可以是静态的，即在编译时指定，也可以是动态的，就是运行时再指定[DP] 通常设计应是从工厂方法开始，当设计者发现需要更大的灵活性时，设计便会向其他创建型模式演化。当设计者在设计标准之间进行权衡的时候，了解多个创建型模式可以给设计者更多的选择余地[DP] ​ 二、 结构型模式 适配器模式 将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作[DP] 桥接模式 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 组合模式 将对象组合成树形结构以表示‘部分 - 整体’的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性[DP] 装饰模式 动态地给一个对象添加一些额外的职责。就增加功能来说，装饰模式相比生成子类更加灵活[DP] 外观模式 为子系统中的一组接口提供一个一致 的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] 享元模式 为运用共享技术有效地支持大量细粒度的对象[DP] 代理模式 为其他对象提供一种代理以控制对这个对象的访问[DP] 总结 问题 : 信息的隐藏促进了软件的复用，如何理解这句话？ ​ 类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。如果两个类不必彼此直接通信，那么就不要让这两个类发生直接的相互作用。如果实在需要调用，可以通过第三者来转发调用。 代理模式与外观模式的区别 代理对象代表一个单一对象而外观对象代表一个子系统 代理的客户对象无法直接访问目标对象，由代理提供对单独的目标对象的访问控制，而外观的客户对象可以直接访问子系统中的各个对象，但通常由外观对象提供对子系统各元件功能的简化的共同层次的调用接口[R2P] 代理与适配器之间来说，代理模式是一种原来对象的代表，其他需要与这个对象打交道的操作都是和这个对象交涉。而适配器则不需要虚构出一个代表着，只需要为应付特定使用目的，将原来的类进行一些组合[DP]。 三、行为型模式 观察者模式 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。 ​ 模板方法模式 定义一个操作的算法骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP]。 命令模式 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化：可以对请求排队或记录请求日志，以及支持可撤销操作[DP]。 状态模式 允许一个对象在其内部状态改变时改变它的行为，让对象看起来似乎修改了它的类[DP]。 状态模式提供了一个更好的办法来组织与特定状态相关的代码，决定状态转移的逻辑不在单块的 if 或 switch 中，而是分布在各个状态子类之间，由于所有与状态相关的代码都存在于某个状态子类中，所以通过定义新的子类可以很容易地增加新的状态和转换[DP]。 职责链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止[DP]。 四、 行为型模式第二组 解释器模式 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP]。 中介者模式 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 访问者模式 表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。[DP] 策略模式 定义一系列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。[DP] 备忘录模式 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态[DP]。 备忘录模式把可能很复杂的对象 A 的内部信息对其他对象屏蔽起来，从而保持了封装边界[DP]。 迭代器模式 提供一种方法顺序访问一个聚合对象中各个元素，而又不需暴露该对象的内部表示。[DP] 五、 总结 工厂方法的实现并不能减少工作量，但是它能够在必须处理新情况时，避免使已经很复杂的代码更加复杂[DPE]。 面向对象设计模式体现的就是抽象的思想。 类是对对象的抽象 抽象类是对类的抽象 接口是对行为的抽象]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (二)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%BA%8C)%2F</url>
    <content type="text"><![CDATA[十三 、状态模式 状态模式（State）, 当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。（DP） 状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。 使用时机 当一个对象的行为取决于它的状态，并且它必须在运行时刻根据它的状态改变它的行为时，就可以考虑使用状态模式了。 [此处应有（meiyou）代码(zi ji kan)] 十四 、 适配器模式 适配器模式（Adapter）, 将一个类的接口转换成客户希望的另外一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。[DP] 类适配器模式 通过多重继承对一个接口与另一个接口进行匹配，但大部分语言不支持多重继承（C++ 支持） 对象适配器模式 对象适配器模式结构图 代码示例 十五 、 备忘录模式 备忘录（Memento）: 在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可将该对象恢复到原先保存的状态[DP]。 [DP] 如果在某个系统中使用命令模式时，需要实现命令的撤销功能，那么命令模式可以使用备忘录模式来存储可撤销操作的状态。 使用备忘录可以把复杂的对象内部信息对其他的对象屏蔽起来[DP]. 当角色的状态改变时，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。 十六 、 组合模式 组合模式（Composite）: 将对象组合成树形结构以表示‘部分 - 整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。[DP] 》接口是一种约束 十七 、 迭代器模式 迭代器模式（Iterator）: 提供了一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。[DP] foreach 迭代器模式就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明的访问集合内部的数据 十八 、 单例模式 单例模式（Singleton）: 保证一个类仅有一个实例，并提供一个访问它的全局访问点。[DP] 通常我们可以用一个全局变量使得一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类自身负责保存它的唯一实例。这个类可以保证没有其他实例可以被创建，并且它可以提供一个访问该实例的办法。[DP] 十九、 桥接模式 继承的麻烦 对象的继承关系是在编译时就定义好了，所以无法在运行时改变从父类继承的实现。子类的实现与它的父类有非常紧密的依赖关系，以至于父类实现中的任何变化必然会导致子类发生变化。当你需要复用子类时，如果继承下来的实现不适合解决新问题，则父类必须重写或被其他更换的类替换。这种依赖关系限制了灵活性并最终限制了复用性。[DP] 在面向对象设计中，我们有一个很重要的设计原则，那就是合成 / 聚合复用原则。即优先使用对象合成 / 聚合，而不是类继承。[DP] 合成 / 聚合复用原则(CARP): 尽量使用合成 / 聚合，尽量不要使用类继承。[J&amp;DP] 聚合表示一种弱的‘拥有’关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分: 合成表示一种强的‘拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样[DPE]（看图） 好处 优先使用对象的合成 / 聚合将有助于你保持每个类被封装，并被集中在单个任务上。这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。[DP] 桥接模式（Bridge）: 将抽象部分与它的实现部分分离，使他们都可以独立地变化。[DP] 二十、 命令模式 命令模式（Command）: 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化; 对请求进行排队或记录请求日志，以及支持可撤销的操作。[DP] 命令模式作用 它能较容易地设计一个命令队列 在需要的情况下，可以较容易地将命令记入日志 允许接受请求的一方决定是否要否决请求 可以容易地实现对请求的撤销和重做 由于加进新的具体命令类不影响其他的类，因此增加的新的具体命令类很容易。 命令模式把请求一个操作的对象与知道怎样执行一个操作的对象分隔开[DP] ​ 二十一、 责任链模式 责任链模式（Chain of Responsibility）: 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。[DP] 职责连的好处 可简化对象的互相连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选接受者的引用。[DP] 可随时地增加或修改处理一个请求的结构。增强了给对象指派职责的灵活性[DP] 二十二、 中介者模式 中介者模式（Mediator）: 用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。[DP] 应用场景 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。 二十三 、享元模式 享元模式（Flyweight）: 运用共享技术有效地支持大量细粒度的对象[DP] 优点 享元模式可以避免大量相似类的开销。在程序设计中，有时需要生成大量细粒度的类实例来表示数据。如果能发现这些实例除了几个参数外基本上都是相同的，有时就能够大幅度地减少需要实例化的类的数量。如果能把那些参数移到类实例的外面，在方法调用时将他们传递进来，就可以通过共享大幅度地减少单个实例的数目。[减少对象的实例化数量] 二十四、 解释器模式 解释器模式（Interpreter）: 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子[DP] 如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题[DP] (正则表达式是它的一种应用，解释器为正则表达式定义了一个文法，如何表示一个特定的正则表达式，以及如何解释这个正则表达式) 当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式[DP] 解释器模式可以很容易地改变或扩展文法，因为该模式使用类来表示文法规则，你可使用继承来改变或扩展该文法。其也比较容易实现文法，因为定义抽象语法树中各个节点的类的实现大体类似，这些类都易于直接编写[DP] 举个例子就是人工智能机器人，机器人把人的具体指令解释成相应的行为。 二十五、 访问者模式 访问者模式（Visitor）: 表示一个作用于某对象结构中的各元素的操作。它可以使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作[DP] 访问者模式应用 适用于数据结构相对稳定的系统，它把数据结构和作用于结构上的操作之间的耦合解脱开，使得操作集合可以相对自由的演化。 访问者模式使得增加新的操作很容易，因为增加新的操作就意味着增加一个新的访问者。访问者模式将有关的行为集中到一个访问者对象中。 访问者模式通常都会使增加新的数据结构变化困难。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大话设计模式 (一)]]></title>
    <url>%2F2017%2F08%2F27%2F%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F(%E4%B8%80)%2F</url>
    <content type="text"><![CDATA[标签（空格分隔）： 设计模式 大话 设计 &gt; 仅供参考 /(ㄒ o ㄒ)/~~ 相关的对应的代码会贴上百度云，是用 JAVA 写的。想看的可以下载（在文章末尾）。暂时只是一些个概念和大体结构，大部分（jihu）是没有代码的，理解起来肯定会比较难（或许根本理解不了），whatever , 只是个人读书笔记，比较粗糙，凑活看吧。哈哈。 一 、简单工厂模式 用一个单独的类来实现易修改和扩展创造实例的过程。 有图 ​ ​ UML 类图图示样例 ​ ​ ‘+’表示 public ‘-‘表示 private ‘#’表示 protected ​ 继承关系用空心三角形 + 实线来表示 如图 ​ ​ 接口关系用空心三角形 + 虚线表示 形如上图（略） ​ 关联关系用实线箭头表示 形如上图（略）、 ​ 聚合关系 ​ 聚合表示一种弱的’拥有‘关系，体现的是 A 对象可以包含 B 对象，但 B 对象不是 A 对象的一部分 –《设计模式》第二版 用空心的菱形 + 实线箭头表示 ​ 这个有图哦:happy: ​ ​ 组合关系 ​ 一种强的’拥有’关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样 –《设计模式》 ​ 组合关系用实心的菱形 + 实线箭头来表示，连线两端的数字 1,2，被称为基数表明这一端的类可以有几个实例（n 表示无数）。 这个也是有图的 看图 ​ ​ 依赖关系 用虚线箭头表示 UML 最后一张图 ​ 二 、策略模式​ 定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。[DP] ​ 面向对象的编程, 并不是越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的抽象集合才是类 ​ 策略模式结构图 ​ ​ 策略模式反思 策略模式是定义一系列算法的方法，从概念上来讲，所有这些算法完成的都是相同的工作，只是实现不同，他可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合 –《设计模式》[DPE] ​ 策略模式的另一个优点是简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试 –《设计模式》【DPE】 ​ 1. 单一职责原则(SRP)​ 就一个类而言，应该仅有一个引起它变化的原因。 ​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭到意想不到的破坏【ASD】。 ​ 2. 开放 - 封闭原则[简称 OCP]​ 是说软件实体（类，模块，函数等等），应该可以扩展，但是不可修改【ASD】 ​ 开放 - 封闭原则是面向对象设计的核心所在，遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护，可扩展，可复用，灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意的进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要【ASD】 ​ 3. 依赖倒转原则​ 抽象不应该依赖细节，细节应该依赖于抽象。（针对接口编程，不要对实现编程） ​ 依赖倒转原则 ​ 高层模块不应该依赖底层模块，两个都应该依赖抽象。 抽象不应该依赖细节，细节应该依赖抽象。【ASD】 ​ 4. 里氏代换原则【LSP】​ 子类型必须能够替换掉他们的父类型。【ASD】 ​ 只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。 如图 ​ ​ （依赖倒转其实就是谁也不依赖谁，除了约定的接口，大家都可以灵活自如） ​ 原则总结​ 依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是止于抽象类或者接口，那就是面向对象的设计，反之就是过程化的设计了【ASD】 ​ 三 、装饰模式​ 动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活【DP】 ​ 如图装饰模式结构图 ​ ​ 装饰模式实例代码（感觉穿衣服的例子比较有意思，是 java 代码:sad:, 逻辑能看懂:sad:） ​ 后面有例子总结，不想看图的直接跳到后面看。 ​ ​ ​ ​ ​ ​ 小结 ​ 我理解的大概的过程是这样一个工程。就是先从最后的具体服饰类开始往上逐个 装饰 的走。从具体服饰类到服饰类再到 Person 类。（可以从结果显示中看到这一过程）。 ​ ​ ​ 总结 ​ 装饰模式是为已有功能动态地添加更多功能的一种方式，装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要装饰的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有条件地，按顺序地使用装饰功能包装对象了【DP】 ​ （优点：把类中的装饰功能从类中搬除去除，这样可以简化原有的类。这样做的更大的好处是有效的把类的核心职责和装饰功能区分开了，而且可以去除相关类中重复的装饰逻辑。） ​ 四 、代理模式（Proxy）​ 为其他对象提供一种代理以控制对这个对象的访问。【DP】 ​ 代理模式结构图 ​ ​ 注释 ​ 大概的意思就是，有一个公共的接口。中间代理和实际实体两者都实现接口的方法。当具体操作的时候，用代理操作，在代理内部实现实际方法的实例化操作来间接的替代实际方法。 ​ 应用场合 ​ 远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实[DP]。 虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象[DP]。这样就可以达到性能的最优化，比如打开一个很大的 HTML 页面，虽然有很多图片但是还是能很快的打开它，此时看到的是文字，图片是一张一张的下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。其实，浏览器当中是用代理模式来优化下载的。 安全代理，用来控制真实对象访问时的权限[DP]。一般用于对象应该有不同的访问权限的时候。 智能指引，是指当调用真实的对象时，代理处理另外一些事情[DP]。如计算真实对象的引用次数，当该对象没有引用时，可以自动释放它: 或当第一次引用一个持久对象时，将它装入内存: 或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 ​ 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。 ​ 五 、工厂方法模式​ 简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。 ​ 工厂方法模式 ，定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。[DP] ​ ​ 工厂方法模式具体实现示例图 ​ ​ 工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂的内部逻辑判断移到了客户端代码来进行。你想要加功能，本来是改工厂类的，而现在是修改客户端。 ​ ​ ​ 六 、原型模式​ 用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象[DP]. ​ 原型模式结构图 ​ ​ 注释 原型模式其实就是从一个对象再创建另外一个可定制的对象，而且不需知道任何创建的细节。 ​ 原型模式中一般在初始化的信息不发生变化的情况下，克隆时最好的办法。这即隐藏了对象创建的细节，又对性能是大大的提高。同样也不用重新初始化对象，而是动态地获得对象运行时的状态。 ​ ‘浅复制’: 被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。 ‘深复制’: 深复制把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。 ​ 声明：这一模式，本人看的不是太懂。感觉有些东西不通。下面会有一个详细的例子，可以参考一下。不解释。 ​ 简历的深复制实现 ​ ​ ​ ​ ​ ​ 七 、模板方法模式​ 当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板模式方法处理。 ​ 模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤[DP] ​ ​ 模板方法模式特点 模板方法模式是通过把不变行为搬移到超类，去除子类中的重复代码来体现其优势。 提供了一个很好的代码复用平台 当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现。通过模板方法模式把这些行为搬移到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。 ​ 八、迪米特法则​ 迪米特法则（LoD）/ 最少知识原则[J&amp;DP]: 如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。[J&amp;DP] ​ 九 、外观模式​ 外观模式（Facade）: 为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用[DP] ​ ​ 十 、 建造者模式​ 建造者模式（Builder）: 将一个复杂对象的建造与它的表示分离，使得同样的建造过程可以创建不同的表示[DP] ​ 建造者模式可以将一个产品的内部表象与产品的生成过程分割开来，从而可以使一个建造过程生成具有不同的内部表象的产品对象。 ​ ​ 建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及他们的装配方式时适用的模式。 ​ 十一 、观察者模式​ 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够自动更新自己[DP]。 ​ ​ 观察者模式特点​ 当一个对象的改变需要同时改变其他对象时而且它并不知道具体有多少对象有待改变时，应该考虑使用观察中模式。 ​ 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，这时用观察者模式可以将两者封装在独立的对象中使他们各自独立的改变和复用。 ​ 委托[这段有点突兀，我理解的大概意思是把观察者也抽象了，直接委托具体的类去实现观察类的抽象。] ​ 委托就是一种引用方法的类型。一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的‘类’，委托的实例将代表一个具体的函数。 ​ 十二、抽象工厂模式​ 抽象工厂模式（Abstract Factory）, 提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。[DP] ​ ​ 百度云链接]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web 安全]]></title>
    <url>%2F2017%2F08%2F26%2Fweb%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[根本原则：数据与代码分离 同源策略1. 当 JS 被浏览器认为来自不同源是，请求被拒绝。2. 影响同源策略的因素 host(域名，IP 地址，子域名，端口和协议)。3.EXCEPT：script . img .iframe . link 标签可跨区加载资源而不受同源策略的影响。（原因是都带着 src 属性） 攻击手段类型 1. XSS 跨站脚本攻击 总的来说就是引用上面描述的不受同源策略影响的标签引入不合法的代码来进行攻击主要有四种 反射型 XSS 存储型 XSS DOM Based XSS XSS Payload Cookie 劫持攻击等 2. CSRF Cross Site Request Forgery 跨站点请求伪造 风险在于那些通过基于受信任的输入 form 和对特定行为无需授权的已认证的用户来执行某些行为的 web 应用。已经通过被保存在用户浏览器中的 cookie 进行认证的用户将在完全无知的情况下发送 HTTP 请求到那个信任他的站点，进而进行用户不愿做的行为。使用图片的 CSRF 攻击常常出现在网络论坛中，因为那里允许用户发布图片而不能使用 JavaScript。 –百度百科 3.Click Jacking 点击劫持 点击劫持，clickjacking，也被称为 UI- 覆盖攻击。这个词首次出现在 2008 年，是由互联网安全专家罗伯特·汉森和耶利米·格劳斯曼首创的。它是通过覆盖不可见的框架误导受害者点击。虽然受害者点击的是他所看到的网页，但其实他所点击的是被黑客精心构建的另一个置于原网页上面的透明页面。这种攻击利用了 HTML 中 iframe 标签的透明属性。 4.SQL 注入 盲注（Blind Injection） 攻击存储过程 编码问题 Session 劫持 如果 SessionID 是保存在 cookie 中的，则这种攻击称为 cookie 劫持 Session Fixation（固定） 攻击：在用户登录网站的过程中，如果登陆前后用户的 sessionID 没有发生变化，则会存在 session fixation 问题 预防 SQL 注入的方式1. 使用预编译语句，绑定变量2. 使用存储过程3. 检查数据类型4. 使用安全函数 5.OAuth（单纯的名词解释）OAuth 是一个在不提供用户名密码的情况下授权第三方应用访问 web 资源的安全协议。 6. 绕过文件上传检查功能 1230x00 被认为是终止符[\0] 为十六进制的 0x00 字符 会利用上述特性截端字符串为脚本语言。 设计安全的文件上传功能1. 文件上传的目录设置为不可执行2. 判断文件类型3. 使用随机数改写文件名和文件路径4. 单独设置文件服务器的域名 在加密算法的选择和使用上 有一些建议1，不要使用 ECB 模式。2，不要使用流密码比如 RC4.3，使用 HMAC-SHAI 代替 MD5(甚至是 SHAI).4, 不要使用相同的 key 做不同的事情。5，salts 与 IV 需要随机产生。6，不要自己实现加密算法，尽量使用安全专家已经实现好的库7，不要依赖系统的保密性。 当不知道如何选择时1，使用 CBC 模式的 AES256 用于加密。2. 使用 HMAC-SHA512 用于完整性检查。3，使用带 salt 的 SHA-256 或 SHA-512 用于 Hashing. 7.DDOS 分布式拒绝服务 Distributed Denial of Service 最主要的便是限制请求频率，比如无限占用 http 请求，缓慢多次发送 http 请求。 Slowloris 攻击 1 以极低的速度往服务器发送 HTTP 请求，在正常的 HPPT 包头中，是以两个 CLRF（\r\n\r\n）表示 HTTP Headers 部分结束的。 HTTP POST DOS1在发送 HTTP POST 包是，指定一个非常大的 Content-Length 值，然后以很低的速度发包，比如 10~100s 发一个字节，保持住这个链接不断开。 Server Limit Dos1（Apache 所能接受的最大 HTTP 包头大小为 8192 字节（request header） request body 默认最大限制为 2GB）超过指定大小服务器会返回一个 4xx 错误。 正则 ReDOS1一种代码实现上的缺陷，正则表达式写的不好，有可能被恶意输入利用，消耗大量资源，从而造成 DOS。 小结 1 应用层拒绝服务攻击是传统的网络拒绝服务攻击的一种选择，本质也是对有限资源的无限滥用所造成的，解决这个问题的核心思路就是限制每个不可信任的资源使用者的配额。 8. PHP 安全 文件包含漏洞 常见的导致文件包含的函数如下：PHP：include,require,fopen(),readfile();(PHP 内核并不会在意被包含的文件是什么类型)要想成功利用文件包含漏洞，需要满足下面两个条件： include()等函数通过动态变量的方式引入需要包含的文件。 用户能够控制该动态变量。 本地文件包含（LFI）能够打开并包含本地文件的漏洞，被称为本地文件包含漏洞。PHP 配置设置 open_basedir 的作用是限制在某个特定目录下 PHP 能打开的文件，其作用与 safe_mode 是否开启无关。 远程文件包含PHP 的配置选项 allow_url_include 为 ON 的话，则 inlude/require 函数是可以远程加载文件的（RFI）。 PHP 会为上传文件创建临时文件，其目录在 php.ini 的 upload_tmp_dir 中定义，但改值默认为空，此时在 Linux 下回使用 /tmp 目录，在 Windows 下会使用 C:\windows\temp 目录。 变量覆盖漏洞 全局变量覆盖register_globals PHP 配置文件 unset()默认只会销毁局部变量，而要销毁全局变量必须使用 $GLOBALS; extract()变量覆盖 extract() 函数能将变量从数组导入当前的符号表。 遍历初始化变量 常见的一些以遍历的方式释放变量的代码，可能会导致变量覆盖（按下不表）。 import_request_variables 变量覆盖 次函数将 GET,POST,Cookie 中的变量导入到全局。 parse_str()变量覆盖 parse_str() 函数往往被用于解析 URL 的 query string.eg. 123$var = &apos;init&apos;;parse_str($_SERVER[&apos;QUERY_STRING&apos;]);print $var; 防止变量覆盖的安全建议 确保 register_globals = OFF, 若不能自定义 php.ini, 则应该在代码中控制。 熟悉可能造成变量覆盖的函数和方法，检查用户是否能控制变量的来源。 养成初始换变量的好习惯。 代码执行漏洞 phpMyAdmin3.4.3.1 远程代码执行漏洞 MyBB 1.4 远程代码执行漏洞 挖掘漏洞的过程，通常需要先找到危险函数，然后回溯函数的调用过程，最终看在整个调用过程中用户是否有可能控制输入。 “文件写入”执行代码 其他执行代码方式 直接执行代码函数 eval(),assert(),exec(),shell_exec() 文件包含 本地文件写入 preg_replace()代码执行 preg_replace() 的第一个参数如果存在 /e 模式修饰符，则许代码执行。 动态函数执行 Curly Syntax {}将执行花括号间的代码，并将结果替换回去。 回调函数执行代码 unserialize()将导致代码执行 能将序列化的数据重新映射为 PHP 变量。 定制安全的 PHP 环境 register_globals = ON. open_basedir = /home/web/html/(指定目录) allow_url_include = offallow_url_fopen = off. display_errors = off log_errors = on magic_quotes_gpc = OFF. cgi.fix_pathinfo = 0(如果 PHP 以 CGI 的方式安装，则需要关闭此项，以避免出现文件解析问题) session.cookie_httponly = 1 session.cookie_secure = 1. sefe_mode disable_functions 能够在 PHP 中禁用函数disable_functions = eg… 10. WEB SERVER 配置安全 主要有五个方面（详略）1.apache 安全 2.nginx 安全3.jBoss 远程命令执行4.Tomcat 远程命令执行5.HTTP Parameter Pollution(通过 GET 或 POST 向服务器发起请求时，提交两个相同的参数) 入侵检测 常见的安全监控产品有 IDS(入侵检测系统)，IPS(入侵防御系统)，DDOS 监控设备。WAF(web 应用防火墙) ModSecurity:Apache 的一个 Module. 他能获取到所有的访问 Apache Httpd Server 的请求，并根据自己的规则对这些请求进行匹配，以检测那些请求存在攻击行为。 1声明：纯手打总结，劳动不易，转载请附上原文链接。谢谢支持]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>web 安全 协议 HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 配置文件详解（php.ini 详解 )]]></title>
    <url>%2F2017%2F08%2F26%2FPHP-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3%EF%BC%88php.ini-%E8%AF%A6%E8%A7%A3-)%2F</url>
    <content type="text"><![CDATA[[PHP]; PHP 还是一个不断发展的工具，其功能还在不断地删减; 而 php.ini 的设置更改可以反映出相当的变化，; 在使用新的 PHP 版本前，研究一下 php.ini 会有好处的;;;;;;;;;;;;;;;;;;;; 关于这个文件 ;;;;;;;;;;;;;;;;;;;; ; 这个文件控制了 PHP 许多方面的观点。为了让 PHP 读取这个文件，它必须被命名为; ‘php.ini’。PHP 将在这些地方依次查找该文件：当前工作目录；环境变量 PHPRC; 指明的路径；编译时指定的路径。; 在 windows 下，编译时的路径是 Windows 安装目录。; 在命令行模式下，php.ini 的查找路径可以用 -c 参数替代。 ; 该文件的语法非常简单。空白字符和用分号’;’开始的行被简单地忽略（就象你可能 ; 猜到的一样）。 章节标题（例如 : [Foo]）也被简单地忽略，即使将来它们可能; 有某种的意义。;; 指示被指定使用如下语法：; 指示标识符 = 值; directive = value; 指示标识符 是 大小写敏感的 - foo=bar 不同于 FOO = bar。;; 值可以是一个字符串，一个数字，一个 PHP 常量 (如： E_ALL or M_PI), INI 常量中的; 一个 (On, Off, True, False, Yes, No and None) ，或是一个表达式; (如: E_ALL &amp; ~E_NOTICE), 或是用引号括起来的字符串(“ foo”).;; INI 文件的表达式被限制于位运算符和括号。; | bitwise OR; &amp; bitwise AND; ~ bitwise NOT; ! boolean NOT;; 布尔标志可用 1, On, True or Yes 这些值置于开的状态。; 它们可用 0, Off, False or No 这些值置于关的状态。;; 一个空字符串可以用在等号后不写任何东西表示，或者用 None 关键字:;; foo = ; 将 foo 置为空字符串; foo = none ; 将 foo 置为空字符串; foo = “ none” ; 将 foo 置为字符串’none’;; 如果你值设置中使用常量，而这些常量属于动态调入的扩展库（不是 PHP 的扩展，就是; Zend 的扩展），你仅可以调入这些扩展的行 之后 使用这些常量。;; 所有在 php.ini-dist 文件里设定的值与内建的默认值相同（这是说，如果 php.ini; 没被使用或者你删掉了这些行，默认值与之相同）。 ;;;;;;;;;;;;;;;;;;;;; 语言选项 ;;;;;;;;;;;;;;;;;;;;; engine = On; 使 PHP scripting language engine（PHP 脚本语言引擎）在 Apache 下有效。short_open_tag = On; 允许 tags 将被识别。asp_tags = Off; 允许 ASP-style tagsprecision = 14; 浮点类型数显示时的有效位数 y2k_compliance = Off; 是否打开 2000 年适应 (可能在非 Y2K 适应的浏览器中导致问题) output_buffering = Off; 输出缓存允许你甚至在输出正文内容之后发送 header（标头，包括 cookies）行; 其代价是输出层减慢一点点速度。你可以使用输出缓存在运行时打开输出缓存，; 或者在这里将指示设为 On 而使得所有文件的输出缓存打开。output_handler = ; 你可以重定向你的脚本的所有输出到一个函数，; 那样做可能对处理或以日志记录它有用。; 例如若你将这个 output_handler 设为” ob_gzhandler” ,; 则输出会被透明地为支持 gzip 或 deflate 编码的浏览器压缩。; 设一个输出处理器自动地打开输出缓冲。 implicit_flush = Off; 强制 flush（刷新）让 PHP 告诉输出层在每个输出块之后自动刷新自身数据。; 这等效于在每个 print() 或 echo() 调用和每个 HTML 块后调用 flush()函数。; 打开这项设置会导致严重的运行时冲突，建议仅在 debug 过程中打开。 allow_call_time_pass_reference = On; 是否让强迫函数调用时按引用传递参数。这一方法遭到抗议，; 并可能在将来版本的 PHP/Zend 里不再支持。; 受到鼓励的指定哪些参数按引用传递的方法是在函数声明里。; 你被鼓励尝试关闭这一选项并确认你的脚本仍能正常工作，以保证在将来版本的语言里; 它们仍能工作。（你将在每次使用该特点时得到一个警告，而参数将按值而不是按引用; 传递）。 ; Safe Mode 安全模式safe_mode = Offsafe_mode_exec_dir =safe_mode_allowed_envvars = PHP; ？Setting certain environment variables; ？may be a potential security breach.; 该指示包含用逗号分隔的前缀列表。安全模式中，用户仅可以替换; 以在此列出的前缀开头的环境变量的值。; 默认地，用户将仅能 设定以 PHP_开头的环境变量，（如: PHP_FOO=BAR）。; 注意: 如果这一指示为空，PHP 将让用户更改任意环境变量! safe_mode_protected_env_vars = LD_LIBRARY_PATH; 这条指示包含一个用逗号分隔的环境变量列表，那是最终用户将不能用 putenv () 更改的。; 这些变量甚至在 safe_mode_allowed_env_vars 设置为允许的情况下得到保护。 disable_functions =; 这条指示让你可以为了安全的原因让特定函数失效。; 它接受一个用逗号分隔的函数名列表。; 这条指示 不受 安全模式是否打开的影响。 ; 语法高亮模式的色彩。; 只要能被接受的东西就能工作。 highlight.string = #DD0000highlight.comment = #FF8000highlight.keyword = #007700highlight.bg = #FFFFFFhighlight.default = #0000BBhighlight.html = #000000 ; Misc 杂项expose_php = Off; 决定 PHP 是否标示它装在服务器上的事实（例如：加在它 — PHP— 给 Web 服务; 发送的信号上）。; （我个人的意见，在出现什么 power-by 的 header 的时候，把这关掉。）; 它不会有安全上的威胁, 但它使检查你的服务器上是否安装了 PHP 成为了可能。 ;;;;;;;;;;;;;;;;;;;; Resource Limits ;;;;;;;;;;;;;;;;;;;; max_execution_time = 30 ; 每个脚本的最大执行时间, 按秒计memory_limit = 8388608 ; 一个脚本最大可使用的内存总量 (这里是 8MB) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Error handling and logging ;; 出错控制和登记 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 错误报告是按位的。或者将数字加起来得到想要的错误报告等级。; E_ALL - 所有的错误和警告; E_ERROR - 致命性运行时错; E_WARNING - 运行时警告（非致命性错）; E_PARSE - 编译时解析错误; E_NOTICE - 运行时提醒(这些经常是是你的代码的 bug 引起的，; 也可能是有意的行为造成的。(如：基于未初始化的变量自动初始化为一个; 空字符串的事实而使用一个未初始化的变量) ; E_CORE_ERROR - 发生于 PHP 启动时初始化过程中的致命错误; E_CORE_WARNING - 发生于 PHP 启动时初始化过程中的警告(非致命性错); E_COMPILE_ERROR - 编译时致命性错; E_COMPILE_WARNING - 编译时警告(非致命性错); E_USER_ERROR - 用户产生的出错消息; E_USER_WARNING - 用户产生的警告消息; E_USER_NOTICE - 用户产生的提醒消息; 例子:; error_reporting = E_ALL &amp; ~E_NOTICE ; 显示所有的错误，除了提醒; error_reporting = E_COMPILE_ERROR|E_ERROR|E_CORE_ERROR ; 仅显示错误error_reporting = E_ALL &amp; ~E_NOTICE ; 显示所有的错误，除了提醒display_errors = On ; 显示出错误信息(作为输出的一部分); 在最终发布的 web 站点上，强烈建议你关掉这个特性，并使用; 错误日志代替（参看下面）。; 在最终发布的 web 站点继续让 display_errors 有效可能; 暴露一些有关安全的信息，例如你的 web 服务上的文件路径、; 你的数据库规划或别的信息。display_startup_errors = Off ; 甚至当 display_erroes 打开了，发生于 PHP 的启动的步骤中; 的错误也不会被显示。; 强烈建议保持使 display_startup_errors 关闭，; 除了在改错过程中。log_errors = Off ; 在日志文件里记录错误（服务器指定的日志，stderr 标准错误输出，或 error_log(下面的））; 正如上面说明的那样，强烈建议你在最终发布的 web 站点以日志记录错误; 取代直接错误输出。 track_errors = Off ; 保存最近一个 错误 / 警告 消息于变量 $php_errormsg (boolean);error_prepend_string = “ “ ; 于错误信息前输出的字符串;error_append_string = “ “ ; 于错误信息后输出的字符串;error_log = filename ; 记录错误日志于指定文件;error_log = syslog ; 记录错误日志于系统日志 syslog (NT 下的事件日志, Windows 95 下无效)warn_plus_overloading = Off ; 当将‘ +’ 用于字符串时警告 ;;;;;;;;;;;;;;;;;; Data Handling ;;;;;;;;;;;;;;;;;;variables_order = “ EGPCS” ; 这条指示描述了 PHP 记录; GET, POST, Cookie, Environment and Built-in 这些变量的顺序。; （以 G, P, C, E &amp; S 代表，通常以 EGPCS 或 GPC 的方式引用）。; 按从左到右记录，新值取代旧值。 register_globals = On ; 是否将这些 EGPCS 变量注册为全局变量。; 若你不想让用户数据不在全局范围内混乱的话，你可能想关闭它。; 这和 trackvars 连起来用更有意义 — 这样你可以通过; $HTTP*_VARS[] 数组访问所有的 GPC 变量。 register_argc_argv = On ; 这条指示告诉 PHP 是否声明 argv 和 argc 变量; （注：这里 argv 为数组,argc 为变量数）; （其中包含用 GET 方法传来的数据）。; 若你不想用这些变量，你应当关掉它以提高性能。 trackvars = On ; 使 $HTTP_VARS[]数组有效，这里 在使用时用; ENV, POST, GET, COOKIE or SERVER 替换post_max_size = 8M ; PHP 将接受的 POST 数据最大大小。 gpc_order = “ GPC” ; 这条指示被人反对。用 variables_order 代替。 ; Magic quotesmagic_quotes_gpc = On ; 在输入的 GET/POST/Cookie 数据里使用魔术引用 ; （原文就这样，呵呵，所谓 magic quotes 应该是指用转义符加在引用性的控制字符上，如 ‘….）magic_quotes_runtime= Off ; 对运行时产生的数据使用魔术引用，; 例如：用 SQL 查询得到的数据，用 exec() 函数得到的数据，等等magic_quotes_sybase = Off ; 采用 Sybase 形式的魔术引用（用 ‘’ 脱出 ‘ 而不用 ‘） ; 自动在 PHP 文档之前和之后添加文件auto_prepend_file =auto_append_file = ; 象 4.04b4 一样，PHP 默认地总是在 “ Content-type:” 头标输出一个字符的编码方式。; 让输出字符集失效，只要设置为空。; PHP 的内建默认值是 text/htmldefault_mimetype = “ text/html”;default_charset = “ iso-8859-1” ;;;;;;;;;;;;;;;;;;;;;;;;;; Paths and Directories ;;;;;;;;;;;;;;;;;;;;;;;;;;include_path = ; include 路径设置，UNIX: “ /path1:/path2” Windows: “ \path1;\path2”doc_root = ; php 页面的根路径，仅在非空时有效 user_dir = ; 告知 php 在使用 /~username 打开脚本时到哪个目录下去找，仅在非空时有效;upload_tmp_dir = ; 存放用 HTTP 协议上载的文件的临时目录（在没指定时使用系统默认的）upload_max_filesize = 2097152 ; 文件上载默认地限制为 2 Megextension_dir = c:\php\ ; 存放可加载的扩充库（模块）的目录enable_dl = On ; 是否使 dl() 有效。; 在多线程的服务器上 dl()函数 不能 很好地工作，; 例如 IIS or Zeus，并在其上默认为禁止 ;;;;;;;;;;;;;;;;; File Uploads ;;;;;;;;;;;;;;;;;file_uploads = On ; 是否允许 HTTP 方式文件上载;upload_tmp_dir = ; 用于 HTTP 上载的文件的临时目录（未指定则使用系统默认）upload_max_filesize = 2M ; 上载文件的最大许可大小 ; Fopen wrappers ;;;;;;;;;;;;;;;;;;;allow_url_fopen = On ; 是否允许把 URLs 当作 http:.. 或把文件当作 ftp:… ;;;;;;;;;;;;;;;;;;;;;;; 动态扩展 ;; Dynamic Extensions ;;;;;;;;;;;;;;;;;;;;;;;; 若你希望一个扩展库自动加载，用下面的语法：; extension=modulename.extension; 例如，在 windows 上，; extension=msql.dll; or 在 UNIX 下,; extension=msql.so; 注意，这只应当是模块的名字，不需要目录信息放在里面。; 用上面的 extension_dir 指示指定扩展库的位置。 ;Windows 扩展;extension=php_nsmail.dllextension=php_calendar.dll;extension=php_dbase.dll;extension=php_filepro.dllextension=php_gd.dll;extension=php_dbm.dll;extension=php_mssql.dll;extension=php_zlib.dll;extension=php_filepro.dll;extension=php_imap4r2.dll;extension=php_ldap.dll;extension=php_crypt.dll;extension=php_msql2.dll;extension=php_odbc.dll; 注意， MySQL 的支持现在是内建的，因此，不需要用它的 dll ;;;;;;;;;;;;;;;;;;;; 模块设定 ;; Module Settings ;;;;;;;;;;;;;;;;;;;; [Syslog]define_syslog_variables = Off ; 是否定义各种的系统日志变量; 如：$LOG_PID, $LOG_CRON, 等等。; 关掉它是个提高效率的好主意。; 运行时，你可以调用函数 define_syslog_variables()，来定义这些变量 [mail function]SMTP = localhost ; 仅用于 win32 系统sendmail_from = me@localhost.com ; 仅用于 win32 系统;sendmail_path = ; 仅用于 unix, 也可支持参数（默认的是’sendmail -t -i’） [Debugger]debugger.host = localhostdebugger.port = 7869debugger.enabled = False [Logging]; 这些配置指示用于示例的日志记录机制。; 看 examples/README.logging 以得到更多的解释;logging.method = db;logging.directory = /path/to/log/directory [Java];java.class.path = .\php_java.jar;java.home = c:\jdk;java.library = c:\jdk\jre\bin\hotspot\jvm.dll;java.library.path = .\ [SQL]sql.safe_mode = Off [ODBC];uodbc.default_db = Not yet implemented;uodbc.default_user = Not yet implemented;uodbc.default_pw = Not yet implementeduodbc.allow_persistent = On ; 允许或禁止 持久连接uodbc.check_persistent = On ; 在重用前检查连接是否还可用uodbc.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制uodbc.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制uodbc.defaultlrl = 4096 ; 控制 LONG 类型的字段。返回变量的字节数，0 代表通过（？）0 means passthruuodbc.defaultbinmode = 1 ; 控制 二进制数据。0 代表?????Handling of binary data. 0 means passthru, 1 return as is, 2 convert to char; 见有关 odbc_binmode 和 odbc_longreadlen 的文档以得到 uodbc.defaultlrl 和 uodbc.defaultbinmode 的解释。 [MySQL]mysql.allow_persistent = On ; 允许或禁止 持久连接mysql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制mysql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制mysql.default_port = ; mysql_connect() 使用的默认端口，如不设置，mysql_connect(); 将使用变量 $MYSQL_TCP_PORT，或在 /etc/services 下的 mysql-tcp 条目(unix)，; 或在编译是定义的 MYSQL_PORT(按这样的顺序); Win32 环境，将仅检查 MYSQL_PORT。mysql.default_socket = ; 用于本地 MySql 连接的默认的套接字名。为空，使用 MYSQL 内建值 mysql.default_host = ; mysql_connect() 默认使用的主机（安全模式下无效）mysql.default_user = ; mysql_connect() 默认使用的用户名（安全模式下无效）mysql.default_password = ; mysql_connect() 默认使用的密码（安全模式下无效）; 注意，在这个文件下保存密码通常是一个 坏主意 ; 任何 可以使用 PHP 访问的用户可以运行; ‘echo cfg_get_var(“ mysql.default_password”)’来显示那个密码!; 而且当然地，任何有读该文件权力的用户也能看到那个密码。 [mSQL]msql.allow_persistent = On ; 允许或禁止 持久连接msql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制msql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制 [PostgresSQL]pgsql.allow_persistent = On ; 允许或禁止 持久连接pgsql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制pgsql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制 [Sybase]sybase.allow_persistent = On ; 允许或禁止 持久连接sybase.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制sybase.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制;sybase.interface_file = “ /usr/sybase/interfaces”sybase.min_error_severity = 10 ; 显示的错误的最低严重性sybase.min_message_severity = 10 ; 显示的消息的最低重要性sybase.compatability_mode = Off ; 与旧版的 PHP 3.0 兼容的模式。若打开，这将导致 PHP 自动地; 把根据结果的 Sybase 类型赋予它们，; 而不是把它们全当成字符串。; 这个兼容模式不会永远留着，; 因此，将你的代码进行需要的修改，; 并将该项关闭。 [Sybase-CT]sybct.allow_persistent = On ; 允许或禁止 持久连接sybct.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制sybct.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制sybct.min_server_severity = 10 ; 显示的错误的最低严重性sybct.min_client_severity = 10 ; 显示的消息的最低重要性 [bcmath]bcmath.scale = 0 ; 用于所有 bcmath 函数的 10 十进制数数字的个数 number of decimal digits for all bcmath functions [browscap];browscap = extra/browscap.inibrowscap = C:\WIN\SYSTEM\inetsrv\browscap.ini[Informix]ifx.default_host = ; ifx_connect() 默认使用的主机（安全模式下无效）ifx.default_user = ; ifx_connect() 默认使用的用户名（安全模式下无效）ifx.default_password = ; ifx_connect() 默认使用的密码（安全模式下无效）ifx.allow_persistent = On ; 允许或禁止 持久连接ifx.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制ifx.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制ifx.textasvarchar = 0 ; 若打开，select 状态符返回一个 ‘ text blob’ 字段的内容，而不是它的 idifx.byteasvarchar = 0 ; 若打开，select 状态符返回一个 ‘ byte blob’ 字段的内容，而不是它的 idifx.charasvarchar = 0 ; 追踪从固定长度的字符列里剥离的空格。; 可能对 Informix SE 用户有效。ifx.blobinfile = 0 ; 若打开，text 和 byte blobs 的内容被导出到一个文件; 而不是保存到内存。ifx.nullformat = 0 ; NULL（空）被作为空字段返回，除非，这里被设为 1。; 这种情况下（为 1），NULL 作为字串 NULL 返回。 [Session]session.save_handler = files ; 用于保存 / 取回数据的控制方式session.save_path = C:\win\temp ; 在 save_handler 设为文件时传给控制器的参数，; 这是数据文件将保存的路径。session.use_cookies = 1 ; 是否使用 cookiessession.name = PHPSESSID; 用在 cookie 里的 session 的名字session.auto_start = 0 ; 在请求启动时初始化 sessionsession.cookie_lifetime = 0 ; 为按秒记的 cookie 的保存时间，; 或为 0 时，直到浏览器被重启session.cookie_path = / ; cookie 的有效路径session.cookie_domain = ; cookie 的有效域session.serialize_handler = php ; 用于连接数据的控制器; php 是 PHP 的标准控制器。session.gc_probability = 1 ; 按百分比的’garbage collection（碎片整理）’进程; 在每次 session 初始化的时候开始的可能性。session.gc_maxlifetime = 1440 ; 在这里数字所指的秒数后，保存的数据将被视为; ‘碎片(garbage)’并由 gc 进程清理掉。session.referer_check = ; 检查 HTTP 引用以使额外包含于 URLs 中的 ids 无效session.entropy_length = 0 ; 从文件中读取多少字节session.entropy_file = ; 指定这里建立 session id; session.entropy_length = 16; session.entropy_file = /dev/urandomsession.cache_limiter = nocache ; 设为{nocache,private,public}, 以决定 HTTP 的; 缓存问题session.cache_expire = 180 ; 文档在 n 分钟后过时session.use_trans_sid = 1 ; 使用过渡性的 sid 支持，若编译时许可了; –enable-trans-sidurl_rewriter.tags = “ a=href,area=href,frame=src,input=src,form=fakeentry” [MSSQL];extension=php_mssql.dllmssql.allow_persistent = On ; 允许或禁止 持久连接mssql.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制mssql.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制mssql.min_error_severity = 10 ; 显示的错误的最低严重性mssql.min_message_severity = 10 ; 显示的消息的最低重要性mssql.compatability_mode = Off ; 与旧版的 PHP 3.0 兼容的模式。 [Assertion]; ？？？？？;assert.active = On ; ？assert(expr); active by default;assert.warning = On ; issue a PHP warning for each failed assertion.;assert.bail = Off ; don’t bail out by default.;assert.callback = 0 ; user-function to be called if an assertion fails.;assert.quiet_eval = 0 ; eval the expression with current error_reporting(). set to trueif you want error_reporting(0) around the eval(). [Ingres II]ii.allow_persistent = On ; 允许或禁止 持久连接ii.max_persistent = -1 ; 持久连接的最大数。-1 代表无限制ii.max_links = -1 ; 连接的最大数目（持久和非持久）。-1 代表无限制ii.default_database = ; 默认 database (format : [node_id::]dbname[/srv_class]ii.default_user = ; 默认 userii.default_password = ; 默认 password [Verisign Payflow Pro]pfpro.defaulthost = “ test.signio.com” ; 默认的 Signio 服务器pfpro.defaultport = 443 ; 连接的默认端口pfpro.defaulttimeout = 30 ; 按秒计的默认超时时间 ; pfpro.proxyaddress = ; 默认的代理的 IP 地址（如果需要）; pfpro.proxyport = ; 默认的代理的端口; pfpro.proxylogon = ; 默认的代理的登录（logon 用户名）; pfpro.proxypassword = ; 默认的代理的密码 [Sockets]sockets.use_system_read = On ; 使用系统的 read() 函数替代 php_read()封装; Local Variables: （局部变量）; tab-width: 4; End]]></content>
      <categories>
        <category>PHP转载</category>
      </categories>
      <tags>
        <tag>php.ini 转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php.ini 中 safe_mode 开启对 PHP 系统函数的影响]]></title>
    <url>%2F2017%2F08%2F26%2Fphp.ini%E4%B8%ADsafe_mode%E5%BC%80%E5%90%AF%E5%AF%B9PHP%E7%B3%BB%E7%BB%9F%E5%87%BD%E6%95%B0%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[​ 开启之后，主要会对系统操作、文件、权限设置等方法产生影响，平常项目基本上也用不到这些方法。主要我想还是用来应对 webshell 吧，减少被人植入 webshell 所带来的某些安全问题。 http://www.[PHP](http://lib.csdn.net/base/php).net/manual/zh/ini.sect.safe-mode.[php](http://lib.csdn.net/base/php) php safe_mode 影响参数 函数名 限制 dbmopen() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。dbase_open() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 filepro() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。filepro_rowcount() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。filepro_retrieve() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 ifx_ sql_safemode 限制, (!= safe mode)ingres sql_safemode 限制, (!= safe mode)mysql* sql_safe_mode 限制, (!= safe mode)pg_loimport() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。posix_mkfifo() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 putenv() 遵循 ini 设置的 safe_mode_protected_env_vars 和 safe_mode_allowed_env_vars 选项。请参考 putenv() 函数的有关文档。move_uploaded_file() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 chdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。dl() 本函数在安全模式下被禁用。backtick operator 本函数在安全模式下被禁用。shell_exec()（在功能上和 backticks 函数相同） 本函数在安全模式下被禁用。exec() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。system() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。passthru() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。popen() 只能在 safe_mode_exec_dir 设置的目录下进行执行操作。基于某些原因，目前不能在可执行对象的路径中使用 ..。escapeshellcmd() 将被作用于此函数的参数上。fopen() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。mkdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。rmdir() 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。rename() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 unlink() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。copy() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 (on source and target)chgrp() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。chown() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。chmod() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 另外，不能设置 SUID、SGID 和 sticky bitstouch() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。symlink() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅 测试 target）link() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意：仅测试 target） apache_request_headers() 在安全模式下，以“authorization”（区分大小写）开头的标头将不会被返回。header() 在安全模式下，如果设置了 WWW-Authenticate，当前脚本的 uid 将被添加到该标头的 realm 部分。PHP_AUTH 变量 在安全模式下，变量 PHP_AUTH_USER、PHP_AUTH_PW 和 PHP_AUTH_TYPE 在 $_SERVER 中不可用。但无论如何，您仍然可以使用 REMOTE_USER 来获取用户名称（USER）。（注意：仅 PHP 4.3.0 以后有效） highlight_file(), show_source() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效）parse_ini_file() 检查被操作的文件或目录是否与正在执行的脚本有相同的 UID（所有者）。 检查被操作的目录是否与正在执行的脚本有相同的 UID（所有者）。 （注意，仅在 4.2.1 版本后有效） set_time_limit() 在安全模式下不起作用。max_execution_time 在安全模式下不起作用。mail() 在安全模式下，第五个参数被屏蔽。]]></content>
      <categories>
        <category>PHP转载</category>
      </categories>
      <tags>
        <tag>php.ini  safe_mode 配置 转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql 之 ZEROFILL 数据类型属性补 0 操作]]></title>
    <url>%2F2017%2F08%2F17%2FMysql%E4%B9%8BZEROFILL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%B1%9E%E6%80%A7%E8%A1%A50%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[建一张数据表 ‘t’: 查看一下表的数据结构： mysql&gt; select * from t;+——+——+| a | b |+——+——+| 1 | 2 |+——+——+1 row in set (0.03 sec)mysql&gt; desc t;+——-+——————+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+——————+——+—–+———+——-+| a | int(10) unsigned | YES | | NULL | || b | int(10) unsigned | YES | | NULL | |+——-+——————+——+—–+———+——-+2 rows in set (0.03 sec) 我们可以看到 a,b 字段的数据类型都是 int(10); 接下来让我们改变一下 a 列的数据类型属性。 mysql&gt; alter table t change column a a int(4) unsigned zerofill;Query OK, 0 rows affected (0.07 sec)Records: 0 Duplicates: 0 Warnings: 0 为 a 字段添加了 zerofill 属性，并将默认的 int(10) 修改为 int(4). 查看表的数据结构： mysql&gt; select * from t;+——+——+| a | b |+——+——+| 0001 | 2 |+——+——+1 row in set (0.03 sec) mysql&gt; desc t;+——-+————————–+——+—–+———+——-+| Field | Type | Null | Key | Default | Extra |+——-+————————–+——+—–+———+——-+| a | int(4) unsigned zerofill | YES | | NULL | || b | int(10) unsigned | YES | | NULL | |+——-+————————–+——+—–+———+——-+2 rows in set (0.04 sec) 这就是 zerofill 属性的作用，如果宽度小于设定的宽度，则自动填充 0. 注意 ： 在 MySQL 中 a 字段实际存储的还是 1. 可用 hex 函数证明. mysql&gt; select a,hex(a) from t;+——+——–+| a | hex(a) |+——+——–+| 0001 | 1 |+——+——–+1 row in set (0.03 sec) 可以推测出 a 字段中的 0001 值的改变只是设置了 zerofill 属性后的一种格式化输出而已. 但为了一些业务的需求问题提供了一个很好的解决办法.]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>mysql 字段类型属性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月专业书籍读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E4%B8%93%E4%B8%9A%E4%B9%A6%E7%B1%8D%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[程序员的思维修炼：开发认知潜能的九堂课 亨特 自由的代价是永远提高警惕。 ——约翰•菲尔波特•柯伦的名言, 1790 年 ​ 对于专家来说最致命的弱点是像专家一样行动。一旦你相信自己的专业水平，你就会对其他的可能性视而不见。你停止了好奇心。你可能开始抵制所属领域的改变，担心在你花费了很多努力才得以精通的主题上失去权威。你自己的判断和看法不再支持你，而是囚禁你。 不管你能做什么，或者期望自己能做什么，现在就开始做。勇敢可以给人智慧、力量和神奇。现在就开始做吧。 ——歌德 ​ 如果某个任务你真的不想做，那么任何分散注意力的努力都很可能只是耗费时间。如果你仍然有兴趣，但感觉“困难”，那么思想其实是在继续发酵，这当然没问题。​ 好问题是没有答案的。它不是一个需要拧紧的螺栓，而是一颗种下的种子，由它可以收获一片思想的绿洲。 ——约翰•安东尼•查尔迪（John Anthony Ciardi，1916—1986），美国诗人和评论家 ​ 看法是基于预测的。 Perception is based on prediction.​ 很多感知是基于预测的，预测则基于情境和过去的经验，以至于当前的、实时的输入被抛在了后面。​ 认知胜过尝试 ​ 开头把事情做好并不重要，重要的是最后把事情做好。在任何不平凡的工作中，你都会犯错误。​ 错误有益于我们，因为它们让我们思索到底发生了什么，知道什么地方错了，然后通过理解，纠正它。​ 他人即地狱（L’enfer, c’est les autres）。 ——让•保罗•萨特，法国思想家、作家、存在主义哲学大师 ​ 在你出生时，世界上的任何事情都是平凡的，都是世界运转的天然组成部分。当你在十五岁到三十五岁之间时，世界上创造出的任何事物都是新鲜的、令人振奋的、革命性的，你可能以此为职业。三十五岁之后创造出的任何事物都是有悖于事物的自然顺序的。 ——道格拉斯•亚当斯，《怀疑的鲑鱼》​ ，并将它们组装成最合适的表现形式，这就是创作。​ 创造来自于选择和组装，它要选择最合适的部 ​ 设计并不是创造美，美来自于选择、共鸣、同化和爱 ​ 达尔文说过：“无知往往来自于自信而不是知识。 黑客与画家 –保罗·格雷厄姆 以绘画为例，文艺复兴时期就有人发现了这一点。如今，几乎所有的美术老师都会告诉你准确画出一个事物的方法，不是沿着轮廓慢慢一个部分、一个部分地把它画出来，因为这样的话各个部分的错误会累积起来，最终导致整幅画失真。你真正应该采用的方法是快速地用几根线画出一个大致准确的轮廓，然后再逐步地加工草稿。 ​ 「“弱即是强”指的是一种软件传播的模式，由 Common Lisp 专家理査德·加布里埃尔（Richard P. Gabriel）于 1991 年在 Lisp: Good News, Bad News, How to Win Big（http://www.dreamsongs.com/WIB.html）一文中首先提出。它的含义非常广泛，涉及软件设计思想的各个方面，其中的一个重要结论就是软件功能的增加并不必然带来质量的提高。有时候，更少的功能（“弱”）反而是更好的选择（“强”），因为这会使得软件的可用性提高。相比那些体积庞大、功能全面、较难上手的软件，一种功能有限但易于使用的软件可能对用户有更大的吸引力 任何 C 或 Fortran 程序复杂到一定程度之后，都会包含一个临时开发的、只有一半功能的、不完全符合规格的、到处都是 bug 的、运行速度很慢的 Common Lisp 实现 大公司可以互相模仿，但是创业公司就不行。我觉得很多人没有意识到这一点，尤其是一些创业者 essay（论文）这个词来自法语的动词 essayer，意思是“试试看”。从这个原始意义来说，论文就是你写一篇文章，试着搞清楚某件事。 设计编程语言的时候，我们应该有意识地问自己，什么时候可以放弃一些性能，换来一点点便利性的提高。 编译器不是高级语言唯一的实现方法，另一种方法是使用解释器，它的作用是实时地将代码解释为相应的机器语言，然后一行行运行。相比之下，编译器则是先将整个程序全部翻译成机器语言，然后再运行。 所谓“编译器”，本身就是一个程序，作用是将简便方式书写的程序（就像上面这一行命令）转变为硬件可以理解的语言。 推动人才成批涌现的最大因素就是，让有天赋的人聚在一起，共同解决某个难题。 科学和工程学的一些最重大的发现在形式上往往很简单，会使得你觉得自己也想到过。 德国包豪斯（Bauhaus）学派的设计师采纳了美国建筑师路易斯·沙利文（Louis Sullivan）的观点“功能决定形式”（form follows function）， 但是他们实际上的理解是“功能应当决定形式”^。真实情况是，如果开发“功能”非常艰难，那么“形式”将不得不全部都由“功能”决定，因为没有多余的精力再来单独开发“形式”了。人们常常觉得野生动物非常优美，原因就是它们的生活非常艰苦，在外形上不可能有多余的部分了。 当你被迫把东西做得很简单时，你就被迫直接面对真正的问题。当你不能用表面的装饰交差时，你就不得不做好真正的本质部分。 ​ 一个社会需要有富人，这主要不是因为你需要富人的支出创造就业机会，而是因为他们在致富过程做出的事情。 ​ 技术的发展加大了贫富差距，这是不是一个社会问题？好像没有那么严重。技术在加大收入差距的同时，缩小了大部分的其他差距 ​ 在现实中，财富是用工作成果衡量的，而不是用它花费的成本衡量的。如果我用牙刷油漆房屋，屋主也不会付给我额外工资的 ​ ，他一个人的价值真的等于我们 100 个人的价值吗？你想一想，一个篮球队会同意用一个运动员交换 100 个普通人吗？如果苹果公司不是由乔布斯掌管，而是由一个 100 人组成的委员会掌管，那么这家公司的下一代产品会是什么样 ^？人与人之间的差别并不是那么稳定的线性关系。也许 CEO 和运动员的技能和决心只比普通人高出 10 倍（倍数不重要），但是人与人之间就是存在着重大差别。 ​ 每个人的技能不同，导致收入不同，这才是贫富分化的主要原因，正如逻辑学的“奥卡姆剃刀”原则所说，简单的解释就是最好的解释。 为什么财富的分配问题引起这么多争论？部分原因是反对声最大的人当中，很多人都少有创造财富的经验：大学生、继承人、教授、政客、新闻记者。（如果你在酒吧里听过大家议论体育赛事，你一定很熟悉这种现象。） ​ 一旦自己的财产有了保证，那些想致富的人就会愿意去创造财富，而不是去偷窃。由此导致的新技术不仅被转化成财富，还被转化成军事力量。隐形飞机的理论是由前苏联数学家提出的，但是因为前苏联没有计算机工业，它就只能是一个理论，无法变成产品。前苏联没有足够快的硬件来完成设计飞机所需要的大量计算。 ​ 理解这些有助于回答一个重要的问题：为什么欧洲在历史上变得如此强大？是因为欧洲优越的地理位置，还是因为欧洲人天生就比较优秀，或者是宗教原因？答案（或者至少是近因）可能就是欧洲人接受了一个威力巨大的新观点：允许赚到大钱的人保住自己的财富。 ​ 缓慢工作的后果并不仅仅是延迟了技术革新，而且很可能会扼杀技术革新。只有在快速获得巨大利益的激励下，你才会去挑战那些困难的问题，否则你根本不愿意去碰它们。开发新技术是非常痛苦的经历，正如爱迪生所说，百分之一的灵感加上百分之九十九的汗水。没有财富的激励，就不会有人愿意去做技术革新。工程师愿意接受普通薪水去做一些诱人的项目（比如战斗机和登月火箭），而与日常生活关系更密切的技术革新（比如电灯泡和半导体）只能由创业者来发明。 ​ 「充分条件在这里可能也成立。但是如果成立的话，为什么工业革命没有早一点发生呢？两个可能的（但是互相排斥的）解释是：（a）变化其实早发生了，工业革命只是一系列革命中的一环，（b）中世纪的城镇存在垄断经营和行会制度，延缓了新生产方式的诞生。」 ​ 创造财富不是致富的唯一方法。在人类的历史长河中，它甚至不是最常见的方法。就在几个世纪前，财富的主要来源还是矿石、奴隶、农奴、土地、牲畜，而快速获得财富的方法只有继承、婚姻、征服、没收。所以，很自然地，财富的名声不好。 ​ ^「平均数（mean）是算数平均值，会受到个别极端值的影响，中位数（median）是最中间的那个值，不受个别极端值的影响。所以，这句话的意思就是，由于存在个别极其成功的创业者，所以回报的平均值被拉到了 30 倍，但是大多数创业者其实都以失败告终，所以中位数是 0。——译者注」 「近代历史上，政府有时都搞不清楚金钱和财富的区别。亚当·斯密在《国富论》中提到，许多国家政府为了保住“财富”，禁止出口白银或者黄金。但是，黄金和白银实际上只是一种交换媒介，留住它们并不会让一个国家变得更富有。如果物质财富保持不变，金钱越多，导致的唯一结果就是物价越高。」 ​ 经济学里有一条拉弗曲线（Laffer curve），认为随着税率的上升，税收收入会先增加后减少。 1989 年，一些聪明的研究人员设计了一个实验，给放射科医生看胸部 X 光片，请他们判断病人有没有肺癌迹象。研究人员记录了医生检査 X 光片时的眼球运动 ^。研究发现，即使那些医生漏掉了一个癌症病灶，他们的目光通常也会在那个地方停留一会。这说明他们的头脑深处已经意识到那里有问题，但是这种深层的反应没有上升为自觉的意识。我认为，类似的思维机制存在于每个人的头脑中，很多看似叛逆的“异端邪说”，早就“潜伏”在我们的思维深处。如果我们暂时关闭自我审查意识，它们就会第一个浮现出来。 ​ 大公司为了避免设计上的灾难，选择了减少设计结果的标准差。但是当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。这对大公司来说不是问题，因为生产特别优秀的产品不是它们的获胜手段。大公司只要做到不太烂，就能赢。 「塞缪尔·约翰逊在他编辑的《莎士比亚戏剧集》的前言中写道：“他（莎士比亚）的影响远远超过他的时代，时间就是对他文学成就的检验。不管他的作品从那时的暗语、风俗、政治局势之中，得到过怎样的优势，这些优势都已经消逝多年了。他在毎一幕戏剧中，通过模拟那时的生活所产生的每一个欢乐的主题或悲伤的动机，都已经趋于平淡，而不再是戏剧的亮点。贵族的宠爱和对手的竞争，都不再产生效果，朋友和敌人都走进了坟墓，他的作品再也不是支持一方、打击另一方的舆论工具；它们既不能产生虚名，也不会带来恶意的攻击。人们阅读这些作品，只有一个理由，那就是欣赏作品本身。因此，只有人们真正欣赏它们，才会发出赞美……”」 塞缪尔·约翰逊 ^ 说过，人们对一个作家的评价，需要 100 年才能达成一致 ^^。你必须先等他的那些有影响力的朋友都死了，然后再等他的追随者都死了，才能对他有一个公正的评价。 当工作的专业程度越来越高时，我们就必须接受更长时间的训练。工业化时代来临之前，儿童最晚大约在 14 岁就要参加工作，如果是在农庄（那个时代大多数人生活在农村），参加工作的时间就更早。如今，只要一个青少年读大学，他就要等到 21 岁或 22 岁才开始全职工作。如果再读更髙的学位，比如医学博士或哲学博士，可能要拖到 30 岁才能完成学业。 这些场合的成员都好像关在封闭的泡沫之中，所作所为只对泡沫内部有影响，对外部没有影响。那么很自然地，这些场合就会产生野蛮的做法。因为它们不具备实际功能，所以也就无所谓采用的形式 ^。 你的灯亮着吗？：发现问题的真正所在 唐纳德·高斯 人们永远没有足够的时间去考虑到底是不是想要它，但永远有足够的时间去为之后悔 ​ 但在更多情况下，交流不畅不是困难的根源。对于不了解的事情，或者不想了解的事情，人们无法有效交流。​ 大多数情况下，问题的根源在你自己身上。​ 在社会上，很多问题源自系统的设计者和决策者，他们并未亲身体会过应该由他们“负责任”的问题。​ 只要可行，人们会首先把问题置于让自己觉得最舒适的语义层面上 ​ 每转换一次视角，都会发现新的不协调之处。 在把一项“解决方案”付诸实践之前从各个视角对其审视一遍，不是比等到出现灾难性后果才意识到问题存在好得多吗？​ 在这次大型“实验”之前，没有人确切知道为什么每年有 50000 人死在高速公路上。汽车制造商归罪于司机，与制酒业无关的所有人指责醉酒驾驶者是罪魁祸首，但从没有人因为立法者设定了如此之高的车速上限而责怪他们。​ 每一个解决方案都是下一个问题的来源。 我们永远都没法避开问题。问题、解决方案、新问题循环出现，构成了无尽的链条。能指望的最理想状态就是新问题比我们“已经解决”的问题要好对付一些。​ 问题就是理想状态和现实状态之间的差别。 人月神话 –弗雷德里克·布鲁克斯 人件：高生产率的项目和团队 ​ 编程人员被屏蔽而不是暴露在他人模块内部结构面前。这种情况下，工作效率最高 ​ 老板的不良反应肯定会对信息的完全公开造成压制；相反，仔细区分状态报告、毫无惊慌地接收报告、决不越俎代庖，将能鼓励诚实的汇报。​ 状态的获取是困难的，因为下属经理有充分的理由不提供信息共享 ​ 系统文档中的巨大容量带来了新的不理解问题 [例如，看看 Unix]，但是它比大多数未能详细描述编程系统特性的短小文章更加可取。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。​ 很容易为不同的晋升线建立相互一致的薪水级别，但要同等威信的建立需要一些强烈的心理措施：相同的办公室、一样的支持和技术调动的优先补偿 ​ 目标上（和开发策略上）的一些正常变化无可避免，事先为它们做准备总比假设它们不会出现要好得多。​ 户的实际需要和用户感觉会随着程序的构建、测试和使用而变化 ​ 将开发的第一个系统–丢弃原型–发布给用户，可以获得时间，但是它的代价高昂–对于用户，使用极度痛苦；对于重新开发的人员，分散了精力；对于产品，影响了声誉，即使最好的再设计也难以挽回名声 ​ 对于大多数项目，第一个开发的系统并不合用。它可能太慢、太大，而且难以使用，或者三者兼而有之。​ 一位首席程序员、类似于外科手术队伍的团队架构提供了一种方法–既能获得由少数头脑产生的产品完整性，又能得到多位协助人员的总体生产率，还彻底地减少了沟通的工作量。​ 向软件项目中增派人手从三个方面增加了项目必要的总体工作量：任务重新分配本身和所造成的工作中断；培训新人员；额外的相互沟通。​ 2.10 因为我们对自己的估计技术不确定，所以在管理和客户的压力下，我们常常缺乏坚持的勇气。 2.11 Brook 法则：向进度落后的项目中增加人手，只会使进度更加落后。​ 在若干人员中分解任务会引发额外的沟通工作量–培训和相互沟通。 2.8 关于进度安排，我的经验是为 1/3 计划、1/6 编码、1/4 构件测试以及 1/4 系统测试。​ 良好的烹饪需要时间，某些任务无法在不损害结果的情况下加快速度。​ .. 任何创造性活动都伴随着枯燥艰苦的劳动，编程也不例外 ​ 。实际上，类的容易重用和通过继承方便地定制是面向对象技术最吸引人的地方 ​ 在所有被误导的科学探索中，最悲惨的莫过于对一种能够将一般金属变成金子的物质，即点金石的研究。这个由统治者不断地投入金钱，被一代代的研究者不懈追求的、炼金术中至高无上的法宝，是一种从理想化想象和普遍假设中–以为事情会像我们所认为的那样–提取出的精华。它是人类纯粹信仰的体现，人们花费了大量的时间和精力来认可和接受这个无法解决的问题。即使被证明是不存在，那种寻找出路和希望能一劳永逸的愿望，依然十分的强烈。而我们中的绝大多数总是很同情这些明知不可为而为之的人，因此它们总是得以延续。所以，将圆形变方的论文被发表，恢复脱发的洗液被研制和出售，提高软件生产率的方法被提出并成功地推销。​ 在软件开发中，我称为”必要（essence）”的部分是构思这些概念上的结构；我称为”次要（accident）”的部分指它的实现过程。​ 那些想看到完美方案的人，其实在心底里就认为它们以前不存在，以后也不可能出现。 - 亚历山大·波普，批判散文 ​ 没有任何软件机构可以忽视这项挑战。尽管公司可能缺少良好的管理人员，但决不会比良好设计人员的需求更加迫切，而卓越的管理人员和设计人员都是非常缺乏的。大多数机构花费了大量的时间和精力来寻找和培养管理人员，但据我所知，它们中间没有任何的一家在寻求和培育杰出的设计人员上投入相同的资源，而产品的技术特色最终依赖于这些设计人员。​ 其中的差异并不小–就象萨列里和莫扎特。一个接一个的研究显示，非常卓越的设计者产生的成果更快、更小、更简单、更优雅，实现的代价更少。卓越和一般之间的差异接近于一个数量级。​ 。低劣设计和良好设计之间的区别可能在于设计方法中的完善性，而良好设计和卓越设计之间的区别肯定不是如此。卓越设计来自卓越的设计人员。软件开发是一个创造性的过程。完备的方法学可以培养和释放创造性的思维，但它无法孕育或激发创造性的过程。​ 无限扩展。日常生活中，建筑有可能发生变化，但众所周知，建筑修改的成本很高，从而打消了那些想提出修改的人的念头。​ 所有成功的软件都会发生变更。现实工作中，经常发生两种情况。当人们发现软件很有用时，会在原有应用范围的边界，或者在超越边界的情况下使用软件。功能扩展的压力主要来自那些喜欢基本功能，又对软件提出了很多新用法的用户们。​ 自文档化方法 ​ 不了解，就无法真正拥有。 - 歌德 ​ 减少角色的冲突。首先老板必须区别行动信息和状态信息。他必须规范自己，不对项目经理可以解决的问题做出反应，并且决不在检查状态报告的时候做安排。我曾经认识一个老板，他总是在状态报告的第一个段落结束之前，拿起电话发号施令。这样的反应肯定压制信息的完全公开。​ 关键的地方和构建无 bug 程序的核心，是把系统的结构作为控制结构来考虑，而不是独立的跳转语句。这种思考方法是我们在程序设计发展史上向前迈出的一大步 ​ 我能召唤遥远的精灵。 那又怎么样，我也可以，谁都可以，问题是你真的召唤的时候，它们会来吗？ - 莎士比亚，《亨利四世》，第一部分 ​ 这正是历史的关键。使用卓越的能源–构建文明–成立杰出的机构，但是每次总会出现问题。一些致命的缺陷会将自私和残酷的人带到塔尖，接着一切开始滑落，回到到痛苦和堕落。实际上，机器失灵了。看上去，就好像是机器正常启动，跑了几步，然后垮掉了 7。​ 对于一个广泛使用的程序，其维护总成本通常是开发成本的 40％或更多。令人吃惊的是，该成本受用户数目的严重影响。用户越多，所发现的错误也越多。​ 不过，他提出了一种卓越的见解。他观察到不愿意为设计书写文档的原因，不仅仅是由于惰性或者时间压力。相反，设计人员通常不愿意提交尝试性的设计决策，再为它们进行辩解。”通过设计文档化，设计人员将自己暴露在每个人的批评之下，他必须能够为他的每个结果进行辩护。如果团队架构因此受到任何形式的威胁，则没有任何东西会被文档化，除非架构是完全受到保护的 ​ 数据的表现形式是编程的根本 ​ 规格说明的风格必须清晰、完整和准确。用户常常会单独提到某个定义，所以每条说明都必须重复所有的基本要素，所以所有文字都要相互一致。这往往使手册读起来枯燥乏味，但是精确比生动更加重要。​ 概念的完整性的确要求系统只反映唯一的设计理念，用户所见的技术说明来自少数人的思想。实际工作被划分成体系结构、设计实现和物理实现，但这并不意味着该开发模式下的系统需要更长的时间来创建。经验显示恰恰相反，整个系统将会开发得更快，所需要的测试时间将更少。同工作的水平分割相比，垂直划分从根本上大大减少了劳动量，结果是使交流彻底地简化，概念完整性得到大幅提高。​ 体系结构同实现必须仔细地区分开来。如同 Blaauw 所说的，”体系结构陈述的是发生了什么，而实现描述的是如何实现 3。”他举了一个简单的例子–时钟。它的结构包括表面、指针和上发条的旋钮。当一个小孩知道了时钟的外表结构，他很容易从手表或者教堂上的时钟辨认时间。而时钟的实现，描述了表壳中的事物–很多种动力提供装置中的一种，以及众多控制精度方案的一种。​ 而进度压力却要求很多人员来开发系统。有两种方法可以解决这种矛盾。第一种是仔细地区分设计方法和具体实现。第二种是前一章节中所讨论的、一种崭新的组建编程开发团队的方法。​ 。项目的时间依赖于顺序上的限制，人员的数量依赖于单个子任务的数量。从这两个数值可以推算出进度时间表，该表安排的人员较少，花费的时间较长（唯一的风险是产品可能会过时）。相反，分派较多的人手，计划较短的时间，将无法得到可行的进度表。总之，在众多软件项目中，缺乏合理的时间进度是造成项目滞后的最主要原因，它比其他所有因素加起来的影响还要大 ​ 向进度落后的项目中增加人手，只会使进度更加落后。（Adding manpower to a late software project makes it later​ 因为软件开发本质上是一项系统工作–错综复杂关系下的一种实践–沟通、交流的工作量非常大，它很快会消耗任务分解所节省下来的个人时间。从而，添加更多的人手，实际上是延长了，而不是缩短了时间进度。]]></content>
      <categories>
        <category>专业书书摘</category>
      </categories>
      <tags>
        <tag>人月神话 黑客与画家 程序员思维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[4-7 月读书书摘]]></title>
    <url>%2F2017%2F08%2F10%2F4-7%E6%9C%88%E8%AF%BB%E4%B9%A6%E4%B9%A6%E6%91%98%2F</url>
    <content type="text"><![CDATA[皮囊 –蔡崇达 我没能说出口的是：厚朴，或许能真实地抵达这个世界的，能确切地抵达梦想的，不是不顾一切投入想象的狂热，而是务实、谦卑的，甚至你自己都看不起的可怜的隐忍。 梦想原来是卑微的执着。 他以为再走进去，就是无限宽广的可能；他以为正在和他对话的，已经是整个世界。 台风在于我从来没有悲伤的色彩，直到那一年。 小王子 –圣. 埃克苏佩里 。如果一个人听任自己被人驯服，那他就要冒流泪的风险…… 重要的东西眼睛是看不见的。 你一直不懂我的爱，这是我的错。不过这并不重要。但是你——你却和我一样傻。祝你幸福……将玻璃罩拿走吧，我不需要。” 我本应该根据事实而不是花言巧语来判断她。她用她的芬芳环绕着我，用她的光辉照耀着我。我真不该离开她……我应该猜出隐藏在她拙劣伎俩背后的所有温情。但我当时太小了，根本不知道怎样去爱她……” 月亮与六便士 –毛姆 恐惧使人们变得残酷无情…… 女人们禀性善良、喜爱虚荣，因此便认为这种感情极富于精神价值。但是在冲动的热情前面，这 种感情是毫无防卫能力的。 这是一种对任何一个人都可能产生的被动的感情，正象藤蔓可以攀附在随便哪株树上一样。因为 这种感情可以叫一个女孩子嫁给任何一个需要她的男人，相信日久天长便会对这个人产生爱情， 所以世俗的见解便断定了它的力量。但是说到底，这种感情是什么呢？它只不过是对有保障的生 活的满足，对拥有家资的骄傲，对有人需要自己沾沾自喜，和对建立起自己的家庭洋洋得意而已。 我觉得，在爱情的事上如 果考虑起自尊心来，那只能有 一个原因：实际上你还是最爱自己 有一些人很不幸，即使他们流露的是最真挚的感情也令人感到滑稽可笑，戴尔克·施特略夫正是这样一个人。 有人说灾难不幸可以使人性高贵，这句话并不对；叫人做出高尚行动的有时候反而是幸福得意，灾难不幸在大多数情况下只能使人们变得心胸狭小、报复心更强。 到了这一 地步，对那些不肯受良心约束的人，他就会觉得怎样责骂也不过分，因为他已经是社会的一名成 员，他知道得很清楚，绝对没有力量造自己的反了。 一个人要是跌进水里，他游泳游得好不好是无关紧要的，反正他得挣扎出去，不然就得淹死。”​ 这种生活模式给人以安详亲切之感。它使人想到一条平静 的小河，蜿蜒流过绿茸茸的牧场，与郁郁的树荫交相掩映，直到最后泻入烟波浩渺的大海中。但是大海却总是那么平静，总是沉默无言、声色不动，你会突然感到一种莫名的不安。也许这只是我自己的一种怪想法（就是在那些日子这种想法也常在我心头作祟），我总觉得大多数人这样度过一生好象欠缺一点什么。我承认这种生活的社会价值，我也看到了它的井然有序的幸福，但是 我的血液里却有一种强烈的愿望，渴望一种更狂放不羁的旅途。这种安详宁静的快乐好象有一种 叫我惊惧不安的东西。我的心渴望一种更加惊险的生活。只要在我的生活中能有变迁——变迁和 无法预见的刺激，我是准备踏上怪石嶙峋的山崖，奔赴暗礁满布的海滩的。 人们常常发现一位离了职的首相当年只不过是个大言不惭的演说家；一个解甲归田的将军无非是个平淡乏味的市井英雄。 目送 –龙应台 原来所有自己的当下啊，都是别人的过去。 幸福就是，寻常的日子依旧 幸福就是，生活中不必时时恐惧 你告诉我，什么是家，我就可以告诉你，什么是永恒。 有一段初始的生命，全世界只有这几个人知道，譬如你的小名，或者，你在哪一棵树上折断了手 是的，没有一种笑是铁打的 甚至眼泪也不是…… 你们之中，今天最聪明、最优秀的四个孩子，两个人会成为医生或工程师或商人，另外两个人会终其一生落魄而艰辛。所有其它的人，会经历结婚、生育、工作、退休，人生由淡淡的悲伤和淡淡的幸福组成，在小小的期待、偶尔的兴奋和沉默的失望中过每一天，然后带着一种想说却又说不来的『懂』，作最后的转身离开。」 如果在我们十二岁那年，有人跟我们这样上课，会怎么样？ 当然，没有一个老师，会对十二岁的孩子们这样说话。因为，这，哪能作人生的「座右铭」呢？ 天心月圆 也还相信。 譬如国也许不可爱，但是土地和人可以爱。譬如史也许不能信，但是对于真相的追求可以无止尽。譬如文明也许脆弱不堪，但是除文明外我们其实别无依靠。譬如正义也许极为可疑，但是在乎正义比不在乎要安全。譬如理想主义者也许成就不了大事大业，但是没有他们社会一定不一样。譬如爱情总是幻灭的多，但是萤火虫在夜里发光从来就不是为了保持光。譬如海枯石烂的永恒也许不存在，但是如果一粒沙里有一个无穷的宇宙，一刹那里想必也有一个不变不移的时间。 曾经相信过爱情，后来知道，原来爱情必须转化为亲情才可能持久，但是转化为亲情的爱情，犹如化入杯水中的冰块——它还是冰块吗？ 情人 –杜拉斯 我已经老了，有一天，在一处公共场所的大厅里，有一个男人向我走来。他主动介绍自己，他对我说：“我认识你，永远记得你。那时候，你还很年轻，人人都说你美，现在，我是特为来告诉你，对我来说，我觉得现在你比年轻的时候更美，那时你是年轻女人，与你那时的面貌相比，我更爱你现在备受摧残的面容。” 恨之所在，就是沉默据以开始的门槛。只有沉默可以从中通过，对我这一生来说，这是绵绵久远的苦役。我至今依然如故，面对这么多受苦受难的孩子，我始终保持着同样的神秘的距离。我自以为我在写作，但事实上我从来就不曾写过，我以为在爱，但我从来也不曾爱过，我什么也没有做，不过是站在那紧闭的门前等待罢了。 不要求取得什么，只求从当前的处境中脱身而去。 菊于刀 –本尼德克特 萨苏 刘锋 我们通常为因为财富产生的不平等而感到愤恨，但是在历史上，以财富的不平等代替出身的不平等却是人类的一个进步。因为，人无法选择出身，却可能通过自己的努力致富；虽然依然是不平等，却为每个人在人格上的平等打下了基础。为了争取到这样的不平等，法国付出了几十年不断的革命，英国经历了王位的反复兴废，从欧洲到亚洲染满了血腥……历史的发展中，五十步和一百步差别就是这样大。 荣枯鉴 –冯道 谤而不辩，其事自明，人恶稍减也；谤而强辩，其事反浊，人怨益增也 人微不诤，才庸不荐 位高节低，人贱义薄 人冀人愚而自明，示人以愚，其谋乃大；人忌人明而自愚，智无潜藏，其害无止 l 有的人总希望别人愚蠢而自己聪明，展示在众人面前是很愚笨的，这样的人具有非同小可的谋略；有的人忌妒别人聪明而自己愚蠢，才智也没有能力深深隐藏，这样的人将祸患无穷。 祸于上，无辩自罪者全；祸于下，争而罪人者免 孤独六讲 –蒋勋 这个社会要有一个从群众里走出去的孤独者，他才会比较有思考性，因为他走出去，可以回看群众的状态；如果他在群众当中，便没办法自觉。 我们看高空弹跳、赛车、极限表演，都是藉助观赏他者的冒险，发泄自己生命潜意识里的暴力倾向。 群体的道德意识往往会变成对他人的指责，在西方，道德观已经回归到个体的自我检视，对他人的批判不叫道德，对自己行为的反省才是 少有人走的路 –斯科特. 派克 你不可能宽恕一个没有罪过的人。宽恕只有在有罪裁决后才生效。 停止一个游戏，唯一的方式就是停止， 一个没有灵魂的人就像一张破碎的纸片，盲目地追逐着每一阵风，完全失去了掌控自己的能力，最终会成为魔鬼撒旦的工具，干出许多邪恶的事情。 恶，可以定义为：为了维护病态的自我， 不择手段去毁灭别人的自我。 恩典与个人之间的关系：“就像身体包裹在衣服里，血肉包裹在皮肤里，骨骼包裹在血肉里，心脏包裹在胸腔一样，我们的心灵和身体包裹在上帝的慈善之中。衣服、血肉、骨骼和心脏都会衰朽，而上帝的慈善却永远保持完整。 自由与约束相辅相成，没有约束作基础，自由带来的就不是真正的爱，而是情感的毁灭。 精神贯注表面上的代价之一，就是你迟早要为贯注对象的死亡或离去，让自己饱受痛苦的折磨。如果不想经受个中痛苦，就必须放弃生活中的许多事物，包括子女、婚姻、性爱、晋升和友谊，但唯有这些事物才能够使人生丰富多彩。在拓展自我的过程中，除了痛苦和悲伤，你同样可以收获快乐和幸福。完整的人生势必伴随着痛苦，其中最大的痛苦之一，就是心爱之人或心爱之物的逝去。如果你想避免其中的痛苦，那你恐怕只有完全脱离现实，去过没有任何意义的生活。 有些时候，我们宁可拒绝改变，也不愿忍受改变带来的痛苦，此时我们最需要的就是勇气。勇气，并不意味着永不恐惧，而是面对恐惧时能够坦然行动，克服畏缩心理，大步走向未知的未来。在某种意义上，心智的成熟（也即爱的实质）需要勇气，也需要冒险。 把“爱”挂在口头上，或只在脑海里去想象真正的爱，并以此作为爱的证据，这显然是轻而易举的事情，而表现出爱的行动却相当困难。真正的爱，其价值在于始终如一的行动，这远远大于转瞬即逝的感觉或者精神贯注。真正的爱出自自我意愿，只能依靠实际行动来证明。 ​ 想让别人真正爱你，只有让自己成为值得爱的人 坠入情网本身并不是爱，但它却是爱的神秘架构中最重要的一环。 对于某种事物长期的爱，使我们生活在了精神贯注的境界里，于是，我们的自我界限便开始延伸，延伸到一定程度后，自我界限就会淡化，而这时，我们的心智便获得了成熟 为了躲开责任带来的痛苦，数不清的人甘愿放弃权力，实则是在逃避自由。 哈佛商业评论 对美好事情的期待。比起美好事情，我们可能更钟情的是对其“渴求”的过程 对商场上的成功而言，技巧和好运缺一不可。就像文章开头所说，并没有简单的规则。但总体而言，战略勇气、适应能力和价值观决定的领导力在商场和战场上均可提高成功的可能性。 我们所畅想的新型雇主－雇员契约的重要性在于：虽然它并不以忠诚为基础，但它也不仅仅是纯粹的交易。它是组织与个人之间的联盟，联盟双方都致力于帮助彼此走向成功。 因为这种契约仍旧鼓励人员流动，这有碍于发挥员工生产力。更重要的是，虽然缺乏职业安全感直接促使员工更具适应能力与创业精神，但由于缺乏共同利益，其导致了逆向选择，也就是最具适应力与创业精神的员工反而另谋高就。企业节约了成本，但损失的是创新性与适应能力。 杀死一只知更鸟 –哈珀·李 从马耶拉张嘴喊叫的那一刻起，汤姆就死定了。 她们慢晃摇椅，轻挥罗扇，细斟慢饮地喝着冰水。 这个世界从表面上看来，只是一群香喷喷的女士 因为他刚安慰了我，所以我就说它看起来很可爱，但实际上我什么也没看见。“真不错，杰姆 他告诉过我，说带枪就等于邀请别人来射你。 勇敢是，当你还未开始就已知道自己会输，可你依然要去做，而且无论如何都要把它坚持到底。 道理很简单，不能因为我们开始前已经失败了一百年，就认为我们没有理由去争取胜利。 阿蒂克斯说过去掉那些形容词，剩下的就是事实了 当然不应该那样做，不过他永远不会改变他的生活方式。你不会再抱怨他的孩子们了吧？​ 霍乱时期的爱情 –加西亚. 马尔克斯 他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 ​ 无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了 “你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定 当她在成为寡妇后的第一个早晨醒来，闭着眼睛在床上翻了个身，想找一个更舒服的姿势继续睡下去，就在这一刻，她才真正意识到他死了。也只有在这时，她才察觉到，这是他多年来第一次没有在家过夜。另一个触动她的情境是在餐桌前，但不是因为感到孤单，尽管事实的确如此，而是因为她奇怪地相信，自己正在同某个已不存在的人一起用餐 ​ 她无法摆脱隐藏在心底的怨恨，怨丈夫将她孤零零地遗弃在这汪洋大海之中 ​ 在这么多年一次次精心算计的爱情之后，天真无邪的生涩味道别有一番新鲜的堕落的快乐 “我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。” 曾经，每天的每分每秒都胜似他的盟友，如今却开始算计他 但最终，他还是让步了，弗洛伦蒂诺·阿里萨把镜子挂到了自己家中，却并不是因为那镜框的精雕细琢，而是因为镜子里的那片天地，他爱恋的形象曾在那里占据了两个小时之久 ​ 他们终于彻底了解了对方，在结婚将近三十年时，他们变得好似一个人被分成了两半，常常因为对方猜出自己没有说出口的心事，或者一个抢先把另一个想说的话公之于众的荒唐事件而感到不悦。 ​ 她丈夫爱她胜过一切，胜过世间所有的人，但这也仅仅是为了他自己：这是他的神圣义务。 ，唯一可能的解释——就像她常说的那样——便是她怨恨丈夫明知故犯地为一群黑人牺牲了性命，而唯一正确的牺牲应该是为了她活下去 ​ 但当她们独自去望弥撒时，才逐渐意识到，自己又一次成为自己意愿的主人，当初，为了换取一种安全感，她们不仅放弃了自己家庭的姓氏，甚至放弃了自我，可那种安全感不过是她们做姑娘时许多幻想中的一个罢了。只有她们自己知道，她们曾经疯狂爱着的那个男人——尽管他或许也爱着她们——给她们带来的负担有多么沉重，她们不得不照顾他们直到最后一口气，喂他们吃喝，给他们换下脏兮兮的尿布，用母亲式的巧妙花招哄他们开心，以减轻他们清晨走出家门去直面现实的恐惧。可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 ​ 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 ​ 说不清究竟是欧洲之行改变了他们，还是爱情改变了他们，因为这两者是同时发生的。它们都起了作用，更深一层说，改变的不仅是他们两人，也是所有人，就像弗洛伦蒂诺·阿里萨在那个不幸的星期日，他们回来两周后，看见他们望完弥撒从教堂中走出来时所察觉到的那样。 ​ 尽管并非有意，但这样处理匿名信的方式是正确的，其实那些不敢留名的人所属的阶层，在历史的嘲弄下，早已习惯了对既成的事实低头 ​ 可洛伦索·达萨以桶匠的大度吞下所受的侮辱，继续执著地依靠智慧创造偶遇胡维纳尔·乌尔比诺的机会，却没有发现其实是胡维纳尔·乌尔比诺付出了更为超常的努力，尽一切可能让两人相遇 “这座城市还真是伟大，”他常常说，“我们用了四百年的时间来摧毁它，至今仍没有达成目的。 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们靠私下里抽签来决定谁做他的女伴，而他也乐得与她们相处，但总是若即若离，始终保持着清雅，直到最后，他不可救药地被费尔明娜·达萨那种质朴的魅力迷住了 ​ 但与那时不同，此刻她没有感到爱情的震撼，而是坠入了失望的深渊。 ​ 四个世纪以来，除了在凋谢的月桂树和腐臭的沼泽间慢慢衰老，这里什么都没有发生 不可避免，苦杏仁的气味总是让他想起爱情受阻后的命运]]></content>
      <categories>
        <category>书摘</category>
      </categories>
      <tags>
        <tag>读书书摘</tag>
      </tags>
  </entry>
</search>
